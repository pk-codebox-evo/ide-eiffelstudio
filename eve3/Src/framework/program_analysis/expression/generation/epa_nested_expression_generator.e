note
	description: "Summary description for {AFX_NESTED_EXPRESSION_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	EPA_NESTED_EXPRESSION_GENERATOR

inherit
	EPA_EXPRESSION_GENERATOR

	EPA_ACCESS_AGENT_UTILITY

	SHARED_WORKBENCH

	SHARED_TYPES

	REFACTORING_HELPER

	EPA_SHARED_EXPR_TYPE_CHECKER

	SHARED_NAMES_HEAP

create
	make

feature{NONE} -- Initialization

	make is
			-- Initialize Current.
		do
			level := 2
			create accesses.make (initial_capacity)

			create expression_veto_agents.make (10)
			initialize_expression_veto_agents
		end

feature -- Access

	level: INTEGER
			-- Level to which expression are built
			-- A level means a level of nested expression.
			-- Level 1 means a single level of expression, for example, is_empty, has (v), Result, local variables. (Current is omitted).
			-- Default: 2.

	expression_veto_agents: HASH_TABLE [FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN], INTEGER]
			-- Agent to decide at each level, which expression should be included.
			-- Key is the level number, value is the decider agent at that level.
			-- If the agent returns True, the expression in its argument is included,
			-- otherwise, the expression is not included.

	final_expression_veto_agent: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
			-- Expression veto agent for final result in `accesses'.
			-- Used to further strip the items in `accesses'.

	accesses: ARRAYED_LIST [EPA_ACCESS]
			-- List of accesses that are generated by last `generate'	

feature -- Basic operations

	set_level (a_level: INTEGER)
			-- Set `level' with `a_leve'.
		require
			a_level_positive: a_level >= 1
		do
			level := a_level
		ensure
			level_set: level = a_level
		end

	set_final_expression_veto_agent (a_agent: like final_expression_veto_agent)
			-- Set `final_expression_veto_agent' with `a_agent'.
		do
			final_expression_veto_agent := a_agent
		ensure
			final_expression_veto_agent_set: final_expression_veto_agent = a_agent
		end

	generate_for_dummy_feature (a_context: EPA_CONTEXT)
			-- Generate accesses for dummy feature defined in `a_context'.
		local
			l_new: ARRAYED_LIST [EPA_ACCESS]
			l_accesses: like accesses
			l_local_tbl: HASH_TABLE [TYPE_A, STRING]
			l_position: INTEGER
			l_cursor: CURSOR
			l_access_local: EPA_ACCESS_LOCAL
			l_veto: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
		do
			context_class := a_context.class_
			context_feature := a_context.feature_
			create accesses.make (initial_capacity)
			l_accesses := accesses

				-- Generate accesses for FAKE local variables.
				-- Those local variables are fake becaue `context_feature' is a dummy feature.
			l_local_tbl := a_context.variables
			l_cursor := l_local_tbl.cursor
			l_veto := expression_veto_agents.item (1)
			from
				l_local_tbl.start
			until
				l_local_tbl.after
			loop
				create l_access_local.make (context_class, context_feature, context_class, l_local_tbl.key_for_iteration, l_position, l_local_tbl.item_for_iteration)
				if l_veto.item ([l_access_local]) then
					l_accesses.extend (l_access_local)
				end
				l_local_tbl.forth
			end
			l_local_tbl.go_to (l_cursor)

				-- Generate expressions at level 2 or above.
			generate_for_level_2_or_above
		end

	generate (a_class: CLASS_C; a_feature: FEATURE_I)
			-- Generate accesses for `a_feature' in `a_class' and
			-- store results in `accesses'.
		local
			l_new: ARRAYED_LIST [EPA_ACCESS]
			l_accesses: like accesses
		do
			fixme ("a_feature needs to be attached now, but is not necessary. 27.11.2009 Jasonw")
			context_class := a_class
			context_feature := a_feature

			create accesses.make (initial_capacity)
			l_accesses := accesses
			l_new := initial_accesses (a_class, a_feature)
			l_accesses.append (l_new)

			generate_for_level_2_or_above
		end

feature{NONE} -- Implementation

	accesses_at_level (a_accesses: like accesses; a_level: INTEGER): like accesses
			-- New accesses at level `a_level', built from existing `a_accesses'
		require
			a_level_valid: a_level > 1
		local
			l_class: CLASS_C
			l_accesses: like accesses
			l_veto_agent: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
		do
			create Result.make (initial_capacity)
			l_accesses := a_accesses.twin
			from
				l_accesses.start
			until
				l_accesses.after
			loop
				l_class := l_accesses.item_for_iteration.type.associated_class
				check l_class /= Void end

				if expression_veto_agents.has (a_level) then
					l_veto_agent := expression_veto_agents.item (a_level)
				else
					l_veto_agent := default_access_veto_agent
				end
				Result.append (feature_accesses_of_class (l_accesses.item_for_iteration, l_class, a_accesses, l_veto_agent))
				l_accesses.forth
			end
		end

	feature_accesses_of_class (a_prefix: EPA_ACCESS; a_class: CLASS_C; a_args: like accesses; a_veto_agent: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]): like accesses
			-- Feature accesses for features in `a_class' which is filtered by `a_veto_agent'.
			-- Arguments to those feature accesses are from `a_args'.
		local
			l_feats: FEATURE_TABLE
			l_cursor: CURSOR
			l_feat: FEATURE_I
			l_new: like accesses
		do
			create Result.make (initial_capacity)
			l_feats := a_class.feature_table
			l_cursor := l_feats.cursor
			from
				l_feats.start
			until
				l_feats.after
			loop
				l_feat := l_feats.item_for_iteration
				if not l_feat.type.is_void then
					l_new := accesses_of_feature (a_prefix, a_class, l_feat, a_args, a_veto_agent)
					Result.append (l_new)
				end
				fixme ("Wield program that `l_feats'.after is True here. 31.5.2010 Jasonw")
				if not l_feats.after then
					l_feats.forth
				end
			end
			l_feats.go_to (l_cursor)
		end

	accesses_of_feature (a_prefix: EPA_ACCESS; a_class: CLASS_C; a_feature: FEATURE_I; a_terms: like accesses; a_veto_agent: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]): like accesses
			-- Feature accesses starting from `a_prefix' for `a_feature' in `a_class', which is filtered by `a_veto_agent'.
			-- Arguments to those feature accesses are from `a_terms'.
		require
			a_feature_is_query: not a_feature.type.is_void
		local
			j: INTEGER
			l_feat_acc: EPA_ACCESS_FEATURE
			l_args: ARRAY [EPA_ACCESS]
			l_arg_type: TYPE_A
			l_term: EPA_ACCESS
			l_arg_index: INTEGER
			l_checked: ARRAY [INTEGER]
			l_list: LINKED_LIST [EPA_ACCESS]
			l_nested: EPA_ACCESS_NESTED
			l_term_type: TYPE_A
		do
			create Result.make (initial_capacity)

			if a_feature.argument_count = 0 then
				create l_list.make
				create l_feat_acc.make (context_class, context_feature, a_feature, l_list, context_feature.written_class)
				create l_nested.make (a_prefix, l_feat_acc)
				if a_veto_agent.item ([l_nested]) then
					Result.extend (l_nested)
				end
			else
				create l_checked.make (1, a_feature.argument_count) -- For backtracking
				create l_args.make (1, a_feature.argument_count)
				from
					j := 1
					l_arg_index := 1
					l_checked.put (1, l_arg_index)
				until
					l_arg_index = 0
				loop
					if j <= a_terms.count then
						l_term := a_terms.i_th (j)
						l_term_type := l_term.type.actual_type
						l_term_type := actual_type_from_formal_type (l_term_type, a_class)
						l_term_type := l_term_type.associated_class.constraint_actual_type
						l_arg_type := a_feature.arguments.i_th (l_arg_index).instantiation_in (a_class.actual_type, a_class.class_id).actual_type
						l_arg_type := actual_type_from_formal_type (l_arg_type, a_class)
						l_arg_type := l_arg_type.associated_class.constraint_actual_type
						fixme ("This implementation is slow, to make it faster, type information of l_term can be cached. 2.11.2009 Jasonw")
						if l_term_type.conform_to (a_class, l_arg_type) then
							l_args.put (l_term, l_arg_index)
							l_checked.put (j, l_arg_index)
							if l_arg_index = a_feature.argument_count then
								create l_list.make
								l_args.do_all (agent l_list.extend)
								create l_feat_acc.make (context_class, context_feature, a_feature, l_list, context_feature.written_class)
								create l_nested.make (a_prefix, l_feat_acc)
								if a_veto_agent.item ([l_nested]) then
									Result.extend (l_nested)
								end
								j := j + 1
							else
								l_arg_index := l_arg_index + 1
								j := 1
							end
						else
							j := j + 1
						end
					else
						l_arg_index := l_arg_index - 1
						if l_arg_index > 0 then
							j := l_checked.item (l_arg_index) + 1
						end
					end
				end
			end
		end

	initial_accesses (a_class: CLASS_C; a_feature: detachable FEATURE_I): like accesses
			-- Initial accesses including possibly Current, Result, locals, arguments.
		local
			l_new: ARRAYED_LIST [EPA_ACCESS]
			l_access: EPA_ACCESS
			l_level: INTEGER
			l_veto: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
			i: INTEGER
			l_locals: HASH_TABLE [LOCAL_INFO, INTEGER]
			l_local: LOCAL_INFO
		do
				-- Setup the initial accesses.
			create l_new.make (initial_capacity)

			l_new.extend (create {EPA_ACCESS_CURRENT}.make (a_class, a_feature, a_feature.written_class))
			if not a_feature.type.is_void then
				l_new.extend (create {EPA_ACCESS_RESULT}.make (a_class, a_feature, a_feature.written_class))
			end

				-- Generate arguments.
			from
				i := 1
			until
				i > a_feature.argument_count
			loop
				l_new.extend (create {EPA_ACCESS_ARGUMENT}.make (a_class, a_feature, a_feature.written_class, i))
				i := i + 1
			end

				-- Generate locals.
			l_locals := expression_type_checker.local_info (a_class, a_feature)
			if not l_locals.is_empty then
				from
					l_locals.start
				until
					l_locals.after
				loop
					l_local := l_locals.item_for_iteration
					l_new.extend (create {EPA_ACCESS_LOCAL}.make (a_class, a_feature, a_feature.written_class, names_heap.item (l_locals.key_for_iteration), l_local.position, l_local.type))
					l_locals.forth
				end
			end

			l_level := 1
			l_veto := expression_veto_agents.item (l_level)
			from
				l_new.start
			until
				l_new.after
			loop
				if l_veto.item ([l_new.item_for_iteration]) then
					l_new.forth
				else
					l_new.remove
				end
			end
			Result := l_new
		end

feature{NONE} -- Implementation

	initial_capacity: INTEGER is 20
			-- Initial capacity for `accesses'

	context_class: CLASS_C
			-- Context class

	context_feature: FEATURE_I
			-- Context feature

	default_access_veto_agent: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
			-- Default access veto agent
		do
			Result :=
				anded_agents (<<feature_expression_veto_agent, feature_not_from_any_veto_agent, nested_not_on_basic_veto_agent>>)
		end

	initialize_expression_veto_agents is
			-- Initialize `expression_veto_agents' and `final_expression_veto_agent'
		do
			expression_veto_agents.put (
				anded_agents (
					<<ored_agents (
						<<result_expression_veto_agent,
					  	  current_expression_veto_agent,
					  	  argument_expression_veto_agent,
					  	  local_expression_veto_agent>>),
					feature_not_from_any_veto_agent>>),
					 	 1)

			expression_veto_agents.put (
				anded_agents (<<
					feature_expression_veto_agent,
					feature_not_from_any_veto_agent,
					nested_not_on_basic_veto_agent,
					feature_not_obsolete_veto_agent,
					feature_with_few_arguments_veto_agent (0)>>), 2)

			final_expression_veto_agent :=
				ored_agents (<<
					integer_expression_veto_agent,
					boolean_expression_veto_agent>>)
		end

	generate_for_level_2_or_above
			-- Generate expressions for level two or above.
		local
			l_level: INTEGER
			l_veto: FUNCTION [ANY, TUPLE [EPA_ACCESS], BOOLEAN]
			l_accesses: like accesses
		do
			l_accesses := accesses
			from
				l_level := 2
			until
				l_level > level
			loop
				l_accesses.append (accesses_at_level (l_accesses, l_level))
				l_level := l_level + 1
			end

				-- Strip results with `final_expression_veto_agent'.
			if final_expression_veto_agent /= Void then
				l_veto := final_expression_veto_agent
			else
				l_veto := default_access_veto_agent
			end
			from
				l_accesses.start
			until
				l_accesses.after
			loop
				if l_veto.item ([l_accesses.item]) then
					l_accesses.forth
				else
					l_accesses.remove
				end
			end
		end

end

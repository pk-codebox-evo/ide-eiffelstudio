note
	description: "The class will parse the model file generated by rapid miner into a tree."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	RM_DECISION_TREE_PARSER

inherit
	RM_DECISION_TREE_PARSER_INTERFACE redefine
		parse_model
	end

create
	make

feature{NONE} -- Implementation

	stack : LINKED_STACK [RM_DECISION_TREE_STACK_ITEM]
		-- Stack needed for parsing the file

feature {NONE} -- Construction

	make(a_model_file_path: STRING)
		require
			file_name_not_null: not a_model_file_path.is_empty
		do
			model_file_path := a_model_file_path
			create stack.make
			tree_root := Void
		end

feature -- Interface

	parse_model
			-- Parses the model file generated by rapidminer. The path to the file is saved in `model_file_path'.
		local
			l_model_file: PLAIN_TEXT_FILE
			l_line: STRING
			l_stack_item: RM_DECISION_TREE_STACK_ITEM
			l_depth: INTEGER
			l_node: RM_DECISION_TREE_NODE
		do
			tree_root := Void
			create l_model_file.make_open_read (model_file_path)
			if not l_model_file.is_empty then
				l_model_file.start
				-- just skip the first 2 lines, since they hold the dates
				l_model_file.read_line
				l_model_file.read_line
				handle_trivial_tree(l_model_file.last_string)
				from until l_model_file.end_of_file loop
					l_model_file.read_line
					l_line := l_model_file.last_string
					if l_line.count > 0 then
						create_new_node (l_line)
					end
				end
				if not stack.is_empty then
					tree_root := stack.linear_representation[stack.count].node
					stack.wipe_out
				end
			end
		end

feature{RM_DECISION_TREE_PARSER} -- Parsing helper functions

	handle_trivial_tree (a_line: STRING)
			-- This will handle the case of a trivial tree. RM prints the trivial node of the tree next to
			-- the date on the second line in the model file. It is assumed that if there is a leaf on that line
			-- then there are no more node down the file.
		local
			l_node: RM_DECISION_TREE_NODE
		do
			if has_leaf (a_line) then -- we have a trivial tree
				create l_node.make (extract_leaf_name (a_line), True)
				l_node.parse_samples (a_line)
				tree_root := l_node
			end
		end

	create_new_node (a_line: STRING)
		-- Parses the line, creates the nodes and edges that it contains and saves them into `stack`.
		local
			l_depth: INTEGER
			l_line: STRING
			l_name: STRING
			l_condition: STRING
			l_leaf: detachable RM_DECISION_TREE_NODE
		do
			l_depth := extract_depth (a_line)
			l_line := clean_line (a_line)
			if has_leaf(l_line) then
				create l_leaf.make (extract_leaf_name (l_line), True)
				l_leaf.parse_samples (l_line)
				l_line := clear_leaf_details (l_line)
			end
			l_name := extract_node_name (l_line)
			l_condition := extract_condition (l_line)
			handle_add_to_stack (l_name, l_depth, l_condition)
			if l_leaf /= Void then
				stack.item.node.add_child (l_leaf, stack.item.condition)
				l_leaf := Void
			end
		end

	handle_add_to_stack (a_name: STRING; a_depth: INTEGER; a_condition: STRING)
		-- adds another item in the stack making sure that the new element is added
		-- only when the top element of the stack has smaller depth. If depth is equal
		-- just the condition is changed
		do
			if stack.is_empty then
				add_to_stack(a_name, a_depth,a_condition)
			elseif stack.item.depth < a_depth then
				add_to_stack(a_name, a_depth, a_condition)
			elseif stack.item.depth = a_depth then
				stack.item.set_condition(a_condition)
			elseif stack.item.depth > a_depth then
				stack.remove
				handle_add_to_stack(a_name, a_depth, a_condition)
			end
		end

	clear_leaf_details (a_line:STRING): STRING
			-- will delete everything after the : before the leaf value including it
		require
			has_leaf (a_line)
		local
			l_index: INTEGER
		do
			l_index := a_line.last_index_of (':', a_line.count) - 1
			Result := a_line.substring (1, l_index)
		end


	extract_leaf_name (a_line: STRING): STRING
			-- extracts the leaf name from a string.
		require
			is_leaf: has_leaf (a_line)
		local
			l_index_end, l_index_start: INTEGER
		do
			l_index_start := a_line.last_index_of (':', a_line.count) + 2
			l_index_end := a_line.last_index_of ('{', a_line.count) - 2
			Result := a_line.substring (l_index_start, l_index_end)
		end

	add_to_stack (a_name: STRING; a_depth: INTEGER; a_condition: STRING)
		-- creates a RM_DT_STACK_ITEM and pushes it on top of the stack
		local
			l_stack_item: RM_DECISION_TREE_STACK_ITEM
			l_node: RM_DECISION_TREE_NODE
		do
			create l_node.make (a_name, false)
			if not stack.is_empty then
				stack.item.node.add_child (l_node, stack.item.condition)
			end
			create l_stack_item.make (l_node, a_condition, a_depth)
			stack.put (l_stack_item)
		ensure
			stack.count = old stack.count + 1
		end

	clean_line (a_line: STRING): STRING
		-- removes the trailing '|' from the beginning of the line
		do
			if extract_depth (a_line) > 0 then
				Result := a_line.substring (a_line.last_index_of ('|', a_line.count)+4, a_line.count)
			else
				Result := a_line
			end
		end

	extract_depth (a_line: STRING): INTEGER
			-- tells us how many levels deep is the node on this line
		do
			Result := a_line.last_index_of ('|', a_line.count)
			Result := (Result + 3)//4
		end

	extract_node_name (a_line: STRING): STRING
			-- extracts the node name from a rapidminer modelfile line
		local
			l_index: INTEGER
		do
			l_index := find_operator_index (a_line) - 1
			Result := a_line.substring (1, l_index)
		end

	extract_condition (a_line: STRING): STRING
			-- extracts the condition from tha rapidminder model file line
		local
			l_index_start: INTEGER
		do
			l_index_start := find_operator_index (a_line) + 1
			Result := a_line.substring (l_index_start, a_line.count)
		end

	find_operator_index (a_line: STRING): INTEGER
			-- returns the index of the operator in this line
		local
			l_index: INTEGER
			l_found: BOOLEAN
		do
			from l_index := a_line.count until l_index = 0 or l_found loop
				if a_line.at (l_index) = '=' or a_line.at (l_index) = '<' or a_line.at (l_index) = '>' or a_line.at (l_index).code = 226 then
					l_found := True
				end
				l_index := l_index - 1
			end
			Result := l_index
		end

	has_leaf (a_line: STRING): BOOLEAN
		-- tells if a line from the model file produced by RM has a leaf node in it.
		do
			if a_line.ends_with ("}") and a_line.has ('{')then
				Result := True
			end
		ensure
			true_if_has_semicolon: Result implies a_line.ends_with ("}")
		end

invariant
	invariant_clause: True -- Your invariant here

end

note
	description: "[
		The class will parse the model file generated by rapid miner into a decision tree.
		This parser is able to parse decision trees in native RapidMiner format or in Weka format.
		]"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	RM_DECISION_TREE_PARSER

inherit
	RM_DECISION_TREE_PARSER_INTERFACE
		redefine
			parse
		end

create
	make

feature {NONE} -- Construction

	make (a_model_file_path: STRING)
		require
			file_name_not_null: not a_model_file_path.is_empty
		do
			model_file_path := a_model_file_path
			create stack.make
			last_node := Void
		end

feature -- Access

	last_node_as_tree (a_label_name: STRING): RM_DECISION_TREE
			-- Decision tree built from `last_node' which
			-- classifies the attribute named `a_label_name'
		do
			create Result.make (last_node, a_label_name)
		end

feature -- Interface

	parse
			-- Parses the model file generated by rapidminer. The path to the file is saved in `model_file_path'.
		local
			l_leaf_value: STRING
			l_tree_body_lines: like tree_body_lines_from_file
		do
			last_node := Void
			l_tree_body_lines := tree_body_lines_from_file (model_file_path)

				-- Parse lines in `l_tree_body_lines' to generate a decision tree.
			if l_tree_body_lines.count = 1 then
					-- We have a single node tree.
				check is_leaf_node (l_tree_body_lines.first) end
				l_leaf_value := leaf_name (l_tree_body_lines.first)
				create last_node.make (l_leaf_value, True)
				last_node.parse_accuracy_performance (l_leaf_value, l_tree_body_lines.first)
			else
					-- We have a multi-node tree.
				across l_tree_body_lines as l_lines loop
					create_new_node (l_lines.item)
				end
				if not stack.is_empty then
					last_node := stack.linear_representation [stack.count].node
					stack.wipe_out
				end
			end
		end

feature{RM_DECISION_TREE_PARSER} -- Parsing helper functions

--	handle_trivial_tree (a_line: STRING)
--			-- This will handle the case of a trivial tree. RM prints the trivial node of the tree next to
--			-- the date on the second line in the model file. It is assumed that if there is a leaf on that line
--			-- then there are no more node down the file.
--		local
--			l_node: RM_DECISION_TREE_NODE
--			l_leaf_value: STRING
--		do
--			if is_leaf_node (a_line) then -- we have a trivial tree
--				l_leaf_value := leaf_name (a_line)
--				create l_node.make (l_leaf_value, True)
--				l_node.parse_samples (l_leaf_value, a_line)
--				last_node := l_node
--			end
--		end

	create_new_node (a_line: STRING)
			-- Parses the line, creates the nodes and edges that it contains and saves them into `stack`.
		local
			l_depth: INTEGER
			l_line: STRING
			l_name: STRING
			l_condition: STRING
			l_leaf: detachable RM_DECISION_TREE_NODE
			l_leaf_value: STRING
		do
			l_depth := node_depth (a_line)
			l_line := clean_line (a_line)
			if is_leaf_node (l_line) then
				l_leaf_value := leaf_name (l_line)
				create l_leaf.make (l_leaf_value, True)
				l_leaf.parse_accuracy_performance (l_leaf_value, l_line)
				l_line := cleared_leaf_details (l_line)
			end
			l_name := node_name (l_line)
			l_condition := condition (l_line)
			handle_add_to_stack (l_name, l_depth, l_condition)
			if l_leaf /= Void then
				stack.item.node.add_child (l_leaf, stack.item.condition)
				l_leaf := Void
			end
		end

	handle_add_to_stack (a_name: STRING; a_depth: INTEGER; a_condition: STRING)
			-- Adds another item in the stack making sure that the new element is added
			-- only when the top element of the stack has smaller depth. If depth is equal
			-- just the condition is changed
		do
			if stack.is_empty then
				add_to_stack (a_name, a_depth, a_condition)
			elseif stack.item.depth < a_depth then
				add_to_stack (a_name, a_depth, a_condition)
			elseif stack.item.depth = a_depth then
				stack.item.set_condition (a_condition)
			elseif stack.item.depth > a_depth then
				stack.remove
				handle_add_to_stack (a_name, a_depth, a_condition)
			end
		end

	cleared_leaf_details (a_line:STRING): STRING
			-- Will delete everything after the : before the leaf value including it
		require
			is_leaf_node (a_line)
		local
			l_index: INTEGER
		do
			l_index := a_line.last_index_of (':', a_line.count) - 1
			Result := a_line.substring (1, l_index)
		end

	leaf_name (a_line: STRING): STRING
			-- Extracts the leaf name from a string.
		require
			is_leaf: is_leaf_node (a_line)
		local
			l_index_end, l_index_start: INTEGER
		do
			l_index_start := a_line.last_index_of (':', a_line.count) + 2
			if a_line.ends_with (once "}") then
					-- Native RapidMiner ending.
				l_index_end := a_line.last_index_of ('{', a_line.count) - 2
			else
					-- Weka ending.
				l_index_end := a_line.last_index_of ('(', a_line.count) - 2
			end
			Result := a_line.substring (l_index_start, l_index_end)
		end

	add_to_stack (a_name: STRING; a_depth: INTEGER; a_condition: STRING)
		-- creates a RM_DT_STACK_ITEM and pushes it on top of the stack
		local
			l_stack_item: RM_DECISION_TREE_STACK_ITEM
			l_node: RM_DECISION_TREE_NODE
		do
			create l_node.make (a_name, false)
			if not stack.is_empty then
				stack.item.node.add_child (l_node, stack.item.condition)
			end
			create l_stack_item.make (l_node, a_condition, a_depth)
			stack.put (l_stack_item)
		ensure
			stack.count = old stack.count + 1
		end

	clean_line (a_line: STRING): STRING
			-- Remove the heading '|' from the beginning of the line
		do
			if node_depth (a_line) > 0 then
				Result := a_line.substring (a_line.last_index_of ('|', a_line.count) + 4, a_line.count)
			else
				Result := a_line
			end
		end

	node_depth (a_line: STRING): INTEGER
			-- Tells us how many levels deep is the node on this line
		do
			Result := a_line.last_index_of ('|', a_line.count)
			Result := (Result + 3) // 4
		end

	node_name (a_line: STRING): STRING
			-- Extracts the node name from a rapidminer model file line.
		local
			l_index: INTEGER
		do
			l_index := operator_index (a_line) - 1
			Result := a_line.substring (1, l_index)
			Result.left_adjust
			Result.right_adjust
		end

	condition (a_line: STRING): STRING
			-- Extracts the condition from tha rapidminder model file line.
		local
			l_index_start: INTEGER
		do
			l_index_start := operator_index (a_line)
			Result := a_line.substring (l_index_start, a_line.count)
			Result.left_adjust
			Result.right_adjust
		end

	operator_index (a_line: STRING): INTEGER
			-- Returns the index of the operator in this line
		require
			leaf_cleaned: not is_leaf_node (a_line)
		local
			l_section: STRING
			l_first_space_index: INTEGER
			l_second_space_index: INTEGER
		do
			if is_leaf_node (a_line) then
					-- Leaf node.
				l_section := a_line.substring (1, a_line.last_index_of (':', a_line.count) - 1)
			else
					-- Non-leaf node.
				l_section := a_line.twin
			end
			l_section.right_adjust

			l_second_space_index := l_section.last_index_of (' ', l_section.count)
			l_first_space_index := l_section.last_index_of (' ', l_second_space_index - 1)
			Result := l_first_space_index + 1
		end

	is_leaf_node (a_line: STRING): BOOLEAN
		-- Tells if a line from the model file produced by RM has a leaf node in it.
		do
			if a_line.ends_with ("}") and a_line.has ('{')then
					-- Native RapidMiner ending.
				Result := True
			elseif a_line.ends_with (")") and a_line.has ('(') then
					-- Weka ending.
				Result := True
			end
		end

	stack: LINKED_STACK [RM_DECISION_TREE_STACK_ITEM]
		-- Stack needed for parsing the file

	tree_body_lines_from_file (a_path: STRING): LINKED_LIST [STRING]
			-- Lines representing a decision tree from file whose absolute
			-- path is given in `a_path'
		local
			l_line: STRING
			l_in_tree_body: BOOLEAN
			l_model_file: PLAIN_TEXT_FILE
		do
			create Result.make
			create l_model_file.make_open_read (a_path)
			if not l_model_file.is_empty then
				from
						-- just skip the first 2 lines, since they hold the dates
					l_model_file.read_line
					l_model_file.read_line
				until
					l_in_tree_body
				loop
					l_model_file.read_line
					l_line := l_model_file.last_string.twin
					l_line.left_adjust
					l_line.right_adjust
					if not l_line.is_empty then
						if not l_line.starts_with (once "-------") then
							l_in_tree_body := True
						end
					end
				end

					-- Load all lines for the decision tree in Result.
				from
				until
					l_model_file.end_of_file or else not l_in_tree_body
				loop
					l_line := l_model_file.last_string.twin
					l_line.left_adjust
					l_line.right_adjust
					if l_line.is_empty then
						l_in_tree_body := False
					else
						Result.extend (l_line)
					end
					l_model_file.read_line
				end
				l_model_file.close
			end
		end

end

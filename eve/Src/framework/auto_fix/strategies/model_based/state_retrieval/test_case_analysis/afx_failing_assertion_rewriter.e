note
	description: "Summary description for {AFX_FAILING_ASSERTION_REWRITER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_FAILING_ASSERTION_REWRITER

inherit
	REFACTORING_HELPER

	EPA_CONTRACT_EXTRACTOR

	AFX_UTILITY

	SHARED_SERVER

	COMPILER_EXPORTER

	SHARED_TYPES

feature -- Access

	assertion: detachable EPA_EXPRESSION
			-- Failing assertion as appeared in
			-- Expression representing the failing assertion as appeared in recipient,
			-- generated by the last `rewrite'.
			-- It has been rewritten in the context of the recipient.

	original_assertion: detachable EPA_EXPRESSION
			-- Original assertion for `assertion', different from `assertion' in precondition violation,
			-- same as `assertion' for other types of assertion violations.

	feature_of_assertion: detachable FEATURE_I
			-- Feature which contains `assertion'
			-- If the exception is a precondition violation, `feature_of_assertion' is the feature containing the precondition.
			-- Otherwise, `feature_of_assertion' is the same as the recipient of the exception.

	class_of_feature_of_assertion: detachable CLASS_C
			-- Context class of `feature_of_assertion'

	assertion_break_point_slot: INTEGER
			-- Break point slot for `assertion'.
			-- If the exception is a precondition violation, this is the break point slot for the failing routine call in recipient.
			-- Otherwise, this is equal to `test_case_info'.`break_point_slot'.

	actual_argument_expressions: HASH_TABLE [EPA_EXPRESSION, INTEGER]
			-- Expressions that are mentioned as actual arguments in the failing routine if the exception is a precondition violation.
			-- For other types of exception, this hashtalbe is empty.
			-- Key is the argument index, value is the mentioned expression for that argument.

	target_expression: detachable EPA_EXPRESSION
			-- Target expression of `feature_of_failing_assertion'
			-- Void means that `feature_of_failing_assertion' is a unqualified call.

feature -- Basic operations

	rewrite (a_tc: EPA_TEST_CASE_SIGNATURE; a_structure: AFX_FEATURE_AST_STRUCTURE_NODE; a_trace: STRING)
			-- Generate the rewritten failing assertion.
			-- The generated assertion should appear in the context of `a_tc'.recipient_'.
			-- `a_structure' stores the AST sturcture of `a_tc'.recipient_'.
		local
			l_failing_expr: detachable EPA_EXPRESSION
		do
			feature_of_assertion := a_tc.recipient_
			class_of_feature_of_assertion := a_tc.recipient_class_
			assertion_break_point_slot := a_tc.breakpoint_slot

			create actual_argument_expressions.make (2)
			if a_tc.exception_code = {EXCEP_CONST}.precondition then
				analyze_precondtion_violation (a_tc, a_structure, a_trace)
			elseif a_tc.exception_code = {EXCEP_CONST}.Void_call_target then
				analyze_void_call_target (a_tc, a_structure, a_trace)
			else
				if a_tc.exception_code = {EXCEP_CONST}.check_instruction then
					if attached {TAGGED_AS} a_structure.relevant_ast (a_tc.breakpoint_slot) as l_check_ast then
						create {EPA_AST_EXPRESSION}l_failing_expr.make (l_check_ast.expr, a_tc.recipient_class_, a_tc.recipient_class_)
					else
						check should_not_happen: False end
					end
				elseif a_tc.exception_code = {EXCEP_CONST}.postcondition then
					l_failing_expr := assertion_with_tag (postcondition_of_feature (a_tc.recipient_, a_tc.recipient_class_), a_tc.tag)
				elseif a_tc.exception_code = {EXCEP_CONST}.class_invariant then
					l_failing_expr := assertion_with_tag (invariant_of_class (a_tc.recipient_class_), a_tc.tag)
				else
					fixme ("Other types of exceptions are not supported for the moment. 12.12.2009 Jasonw")
				end
				assertion := Void
				if l_failing_expr /= Void then
					create {EPA_AST_EXPRESSION} assertion.make_with_text (
						a_tc.recipient_class_,
						a_tc.recipient_,
						text_from_ast (l_failing_expr.ast),
						l_failing_expr.written_class)
				end
				original_assertion := assertion
			end
		end

feature{NONE} -- Implementation

	analyze_void_call_target (a_tc: EPA_TEST_CASE_SIGNATURE; a_structure: AFX_FEATURE_AST_STRUCTURE_NODE; a_trace: STRING)
			-- Analyze void-call-target violation in `a_tc'.
		local
			l_feature_of_void_target: STRING
			l_culprit_ast: AFX_AST_STRUCTURE_NODE
			l_sub_expression_collector: AFX_SUB_EXPRESSION_COLLECTOR
			l_sub_expressions: EPA_HASH_SET [EPA_EXPRESSION]
			l_expression_ast_text_table: DS_HASH_TABLE [EPA_EXPRESSION, STRING]
			l_expression_texts: DS_ARRAYED_LIST [STRING]
			l_sub_expr: EPA_EXPRESSION
			l_equality_tester: AGENT_BASED_EQUALITY_TESTER [STRING]
			l_sorter: DS_QUICK_SORTER [STRING]
			l_found: BOOLEAN

			l_culprit_text: STRING
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_target_expression: STRING
			l_feature_call_end_position: INTEGER
			l_failing_classc: CLASS_C
			l_failing_feature: TUPLE [a_class: STRING; a_feature: STRING]
		do
			l_feature_of_void_target := a_tc.tag
			check l_feature_of_void_target /= VOid and then not l_feature_of_void_target.is_empty end
			feature_of_assertion := a_tc.recipient_
			class_of_feature_of_assertion := a_tc.recipient_class_
			assertion_break_point_slot := a_tc.breakpoint_slot
			l_culprit_ast := a_structure.node_at_break_point (assertion_break_point_slot)

				-- Find the shortest sub-expression in l_culprit_ast, containing the failing routine call.
				-- Collect all sub-expressions.
			create l_sub_expression_collector
			fixme ("uncomment the following if the code is necessary")
--			l_sub_expression_collector.collect_from_ast (l_culprit_ast.feature_, l_culprit_ast.ast.ast)
			l_sub_expressions := l_sub_expression_collector.last_sub_expressions
				-- Sort all sub-expression texts.
			create l_expression_ast_text_table.make_equal (l_sub_expressions.count)
			create l_expression_texts.make_equal (l_sub_expressions.count)
			from l_sub_expressions.start
			until l_sub_expressions.after
			loop
				l_sub_expr := l_sub_expressions.item_for_iteration
				l_expression_texts.force_last (l_sub_expr.text)
				l_expression_ast_text_table.force (l_sub_expr, l_sub_expr.text)
				l_sub_expressions.forth
			end
			create l_equality_tester.make (
				agent (a_string1, a_string2: STRING): BOOLEAN
					do
						Result := a_string1.count < a_string2.count
					end
			)
			create l_sorter.make (l_equality_tester)
			l_sorter.sort (l_expression_texts)
				-- Find the shortest sub-expression containing the feature call.
			from
				l_expression_texts.start
				l_found := False
			until l_expression_texts.after or else l_found
			loop
				if l_expression_texts.item_for_iteration.substring_index (l_feature_of_void_target, 1) /= 0 then
					l_culprit_text := l_expression_texts.item_for_iteration
					l_found := True
				end
				l_expression_texts.forth
			end

			l_culprit_text.replace_substring_all ("%N", "")
			l_culprit_text.replace_substring_all ("%R", "")

				-- Find out the calling position of the failing feature.
			fixme ("Target of the failing call should not include argument for the moment. 12.12.2009 Jasonw")
			create l_reg.make
			l_reg.set_caseless (True)
			l_reg.set_multiline (True)
			l_reg.compile ("((([A-Z]|[a-z])([a-z]|[A-Z]|[0-9]|_)*\.)*)(" + l_feature_of_void_target + ")")
			l_reg.match (l_culprit_text)
			check l_reg.has_matched end

				-- Get target expression of the failing call.
			l_target_expression := l_reg.captured_substring (1)
			l_feature_call_end_position := l_reg.captured_end_position (5)
			check l_target_expression /= VOid and then not l_target_expression.is_empty end
			if l_target_expression.ends_with (".") then
				l_target_expression.remove_tail (1)
			end
			create {EPA_AST_EXPRESSION} target_expression.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_target_expression, a_tc.recipient_class_)
			create {EPA_AST_EXPRESSION} original_assertion.make_with_text (a_tc.recipient_class_, a_tc.recipient_, "(" + l_target_expression + ") /= Void", a_tc.recipient_class_)
			assertion := original_assertion
		end

	analyze_precondtion_violation (a_tc: EPA_TEST_CASE_SIGNATURE; a_structure: AFX_FEATURE_AST_STRUCTURE_NODE; a_trace: STRING)
			-- Analyze precondition violation in `a_tc'.
		local
			l_culprit_ast: AFX_AST_STRUCTURE_NODE
			l_sub_expression_collector: AFX_SUB_EXPRESSION_COLLECTOR
			l_sub_expressions: EPA_HASH_SET [EPA_EXPRESSION]
			l_expression_ast_text_table: DS_HASH_TABLE [EPA_EXPRESSION, STRING]
			l_expression_texts: DS_ARRAYED_LIST [STRING]
			l_sub_expr: EPA_EXPRESSION
			l_equality_tester: AGENT_BASED_EQUALITY_TESTER [STRING]
			l_sorter: DS_QUICK_SORTER [STRING]
			l_found: BOOLEAN
			l_preconditions: LINKED_LIST [EPA_EXPRESSION]
			l_assertion: EPA_AST_EXPRESSION
			l_failing_precondition: EPA_EXPRESSION
			l_failing_preconditions: ARRAYED_LIST [EPA_EXPRESSION]
			l_contract_list: ARRAYED_LIST [TUPLE [req: REQUIRE_AS; ens: ENSURE_AS; wrt_class: CLASS_C]]
			l_target_assertion: TUPLE [wrt_class: CLASS_C; assertion_text: STRING]

			l_assert_id_set: ASSERT_ID_SET
			l_id_index: INTEGER
			l_inh_assert_info: INH_ASSERT_INFO

			l_culprit_text: STRING
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_target_expression: STRING
			l_feature_call_end_position: INTEGER
			l_failing_classc: CLASS_C
			l_failing_feature: TUPLE [a_class: STRING; a_feature: STRING]

			l_calling_args: HASH_TABLE [STRING, INTEGER]
			i: INTEGER
			l_done: BOOLEAN
			l_count: INTEGER
			l_paran_level: INTEGER
			c: CHARACTER
			l_cur_arg: STRING
			l_rewriter: EPA_CONTRACT_REWRITE_VISITOR
			l_arg_expr: EPA_AST_EXPRESSION
			l_square_level: INTEGER
		do
			fixme ("This is an unsound heuristic to handle general cases for the sake of easy implementation. May not generate correct result in some cases. 12.12.2009 Jasonw")
			assertion_break_point_slot := exception_break_point_in_recipient (a_tc, a_trace)
			l_failing_feature := failing_feature_name (a_tc, a_trace)
			l_culprit_ast := a_structure.node_at_break_point (assertion_break_point_slot)

				-- If it is a precondition violation of a function, the function call can be used as arguments or in other expressions.
				-- To identify the target and the arguments, try to find the function call as within a valid expression.
				-- Find the shortest sub-expression in l_culprit_ast, containing the failing function call.

				-- Collect all sub-expressions.
			create l_sub_expression_collector
			fixme ("Uncomment the following line.")
--			l_sub_expression_collector.collect_from_ast (l_culprit_ast.feature_, l_culprit_ast.ast.ast)
			l_sub_expressions := l_sub_expression_collector.last_sub_expressions
				-- Sort all sub-expression texts.
			create l_expression_ast_text_table.make_equal (l_sub_expressions.count)
			create l_expression_texts.make_equal (l_sub_expressions.count)
			from l_sub_expressions.start
			until l_sub_expressions.after
			loop
				l_sub_expr := l_sub_expressions.item_for_iteration
				l_expression_texts.force_last (l_sub_expr.text)
				l_expression_ast_text_table.force (l_sub_expr, l_sub_expr.text)
				l_sub_expressions.forth
			end
			create l_equality_tester.make (
				agent (a_string1, a_string2: STRING): BOOLEAN
					do
						Result := a_string1.count < a_string2.count
					end
			)
			create l_sorter.make (l_equality_tester)
			l_sorter.sort (l_expression_texts)

				-- Find the shortest sub-expression containing the feature call.
			from
				l_expression_texts.start
				l_found := False
			until l_expression_texts.after or else l_found
			loop
				if l_expression_texts.item_for_iteration.substring_index (l_failing_feature.a_feature, 1) /= 0 then
					l_culprit_text := l_expression_texts.item_for_iteration
					l_found := True
				end
				l_expression_texts.forth
			end

			if l_culprit_text = Void or else l_culprit_text.is_empty then
				-- Not a function call, therefore it must be the last call in a nested.
				l_culprit_text := l_culprit_ast.ast.ast.text (match_list_server.item (l_culprit_ast.written_class.class_id)).twin
			end
			l_culprit_text.replace_substring_all ("%N", "")
			l_culprit_text.replace_substring_all ("%R", "")

				-- Find out the calling position of the failing feature.
			fixme ("Target of the failing call should not include argument for the moment. 12.12.2009 Jasonw")
			create l_reg.make
			l_reg.set_caseless (True)
			l_reg.set_multiline (True)
			l_reg.compile ("((([A-Z]|[a-z])([a-z]|[A-Z]|[0-9]|_)*\.)*)(" + l_failing_feature.a_feature + ")")
			l_reg.match (l_culprit_text)
			check l_reg.has_matched end

				-- Get target expression of the failing call.
			l_target_expression := l_reg.captured_substring (1)
			l_feature_call_end_position := l_reg.captured_end_position (5)
			if l_target_expression.is_empty then
				target_expression := Void
			else
				check l_target_expression.count > 1 end
				if l_target_expression.ends_with (".") then
					l_target_expression.remove_tail (1)
				end
				create {EPA_AST_EXPRESSION} target_expression.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_target_expression, a_tc.recipient_class_)
			end

				-- Collect expressions used as arguments.
			l_failing_classc := first_class_starts_with_name (l_failing_feature.a_class)
			feature_of_assertion := l_failing_classc.feature_named (l_failing_feature.a_feature)
			class_of_feature_of_assertion := l_failing_classc
			create l_calling_args.make (feature_of_assertion.argument_count)
			if feature_of_assertion.argument_count > 0 then
				from
					i := l_feature_call_end_position + 1
					l_count := l_culprit_text.count
					create l_cur_arg.make (32)
				until
					i > l_count or l_done
				loop
					c := l_culprit_text.item (i)
					if c = '(' then
						if l_paran_level > 0 then
							l_cur_arg.extend (c)
						end
						l_paran_level := l_paran_level + 1
					elseif c = ')' then
						l_paran_level := l_paran_level - 1
						if l_paran_level = 0 then
							l_done := True
							l_cur_arg.left_adjust
							l_cur_arg.right_adjust
							if not l_cur_arg.is_empty then
								l_calling_args.put (l_cur_arg, l_calling_args.count + 1)
							end
						else
							l_cur_arg.extend (c)
						end
					elseif c = '[' then
						l_square_level := l_square_level + 1
						l_cur_arg.extend (c)
					elseif c = ']' then
						l_square_level := l_square_level - 1
						l_cur_arg.extend (c)
					elseif c = ',' then
						if l_square_level = 0 then
							l_cur_arg.left_adjust
							l_cur_arg.right_adjust
							l_calling_args.put (l_cur_arg, l_calling_args.count + 1)
							create l_cur_arg.make (32)
						else
							l_cur_arg.extend (c)
						end
					else
						if l_paran_level > 0 then
							l_cur_arg.extend (c)
						end
					end
					i := i + 1
				end
			end

			-- Original implementation:
			-- Precondition clause is selected based on the tag of the contract violation.
			-- In multiple inheritance, not all precondition clauses are resolvable in the recipient, in its written class.
			-- For example, the callee might have inherited an other precondition from the other superclass.
			-- Therefore, the original implementation doesn't always report well-formed expressions in recipient.written_class

--				-- Get the AST of the failing precondition.	
--			l_preconditions := precondition_of_feature (feature_of_assertion, l_failing_classc)
--			l_failing_precondition := assertion_with_tag (l_preconditions, a_tc.tag)
--			create {EPA_AST_EXPRESSION} original_assertion.make_with_text (l_failing_precondition.context_class, feature_of_assertion, l_failing_precondition.text, l_failing_precondition.written_class)
--			create l_rewriter
--			l_rewriter.rewrite (l_failing_precondition.ast, feature_of_assertion, l_failing_classc, a_tc.recipient_class_, l_target_expression, l_calling_args)

--				-- Generate result.
--			create {EPA_AST_EXPRESSION} assertion.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_rewriter.assertion, a_tc.recipient_class_)
----			create {EPA_AST_EXPRESSION} l_assertion.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_rewriter.assertion, a_tc.recipient_.written_class)
--			if l_assertion.type = Void then
--				l_assertion.set_type (boolean_type)
--			end
--			assertion := l_assertion

				-- The result assertion should be:
				-- 1. A precondition of `feature_of_assertion'.
				-- 2. Resolvable in the written class of `recipient_', since that's where the assertion expression would be applied.
				-- 3. Preferably with the tag `a_tc.tag', and any clause would be used if none exists.
				-- 		Since all preconditions must have been violated for us to get a violation in this case

			l_contract_list := preconditions_of_feature (feature_of_assertion, a_tc.recipient_class_, a_tc.recipient_written_class)
			l_target_assertion := precondition_with_tag (l_contract_list, a_tc.tag)
			if l_target_assertion = Void then
				l_target_assertion := first_precondition_expression_from_contract_list (l_contract_list)
			end
			create {EPA_AST_EXPRESSION} l_failing_precondition.make_with_text (l_failing_classc, feature_of_assertion, l_target_assertion.assertion_text, l_target_assertion.wrt_class)
			original_assertion := l_failing_precondition

				-- Rewrite in the context of `recipient_.written_class'
			create l_rewriter
			l_rewriter.rewrite (l_failing_precondition.ast, feature_of_assertion, a_tc.recipient_.written_class, l_failing_precondition.written_class, l_target_expression, l_calling_args)
			create {EPA_AST_EXPRESSION} l_assertion.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_rewriter.assertion, a_tc.recipient_.written_class)

				-- Type information.
			if l_assertion.type = Void then
				l_assertion.set_type (boolean_type)
			end
			assertion := l_assertion

				-- Prepare arguments.
			from
				l_rewriter.mentioned_actual_args.start
			until
				l_rewriter.mentioned_actual_args.after
			loop
				create l_arg_expr.make_with_text (a_tc.recipient_.written_class, a_tc.recipient_, l_rewriter.mentioned_actual_args.item_for_iteration, a_tc.recipient_.written_class)
				actual_argument_expressions.put (l_arg_expr, l_rewriter.mentioned_actual_args.key_for_iteration)
				l_rewriter.mentioned_actual_args.forth
			end
		end

	first_precondition_expression_from_contract_list (a_contract_list: ARRAYED_LIST [TUPLE [req: REQUIRE_AS; ens: ENSURE_AS; wrt_class: CLASS_C]]): TUPLE [CLASS_C, STRING]
			-- First precondition expression from `a_contract_list'.
		require
			contract_list_not_empty: a_contract_list /= Void and then not a_contract_list.is_empty
		local
			l_req: REQUIRE_AS
			l_tagged_expressions: EIFFEL_LIST [TAGGED_AS]
			i, l_count: INTEGER
			l_done: BOOLEAN
			l_tagged_exp: TAGGED_AS
			l_tag: STRING
			l_assertion_text: STRING
			l_written_class: CLASS_C
		do
			from a_contract_list.start
			until a_contract_list.after or else l_done
			loop
				l_written_class := a_contract_list.item_for_iteration.wrt_class
				l_req := a_contract_list.item_for_iteration.req

				if l_req.assertions /= Void and then not l_req.assertions.is_empty then
					Result := [l_written_class, text_from_ast (l_req.assertions.first.expr)]
					l_done := True
				end
				a_contract_list.forth
			end
		end

	precondition_with_tag (a_contract_list: ARRAYED_LIST [TUPLE [req: REQUIRE_AS; ens: ENSURE_AS; wrt_class: CLASS_C]]; a_tag: STRING): TUPLE [CLASS_C, STRING]
			-- Precondition expression with `a_tag' from `a_contract_list'.
		require
			contract_list_not_empty: a_contract_list /= Void and then not a_contract_list.is_empty
			tag_not_empty: a_tag /= Void and then not a_tag.is_empty
		local
			l_req: REQUIRE_AS
			l_wrt_class: CLASS_C
			l_tagged_expressions: EIFFEL_LIST [TAGGED_AS]
			i, l_count: INTEGER
			l_done: BOOLEAN
			l_tagged_exp: TAGGED_AS
			l_tag: STRING
			l_assertion_text: STRING
		do
			from a_contract_list.start
			until a_contract_list.after or else l_done
			loop
				l_wrt_class := a_contract_list.item_for_iteration.wrt_class
				l_req := a_contract_list.item_for_iteration.req

				if l_req.assertions /= Void then
					l_tagged_expressions := l_req.assertions
					from
						i := 1
						l_count := l_tagged_expressions.count
					until
						i > l_count or else l_done
					loop
						l_tagged_exp := l_tagged_expressions.i_th (i)
						if l_tagged_exp /= Void and then l_tagged_exp.tag.name ~ a_tag then
							Result := [l_wrt_class, text_from_ast (l_tagged_exp.expr)]
							l_done := True
						end
						i := i + 1
					end
				end
				a_contract_list.forth
			end
		end

	preconditions_of_feature (a_feature: FEATURE_I; a_context_class, a_view_class: CLASS_C): ARRAYED_LIST [TUPLE [REQUIRE_AS, ENSURE_AS, CLASS_C]]
			-- List of preconditions of `a_feature' from `a_context_class'.
			-- The result contains only preconditions that can be seen from `a_view_class'.
			-- `a_view_class' should be a super-class of `a_context_class', and yet a sub-class of `a_feature'.`written_class'.
		require
			all_attached: a_feature /= Void and then a_context_class /= Void and then a_view_class /= Void
		local
			l_e_feature: E_FEATURE
			l_ast: FEATURE_AS
			l_processed_features: ARRAYED_LIST [INTEGER]
			l_assert_id_set: ASSERT_ID_SET
			l_id_index: INTEGER
			l_inh_assert_info: INH_ASSERT_INFO
			l_assert_written_class: CLASS_C
			l_body_index: INTEGER
			l_feature_table: FEATURE_TABLE
			l_candidate_feature: FEATURE_I
			l_candidate_feature_as	: FEATURE_AS
			l_rout_as: ROUTINE_AS
			l_contract_list: ARRAYED_LIST [TUPLE [REQUIRE_AS, ENSURE_AS, CLASS_C]]
		do
			l_e_feature := a_feature.e_feature

			create l_processed_features.make (5)
			create l_contract_list.make (5)
			l_assert_id_set := a_feature.assert_id_set
			if l_assert_id_set /= Void then
				from
					l_id_index := 1
				until
					l_id_index > l_assert_id_set.count
				loop
					l_inh_assert_info := l_assert_id_set.item (l_id_index)
					l_assert_written_class := l_inh_assert_info.written_class
					l_body_index := l_inh_assert_info.body_index
					if a_view_class.conform_to (l_assert_written_class) and then l_assert_written_class.has_feature_table then
						l_feature_table := l_assert_written_class.feature_table
						l_candidate_feature := l_feature_table.feature_of_body_index (l_body_index)
						if l_candidate_feature /= Void then
							l_candidate_feature_as := l_candidate_feature.body
							if l_candidate_feature_as /= Void and then not l_processed_features.has (l_candidate_feature.body_index) then
								if attached {ROUTINE_AS} l_candidate_feature_as.body.content as lvt_routine_as then
									l_contract_list.extend ([lvt_routine_as.precondition, lvt_routine_as.postcondition, l_assert_written_class])
								end
								l_processed_features.extend (l_candidate_feature.body_index)
							end
						end
					end
					l_id_index := l_id_index + 1
				end
			end

			if a_feature.has_assertion and then (not l_processed_features.has (a_feature.body_index)) then
				if attached {ROUTINE_AS}l_e_feature.ast.body.content as lvt_rout_as then
					l_contract_list.extend ([lvt_rout_as.precondition, lvt_rout_as.postcondition, a_feature.written_class])
				end
			end

			Result := l_contract_list
		end


	exception_break_point_in_recipient (a_tc: EPA_TEST_CASE_SIGNATURE; a_trace: STRING): INTEGER
			-- Break point at the exception line in `a_tc'
		local
			l_lines: LIST [STRING]
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_done: BOOLEAN
		do
			fixme ("This is a hack. Use relevant trace analysis classes instead. 12.12.2009 Jasonw")
			l_lines := a_trace.split ('%N')
			from
				l_lines.start
			until
				l_lines.after or l_done
			loop
				create l_reg.make
				l_reg.compile (a_tc.recipient + "\s@([0-9]+)")
				check l_reg.is_compiled end
				l_reg.match (l_lines.item_for_iteration)
				if l_reg.has_matched then
					l_done := True
					Result := l_reg.captured_substring (1).to_integer
				end
				l_lines.forth
			end
		ensure
			result_positive: Result > 0
		end

	failing_feature_name (a_tc: EPA_TEST_CASE_SIGNATURE; a_trace: STRING): TUPLE [a_class_name: STRING; a_feature_name: STRING]
			-- Name of the failing feature from `a_tc'
		local
			l_lines: LIST [STRING]
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_class_name: STRING
			l_feature_name: STRING
			l_done: BOOLEAN
			l_analyzer: EPA_EXCEPTION_TRACE_PARSER
			l_frames: DS_LINEAR [EPA_EXCEPTION_TRACE_FRAME]
			l_frame: EPA_EXCEPTION_TRACE_FRAME
		do
--			fixme ("This is a hack. Use relevant trace analysis classes instead. 12.12.2009 Jasonw")
			create l_analyzer
			l_analyzer.parse (a_trace)
			from
				l_frames := l_analyzer.last_exception_frames
				l_frames.start
			until
				l_frames.after or else l_done
			loop
				l_frame := l_frames.item_for_iteration
				if l_frame /= Void and then l_frame.breakpoint_slot_index = a_tc.breakpoint_slot and then attached {STRING} l_frame.tag as l_tag and then l_tag ~ a_tc.tag then
					l_class_name := l_frame.context_class_name
					l_feature_name := l_frame.routine_name
					l_done := True
				end
				l_frames.forth
			end

			check l_class_name /= Void end
			check l_feature_name /= Void end
			Result := [l_class_name, l_feature_name]
		end

	assertion_with_tag (a_assertions: LIST [EPA_EXPRESSION]; a_tag: STRING): EPA_EXPRESSION
			-- Assertion from `a_assertions' with tag `a_tag'
		local
			l_cursor: CURSOR
			l_expression: EPA_EXPRESSION
			l_done: BOOLEAN
		do
			l_cursor := a_assertions.cursor
			from
				a_assertions.start
			until
				a_assertions.after or else l_done
			loop
				l_expression := a_assertions.item_for_iteration
				if l_expression.tag ~ a_tag then
					l_done := True
					Result := l_expression
				end
				a_assertions.forth
			end
			a_assertions.go_to (l_cursor)
		end

	assertions_written_in_class (a_assertions: LIST [EPA_EXPRESSION]; a_class: CLASS_C): ARRAYED_LIST [EPA_EXPRESSION]
			-- Assertion from `a_assertions', which is written in `a_class'.
		local
			l_cursor: CURSOR
			l_expression: EPA_EXPRESSION
			l_done: BOOLEAN
		do
			create Result.make (a_assertions.count)
			l_cursor := a_assertions.cursor
			from
				a_assertions.start
			until
				a_assertions.after
			loop
				l_expression := a_assertions.item_for_iteration
				if l_expression.written_class ~ a_class then
					Result.force (l_expression)
				end
				a_assertions.forth
			end
			a_assertions.go_to (l_cursor)
		ensure
			result_attached: Result /= Void
		end

end

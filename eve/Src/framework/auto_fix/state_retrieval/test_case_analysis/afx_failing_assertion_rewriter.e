note
	description: "Summary description for {AFX_FAILING_ASSERTION_REWRITER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_FAILING_ASSERTION_REWRITER

inherit
	REFACTORING_HELPER

	EPA_CONTRACT_EXTRACTOR

	AFX_UTILITY

	SHARED_SERVER

feature -- Access

	assertion: detachable EPA_EXPRESSION
			-- expression representing the failing assertion as appeared in recipient,
			-- generated by the last `rewrite'.
			-- It has been rewritten in the context of the recipient.

	original_assertion: detachable EPA_EXPRESSION
			-- Original assertion for `assertion', different from `assertion' in precondition violation,
			-- same as `assertion' for other types of assertion violations.

	feature_of_assertion: detachable FEATURE_I
			-- Feature which contains `assertion'
			-- If the exception is a precondition violation, `feature_of_assertion' is the feature containing the precondition.
			-- Otherwise, `feature_of_assertion' is the same as the recipient of the exception.

	class_of_feature_of_assertion: detachable CLASS_C
			-- Context class of `feature_of_assertion'

	assertion_break_point_slot: INTEGER
			-- Break point slot for `assertion'.
			-- If the exception is a precondition violation, this is the break point slot for the failing routine call in recipient.
			-- Otherwise, this is equal to `test_case_info'.`break_point_slot'.

	actual_argument_expressions: HASH_TABLE [EPA_EXPRESSION, INTEGER]
			-- Expressions that are mentioned as actual arguments in the failing routine if the exception is a precondition violation.
			-- For other types of exception, this hashtalbe is empty.
			-- Key is the argument index, value is the mentioned expression for that argument.

	target_expression: detachable EPA_EXPRESSION
			-- Target expression of `feature_of_failing_assertion'
			-- Void means that `feature_of_failing_assertion' is a unqualified call.

feature -- Basic operations

	rewrite (a_tc: EPA_TEST_CASE_INFO; a_structure: AFX_FEATURE_AST_STRUCTURE_NODE; a_trace: STRING)
			-- Generate the rewritten failing assertion.
			-- The generated assertion should appear in the context of `a_tc'.recipient_'.
			-- `a_structure' stores the AST sturcture of `a_tc'.recipient_'.
		local
			l_failing_expr: detachable EPA_EXPRESSION
		do
			create actual_argument_expressions.make (2)
			if a_tc.exception_code = {EXCEP_CONST}.precondition then
				analyze_precondtion_violation (a_tc, a_structure, a_trace)
			else
				feature_of_assertion := a_tc.recipient_
				class_of_feature_of_assertion := a_tc.recipient_class_
				assertion_break_point_slot := a_tc.breakpoint_slot
				if a_tc.exception_code = {EXCEP_CONST}.check_instruction then
					if attached {TAGGED_AS} a_structure.relevant_ast (a_tc.breakpoint_slot) as l_check_ast then
						create {EPA_AST_EXPRESSION}l_failing_expr.make (l_check_ast.expr, a_tc.recipient_class_, a_tc.recipient_class_)
					else
						check should_not_happen: False end
					end
				elseif a_tc.exception_code = {EXCEP_CONST}.postcondition then
					l_failing_expr := assertion_with_tag (postcondition_of_feature (a_tc.recipient_, a_tc.recipient_class_), a_tc.tag)
				elseif a_tc.exception_code = {EXCEP_CONST}.class_invariant then
					l_failing_expr := assertion_with_tag (invariant_of_class (a_tc.recipient_class_), a_tc.tag)
				else
					fixme ("Other types of exceptions are not supported for the moment. 12.12.2009 Jasonw")
				end
				assertion := Void
				if l_failing_expr /= Void then
					create {EPA_AST_EXPRESSION} assertion.make_with_text (
						a_tc.recipient_class_,
						a_tc.recipient_,
						text_from_ast (l_failing_expr.ast),
						l_failing_expr.written_class)
				end
				original_assertion := assertion
			end
		end

feature{NONE} -- Implementation

	analyze_precondtion_violation (a_tc: EPA_TEST_CASE_INFO; a_structure: AFX_FEATURE_AST_STRUCTURE_NODE; a_trace: STRING)
			-- Analyze precondition violation in `a_tc'.
		local
			l_culprit_ast: AFX_AST_STRUCTURE_NODE
			l_culprit_text: STRING
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_target_expression: STRING
			l_feature_call_end_position: INTEGER
			l_failing_classc: CLASS_C
			l_failing_feature: TUPLE [a_class: STRING; a_feature: STRING]

			l_calling_args: HASH_TABLE [STRING, INTEGER]
			i: INTEGER
			l_done: BOOLEAN
			l_count: INTEGER
			l_paran_level: INTEGER
			c: CHARACTER
			l_cur_arg: STRING
			l_failing_precondition: EPA_EXPRESSION
			l_rewriter: EPA_CONTRACT_REWRITE_VISITOR
			l_arg_expr: EPA_AST_EXPRESSION
			l_square_level: INTEGER
		do
			fixme ("This is an unsound heuristic to handle general cases for the sake of easy implementation. May not generate correct result in some cases. 12.12.2009 Jasonw")
			assertion_break_point_slot := exception_break_point_in_recipient (a_tc, a_trace)
			l_culprit_ast := a_structure.node_at_break_point (assertion_break_point_slot)
			l_culprit_text := l_culprit_ast.ast.ast.text (match_list_server.item (l_culprit_ast.written_class.class_id)).twin
			l_culprit_text.replace_substring_all ("%N", "")
			l_culprit_text.replace_substring_all ("%R", "")
			l_failing_feature := failing_feature_name (a_tc, a_trace)

				-- Find out the calling position of the failing feature.
			fixme ("Target of the failing call should not include argument for the moment. 12.12.2009 Jasonw")
			create l_reg.make
			l_reg.set_caseless (True)
			l_reg.set_multiline (True)
			l_reg.compile ("((([A-Z]|[a-z])([a-z]|[A-Z]|[0-9]|_)*\.)*)(" + l_failing_feature.a_feature + ")")
			l_reg.match (l_culprit_text)
			check l_reg.has_matched end

				-- Get target expression of the failing call.
			l_target_expression := l_reg.captured_substring (1)
			l_feature_call_end_position := l_reg.captured_end_position (5)
			if l_target_expression.is_empty then
				target_expression := Void
			else
				check l_target_expression.count > 1 end
				if l_target_expression.ends_with (".") then
					l_target_expression.remove_tail (1)
				end
				create {EPA_AST_EXPRESSION} target_expression.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_target_expression, a_tc.recipient_class_)
			end

				-- Collect expressions used as arguments.
			l_failing_classc := first_class_starts_with_name (l_failing_feature.a_class)
			feature_of_assertion := l_failing_classc.feature_named (l_failing_feature.a_feature)
			class_of_feature_of_assertion := l_failing_classc
			create l_calling_args.make (feature_of_assertion.argument_count)
			if feature_of_assertion.argument_count > 0 then
				from
					i := l_feature_call_end_position + 1
					l_count := l_culprit_text.count
					create l_cur_arg.make (32)
				until
					i > l_count or l_done
				loop
					c := l_culprit_text.item (i)
					if c = '(' then
						if l_paran_level > 0 then
							l_cur_arg.extend (c)
						end
						l_paran_level := l_paran_level + 1
					elseif c = ')' then
						l_paran_level := l_paran_level - 1
						if l_paran_level = 0 then
							l_done := True
							l_cur_arg.left_adjust
							l_cur_arg.right_adjust
							if not l_cur_arg.is_empty then
								l_calling_args.put (l_cur_arg, l_calling_args.count + 1)
							end
						else
							l_cur_arg.extend (c)
						end
					elseif c = '[' then
						l_square_level := l_square_level + 1
						l_cur_arg.extend (c)
					elseif c = ']' then
						l_square_level := l_square_level - 1
						l_cur_arg.extend (c)
					elseif c = ',' then
						if l_square_level = 0 then
							l_cur_arg.left_adjust
							l_cur_arg.right_adjust
							l_calling_args.put (l_cur_arg, l_calling_args.count + 1)
							create l_cur_arg.make (32)
						else
							l_cur_arg.extend (c)
						end
					else
						if l_paran_level > 0 then
							l_cur_arg.extend (c)
						end
					end
					i := i + 1
				end
			end

				-- Get the AST of the failing precondition.				
			l_failing_precondition := assertion_with_tag (precondition_of_feature (feature_of_assertion, l_failing_classc), a_tc.tag)
			create {EPA_AST_EXPRESSION} original_assertion.make_with_text (l_failing_precondition.context_class, feature_of_assertion, l_failing_precondition.text, l_failing_precondition.written_class)
			create l_rewriter
			l_rewriter.rewrite (l_failing_precondition.ast, feature_of_assertion, l_failing_classc, a_tc.recipient_class_, l_target_expression, l_calling_args)

				-- Generate result.
			create {EPA_AST_EXPRESSION} assertion.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_rewriter.assertion, a_tc.recipient_class_)
			from
				l_rewriter.mentioned_actual_args.start
			until
				l_rewriter.mentioned_actual_args.after
			loop
				create l_arg_expr.make_with_text (a_tc.recipient_class_, a_tc.recipient_, l_rewriter.mentioned_actual_args.item_for_iteration, a_tc.recipient_class_)
				actual_argument_expressions.put (l_arg_expr, l_rewriter.mentioned_actual_args.key_for_iteration)
				l_rewriter.mentioned_actual_args.forth
			end
		end

	exception_break_point_in_recipient (a_tc: EPA_TEST_CASE_INFO; a_trace: STRING): INTEGER
			-- Break point at the exception line in `a_tc'
		local
			l_lines: LIST [STRING]
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_done: BOOLEAN
		do
			fixme ("This is a hack. Use relevant trace analysis classes instead. 12.12.2009 Jasonw")
			l_lines := a_trace.split ('%N')
			from
				l_lines.start
			until
				l_lines.after or l_done
			loop
				create l_reg.make
				l_reg.compile (a_tc.recipient + "\s@([0-9]+)")
				check l_reg.is_compiled end
				l_reg.match (l_lines.item_for_iteration)
				if l_reg.has_matched then
					l_done := True
					Result := l_reg.captured_substring (1).to_integer
				end
				l_lines.forth
			end
		ensure
			result_positive: Result > 0
		end

	failing_feature_name (a_tc: EPA_TEST_CASE_INFO; a_trace: STRING): TUPLE [a_class_name: STRING; a_feature_name: STRING]
			-- Name of the failing feature from `a_tc'
		local
			l_lines: LIST [STRING]
			l_reg: RX_PCRE_REGULAR_EXPRESSION
			l_class_name: STRING
			l_feature_name: STRING
			l_done: BOOLEAN
			l_analyzer: EPA_EXCEPTION_TRACE_ANALYZER
			l_frames: DS_LINEAR [EPA_EXCEPTION_CALL_STACK_FRAME_I]
			l_frame: EPA_EXCEPTION_CALL_STACK_FRAME_I
		do
--			fixme ("This is a hack. Use relevant trace analysis classes instead. 12.12.2009 Jasonw")
			create l_analyzer
			l_analyzer.analyse (a_trace)
			from
				l_frames := l_analyzer.last_relevant_exception_frames
				l_frames.start
			until
				l_frames.after or else l_done
			loop
				l_frame := l_frames.item_for_iteration
				if l_frame /= Void and then l_frame.breakpoint_slot_index = a_tc.breakpoint_slot and then attached {STRING} l_frame.tag as l_tag and then l_tag ~ a_tc.tag then
					l_class_name := l_frame.context_class_name
					l_feature_name := l_frame.feature_name
					l_done := True
				end
				l_frames.forth
			end

--			l_lines := a_trace.split ('%N')
--			from
--				l_lines.start
--			until
--				l_lines.after or l_done
--			loop
--				create l_reg.make
--				l_reg.compile ("(([A-Z]|[a-z]|[0-9]|_)+)\s+(([A-Z]|[a-z]|[0-9]|_)+)\s@" + a_tc.breakpoint_slot.out + "\s+" + a_tc.tag)
--				check l_reg.is_compiled end
--				l_reg.match (l_lines.item_for_iteration)
--				if l_reg.has_matched then
--					l_done := True
--					l_class_name := l_reg.captured_substring (1)
--					l_feature_name := l_reg.captured_substring (3)
--				end
--				l_lines.forth
--			end
			check l_class_name /= Void end
			check l_feature_name /= Void end
			Result := [l_class_name, l_feature_name]
		end

	assertion_with_tag (a_assertions: LIST [EPA_EXPRESSION]; a_tag: STRING): EPA_EXPRESSION
			-- Assertion from `a_assertions' with tag `a_tag'
		local
			l_cursor: CURSOR
			l_expression: EPA_EXPRESSION
			l_done: BOOLEAN
		do
			l_cursor := a_assertions.cursor
			from
				a_assertions.start
			until
				a_assertions.after or else l_done
			loop
				l_expression := a_assertions.item_for_iteration
				if l_expression.tag ~ a_tag then
					l_done := True
					Result := l_expression
				end
				a_assertions.forth
			end
			a_assertions.go_to (l_cursor)
		ensure
			result_attached: Result /= Void
		end

end

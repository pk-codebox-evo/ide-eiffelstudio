note
	description: "Class to generate Daikon input files from ARFF data"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SEM_ARFF_TO_DAIKON_GENERATOR

inherit
	DKN_SHARED_EQUALITY_TESTERS

	WEKA_SHARED_EQUALITY_TESTERS

	SEM_FIELD_NAMES

	EPA_UTILITY

	DKN_CONSTANTS

	DKN_UTILITY

create
	make

feature{NONE} -- Initialization

	make
			-- Initialize Current.
		do
		end

feature -- Access

	last_declaration: DKN_DECLARATION
			-- Program point and variable declarations generate by last `generate'

	last_trace: DKN_TRACE
			-- Trace generated by last `generate'

feature -- Basic operations

	generate (a_relation: WEKA_ARFF_RELATION)
			-- Generate Daikon trace from `a_relation',
			-- make result available in `last_declaration' and `last_trace'.
		do
			arff_relation := a_relation
			trim_arff_relation
			calculate_program_points
			calculate_trace
		end

feature{NONE} -- Implementation

	arff_relation: WEKA_ARFF_RELATION
			-- Weka relation from which `last_trace' should be generated

	program_points: DS_HASH_SET [DKN_PROGRAM_POINT]
			-- Set of program points to be generated

	attributes_at_program_points: DS_HASH_TABLE [DKN_PROGRAM_POINT, WEKA_ARFF_ATTRIBUTE]
			-- Table from weka attributes to the program point where those attributes
			-- should appear. Keys are attributes from ARFF relation, values are program points.

	variable_to_attribute_table: DS_HASH_TABLE [DS_HASH_TABLE [WEKA_ARFF_ATTRIBUTE, DKN_VARIABLE], DKN_PROGRAM_POINT]
			-- Table for mapping from Daikon variable to Weka attribute
			-- Keys of outer table are program points, keys of inner table are Daikon variables, values of
			-- inner table are Weka attributes corresponding to those Daikon variables.

	entry_point: DKN_PROGRAM_POINT
			-- Program point at feature entry

	exit_point: DKN_PROGRAM_POINT
			-- Program point at feature exit

feature{NONE} -- Implementation

	calculate_program_points
			-- Calculate `program_points' from `arff_relation'.
		local
			l_attr: WEKA_ARFF_ATTRIBUTE
			l_attr_name: STRING
			l_variable: DKN_VARIABLE
		do
			create program_points.make (2)
			program_points.set_equality_tester (daikon_program_point_equality_tester)

			create variable_to_attribute_table.make (2)
			variable_to_attribute_table.set_key_equality_tester (daikon_program_point_equality_tester)

			create last_declaration.make (2)

			create entry_point.make_with_type ("ppt1:::PRECONDITION", point_program_point)
			create exit_point.make_with_type ("ppt2:::POSTCONDITION", point_program_point)

			across arff_relation.attributes as l_attrs loop
				l_attr := l_attrs.item
				if is_attribute_supported (l_attr) then
					l_attr_name := l_attr.name_without_quotes

					if l_attr_name.starts_with (precondition_field_prefix) or l_attr_name.starts_with (property_field_prefix) then
						add_attribute_at_program_point (l_attr, entry_point)
					elseif l_attr_name.starts_with (postcondition_field_prefix) then
						add_attribute_at_program_point (l_attr, exit_point)
					end
				end
			end
		end

	add_attribute_at_program_point (a_attribute: WEKA_ARFF_ATTRIBUTE; a_program_point: DKN_PROGRAM_POINT)
			-- Add `a_attribute' into `a_program_point'.
		local
			l_var: DKN_VARIABLE
			l_tbl: DS_HASH_TABLE [WEKA_ARFF_ATTRIBUTE, DKN_VARIABLE]
		do
			if not program_points.has (a_program_point) then
				program_points.force_last (a_program_point)
				last_declaration.force_last (a_program_point)
			end
			l_var := variable_declaraction (a_attribute)
			a_program_point.variables.force_last (l_var)
--			if a_program_point = entry_point then
--				exit_point.variables.force_last (l_var)
--			else
--				entry_point.variables.force_last (l_var)
--			end
			variable_to_attribute_table.search (a_program_point)
			if variable_to_attribute_table.found then
				l_tbl := variable_to_attribute_table.found_item
			else
				create l_tbl.make (100)
				l_tbl.set_key_equality_tester (daikon_variable_equality_tester)
				variable_to_attribute_table.force_last (l_tbl, a_program_point)
			end
			l_tbl.force_last (a_attribute, l_var)
		end

	calculate_trace
			-- Collect trace from instances from `arff_relation'.
		local
			l_instance: DS_HASH_TABLE [STRING, WEKA_ARFF_ATTRIBUTE]
			l_attr_cursor: DS_HASH_TABLE_CURSOR [STRING, WEKA_ARFF_ATTRIBUTE]
			l_relation: like arff_relation
			l_cursor: CURSOR
			l_tbl:like variable_to_attribute_table
		do
			create last_trace.make
			l_relation := arff_relation
			l_cursor := l_relation.cursor
			l_tbl := variable_to_attribute_table
			from
				l_relation.start
			until
				l_relation.after
			loop
				l_instance := l_relation.item_as_ds_hash_table
				if l_tbl.has (entry_point) then
					last_trace.extend (trace_record (entry_point, l_instance))
				end
				if l_tbl.has (exit_point) then
					last_trace.extend (trace_record (exit_point, l_instance))
				end
				l_relation.forth
			end
			l_relation.go_to (l_cursor)
		end

	trace_record (a_program_point: DKN_PROGRAM_POINT; a_instance: DS_HASH_TABLE [STRING, WEKA_ARFF_ATTRIBUTE]):DKN_TRACE_RECORD
			-- Trace record for `a_program_point' and data from `a_instance'
		local
			l_var_cursor: DS_HASH_SET_CURSOR [DKN_VARIABLE]
			l_mapping: DS_HASH_TABLE [WEKA_ARFF_ATTRIBUTE, DKN_VARIABLE]
			l_var: DKN_VARIABLE
			l_raw_value: STRING
			l_attr: WEKA_ARFF_ATTRIBUTE
			l_value: DKN_VARIABLE_VALUE
		do
			create Result.make (a_program_point)
			l_mapping := variable_to_attribute_table.item (a_program_point)
			from
				l_var_cursor := a_program_point.variables.new_cursor
				l_var_cursor.start
			until
				l_var_cursor.after
			loop
				l_var := l_var_cursor.item
				l_attr := l_mapping.item (l_var)
				l_raw_value := a_instance.item (l_attr)
				if l_raw_value = Void or else l_raw_value ~ {WEKA_ARFF_ATTRIBUTE}.missing_value then
					create l_value.make (l_var, daikon_nonsensical_value, modified_flag_2)
				else
					create l_value.make (l_var, l_raw_value, modified_flag_1)
				end
				Result.values.force_last (l_value, l_var)
				l_var_cursor.forth
			end
			Result.complete
		end

	attribute_prefixes (a_attribute: WEKA_ARFF_ATTRIBUTE): LINKED_LIST [STRING]
			-- Prefixes from name of `a_attributes'
			-- For a property attribute, we should have the form, for example, "pre::i::"
			-- then, in the result, the first item is "pre", the second item is "i"
			-- For a non property attribute, return an empty list.
		local
			l_slices: LIST [STRING]
		do
			l_slices := string_slices (a_attribute.name_without_quotes, once "::")
			create Result.make
			if l_slices.count = 3 then
				Result.extend (l_slices.i_th (1))
				Result.extend (l_slices.i_th (2))
			end
		end

	is_attribute_supported (a_attribute: WEKA_ARFF_ATTRIBUTE): BOOLEAN
			-- Should `a_attribute' be generated as a Daikon variable?
		local
			l_prefixes: like attribute_prefixes
		do
			l_prefixes := attribute_prefixes (a_attribute)
			if not l_prefixes.is_empty then
				if
					precondition_field_prefix.starts_with (l_prefixes.first) or
					postcondition_field_prefix.starts_with (l_prefixes.first) or
					property_field_prefix.starts_with (l_prefixes.first)
				then
					Result := not a_attribute.name_without_quotes.has_substring (once "hit_breakpoint (")
				end
			end
		end

	variable_declaraction (a_attribute: WEKA_ARFF_ATTRIBUTE): DKN_VARIABLE
			-- Daikon variable declaraction from `a_attribute'
		require
			is_attribute_supported: is_attribute_supported (a_attribute)
		local
			l_prefixes: like attribute_prefixes
			l_rep_type: STRING
			l_var_kind: STRING
			l_dec_type: STRING
			l_comparability: INTEGER
			l_var_name: STRING
			l_prefix: STRING
		do
			l_prefixes := attribute_prefixes (a_attribute)
			l_prefix := l_prefixes.i_th (1) + "::" + l_prefixes.i_th (2) + "::"
			if l_prefixes.i_th (2) ~ once "i" then
				l_rep_type := integer_rep_type
				l_comparability := integer_comparability
			elseif l_prefixes.i_th (2) ~ once "b" then
				l_rep_type := boolean_rep_type
				l_comparability := boolean_comparability
			else
				check should_not_be_here: False end
			end
			l_dec_type := l_rep_type
			l_var_kind := variable_var_kind
			l_var_name := daikon_variable_name (a_attribute)
			create Result.make (l_var_name, l_rep_type, l_var_kind, l_dec_type, l_comparability)
		end

	daikon_variable_name (a_attribute: WEKA_ARFF_ATTRIBUTE): STRING
			-- Daikon variable name from name of `a_attribute'
		require
			is_attribute_supported: is_attribute_supported (a_attribute)
		local
			l_prefixes: like attribute_prefixes
			l_prefix: STRING
		do
			l_prefixes := attribute_prefixes (a_attribute)
			l_prefix := l_prefixes.i_th (1) + "::" + l_prefixes.i_th (2) + "::"
			Result := a_attribute.name_without_quotes
			Result.remove_head (l_prefix.count)
			Result := encoded_daikon_name (Result)
		end

	trim_arff_relation
			-- Trim `arff_relation'.
			-- For example, to remove attributes which contain missing values.
		local
			l_relation: like arff_relation
			l_values: like arff_relation.value_set
		do
			l_values := arff_relation.value_set
			arff_relation := arff_relation.projection (agent is_all_value_defined (?, l_values))
		end

	is_all_value_defined (a_attribute: WEKA_ARFF_ATTRIBUTE; a_value_set: DS_HASH_TABLE [DS_HASH_SET [STRING_8], WEKA_ARFF_ATTRIBUTE]): BOOLEAN
			-- Are are all values of `a_attribute' defined (that is, no missing values for `a_attributes' in all instances)?
		do
			Result := not a_value_set.item (a_attribute).has ({WEKA_ARFF_ATTRIBUTE}.missing_value)
		end

end

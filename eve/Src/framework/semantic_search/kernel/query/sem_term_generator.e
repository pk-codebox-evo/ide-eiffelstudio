note
	description: "Class to generate terms"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SEM_TERM_GENERATOR

inherit
	SEM_QUERYABLE_VISITOR

	REFACTORING_HELPER

	IR_TERM_OCCURRENCE

feature -- Access

	last_terms: LINKED_LIST [SEM_TERM]
			-- Terms generated by last `generate'

	term_occurrence_function: detachable FUNCTION [ANY, TUPLE [SEM_TERM], INTEGER]
			-- A function to set occurrence into the argument term
			-- If Void, the occurrence already inside the argument term is not changed.

feature -- Basic operations

	generate (a_queryable: SEM_QUERYABLE)
			-- Generate searchable properties as terms from `a_queryable',
			-- make result available in `last_terms'.
		do
			create last_terms.make
			a_queryable.process (Current)
		end

feature{NONE} -- Process

	process_snippet (a_snippet: SEM_SNIPPET)
			-- Process `a_snippet'.
		do
			to_implement ("Implement me. 9.10.2010 Jasonw")
		end

	process_feature_call (a_call: SEM_FEATURE_CALL_TRANSITION)
			-- Process `a_call'.
		local
			l_variable_term: SEM_VARIABLE_TERM
			l_contract_term: SEM_CONTRACT_TERM
			l_change_term: SEM_CHANGE_TERM
			l_vars: DS_HASH_SET_CURSOR [EPA_EXPRESSION]
			l_contracts: DS_HASH_SET_CURSOR [EPA_EQUATION]
			l_changes: DS_HASH_TABLE_CURSOR [LIST [EPA_EXPRESSION_CHANGE], EPA_EXPRESSION]
			l_terms: like last_terms
		do
			l_terms := last_terms
				-- Add variable terms into `terms'.
			from
				l_vars := a_call.variables.new_cursor
				l_vars.start
			until
				l_vars.after
			loop
				create l_variable_term.make (a_call, l_vars.item)
				if term_occurrence_function /= Void then
					l_variable_term.set_occurrence (term_occurrence_function.item ([l_variable_term]))
				end
				l_terms.extend (l_variable_term)
				l_vars.forth
			end

				-- Add precondition terms into `terms'.
			from
				l_contracts := a_call.preconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (a_call, l_contracts.item, True, False)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end

				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add human-written precondition terms into `terms'.
			from
				l_contracts := a_call.written_preconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (a_call, l_contracts.item, True, True)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add postcondition terms into `terms'.
			from
				l_contracts := a_call.postconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (a_call, l_contracts.item, False, False)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add human-written postcondition terms into `terms'.
			from
				l_contracts := a_call.written_postconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (a_call, l_contracts.item, False, True)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add change terms into `terms'.
			from
				l_changes := a_call.changes.new_cursor
				l_changes.start
			until
				l_changes.after
			loop
				across l_changes.item as l_change_items loop
					create l_change_term.make (a_call, l_changes.key, l_change_items.item)
					if term_occurrence_function /= Void then
						l_change_term.set_occurrence (term_occurrence_function.item ([l_change_term]))
					end
					l_terms.extend (l_change_term)
				end
				l_changes.forth
			end
		end

	process_objects (a_objects: SEM_OBJECTS)
			-- Process `a_objects'.
		local
			l_variable_term: SEM_VARIABLE_TERM
			l_property_term: SEM_PROPERTY_TERM
			l_vars: DS_HASH_SET_CURSOR [EPA_EXPRESSION]
			l_properties: DS_HASH_SET_CURSOR [EPA_EQUATION]
			l_terms: like last_terms
		do
			l_terms := last_terms
				-- Add variable terms into `terms'.
			from
				l_vars := a_objects.variables.new_cursor
				l_vars.start
			until
				l_vars.after
			loop
				create l_variable_term.make (a_objects, l_vars.item)
				if term_occurrence_function /= Void then
					l_variable_term.set_occurrence (term_occurrence_function.item ([l_variable_term]))
				end
				l_terms.extend (l_variable_term)
				l_vars.forth
			end

				-- Add precondition terms into `terms'.
			from
				l_properties := a_objects.properties.new_cursor
				l_properties.start
			until
				l_properties.after
			loop
				create l_property_term.make (a_objects, l_properties.item)
				if term_occurrence_function /= Void then
					l_property_term.set_occurrence (term_occurrence_function.item ([l_property_term]))
				end
				l_terms.extend (l_property_term)
				l_properties.forth
			end
		end

end

note
	description: "Class to generate terms"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SEMQ_TERM_GENERATOR

inherit
	SEM_QUERYABLE_VISITOR

	REFACTORING_HELPER

	IR_TERM_OCCURRENCE

feature -- Access

	last_terms: LINKED_LIST [SEMQ_TERM]
			-- Terms generated by last `generate'

	term_occurrence_function: detachable FUNCTION [ANY, TUPLE [SEMQ_TERM], INTEGER]
			-- A function to set occurrence into the argument term
			-- If Void, the occurrence already inside the argument term is not changed.

feature -- Basic operations

	generate (a_queryable: SEM_QUERYABLE)
			-- Generate searchable properties as terms from `a_queryable',
			-- make result available in `last_terms'.
		do
			create last_terms.make
			a_queryable.process (Current)
		end

feature{NONE} -- Process

	process_snippet (a_snippet: SEM_SNIPPET)
			-- Process `a_snippet'.
		do
			to_implement ("Implement me. 9.10.2010 Jasonw")
		end

	process_feature_call (a_call: SEM_FEATURE_CALL_TRANSITION)
			-- Process `a_call'.
		local
			l_variable_term: SEMQ_VARIABLE_TERM
			l_contract_term: SEMQ_EQUATION_TERM
			l_vars: DS_HASH_SET_CURSOR [EPA_EXPRESSION]
			l_contracts: DS_HASH_SET_CURSOR [EPA_EQUATION]
			l_terms: like last_terms
		do
			l_terms := last_terms
				-- Add variable terms into `terms'.
			from
				l_vars := a_call.variables.new_cursor
				l_vars.start
			until
				l_vars.after
			loop
				if a_call.interface_variable_positions.has (l_vars.item) then
					create l_variable_term.make_with_position (l_vars.item, a_call.interface_variable_positions.item (l_vars.item), a_call)
				else
					create l_variable_term.make (l_vars.item, a_call)
				end
				if term_occurrence_function /= Void then
					l_variable_term.set_occurrence (term_occurrence_function.item ([l_variable_term]))
				end
				l_terms.extend (l_variable_term)
				l_vars.forth
			end

				-- Add precondition terms into `terms'.
			from
				l_contracts := a_call.preconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (l_contracts.item, a_call)
				l_contract_term.set_is_precondition (True)
				l_contract_term.set_is_postcondition (False)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end

				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add human-written precondition terms into `terms'.
			from
				l_contracts := a_call.written_preconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (l_contracts.item, a_call)
				l_contract_term.set_is_precondition (True)
				l_contract_term.set_is_human_written (True)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add postcondition terms into `terms'.
			from
				l_contracts := a_call.postconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (l_contracts.item, a_call)
				l_contract_term.set_is_postcondition (True)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end

				-- Add human-written postcondition terms into `terms'.
			from
				l_contracts := a_call.written_postconditions.new_cursor
				l_contracts.start
			until
				l_contracts.after
			loop
				create l_contract_term.make (l_contracts.item, a_call)
				l_contract_term.set_is_postcondition (True)
				l_contract_term.set_is_human_written (True)
				if term_occurrence_function /= Void then
					l_contract_term.set_occurrence (term_occurrence_function.item ([l_contract_term]))
				end
				l_terms.extend (l_contract_term)
				l_contracts.forth
			end
		end

	process_objects (a_objects: SEM_OBJECTS)
			-- Process `a_objects'.
		local
			l_variable_term: SEMQ_VARIABLE_TERM
			l_property_term: SEMQ_EQUATION_TERM
			l_vars: DS_HASH_SET_CURSOR [EPA_EXPRESSION]
			l_properties: DS_HASH_SET_CURSOR [EPA_EQUATION]
			l_terms: like last_terms
		do
			l_terms := last_terms
				-- Add variable terms into `terms'.
			from
				l_vars := a_objects.variables.new_cursor
				l_vars.start
			until
				l_vars.after
			loop
				create l_variable_term.make (l_vars.item, a_objects)
				if term_occurrence_function /= Void then
					l_variable_term.set_occurrence (term_occurrence_function.item ([l_variable_term]))
				end
				l_terms.extend (l_variable_term)
				l_vars.forth
			end

				-- Add precondition terms into `terms'.
			from
				l_properties := a_objects.properties.new_cursor
				l_properties.start
			until
				l_properties.after
			loop
				create l_property_term.make (l_properties.item, a_objects)
				if term_occurrence_function /= Void then
					l_property_term.set_occurrence (term_occurrence_function.item ([l_property_term]))
				end
				l_terms.extend (l_property_term)
				l_properties.forth
			end
		end

end

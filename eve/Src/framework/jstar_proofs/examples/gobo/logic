import "field_logic";

rewrite simple1:
 builtin_ne(?x,?x) = false()

rule obvious1:
 | builtin_ne(?y,?z)!=numeric_const("1") |- 
without
?y=?z
if 
 | ?y=?z |- 

rule obvious2:
 | builtin_ne(?y,?z)=numeric_const("1") |- 
without
?y!=?z
if 
 | ?y!=?z |- 

rule obvious3:
 | |- builtin_ne(?y,?z)!=numeric_const("1")
without
?y=?z
if 
 | |- ?y=?z

rule obvious4:
 | |- builtin_ne(?y,?z)=numeric_const("1")
without
?y!=?z
if 
 | |- ?y!=?z

// We cannot encode this rule as an axiom yet. It would be Cursor * Cursor ==> False in class DS_CURSOR
rule check:
 | Cursor(?x,{ds=?y}) * Cursor(?x,{ds=?z}) |- False
if

// This is another axiom. Since there are many ItemAt's on the left and many IsOff's on the right, jStar picks the wrong ones if the general axiom format is used.
rule someaxiom:
 | ItemAt(?current,{res=?result;ref=?iter;iters=?i;content=?c}) |- IsOff(?current,{res=false();ref=?iter;iters=?i;content=?c})
if
IsOff(?current,{res=false();ref=?iter;iters=?i;content=?c}) | ItemAt(?current,{res=?result;ref=?iter;iters=?i;content=?c}) |- !objsubtype(?current,"DS_TRAVERSABLE")

// Another axiom, but we cannot reason like this about types at the moment.
rule static_types:
 | Cursor(?x,{ds=?d}) |- !statictype(?d,"DS_TRAVERSABLE")
if
 | Cursor(?x,{ds=?d}) |- !statictype(?x,"DS_CURSOR")
or
 | Cursor(?x,{ds=?d}) |- !statictype(?x,"DS_DYNAMIC_CURSOR")

rule static_types2:
 Cursor(?x,{ds=?d}) | |- !statictype(?d,"DS_TRAVERSABLE")
if
 Cursor(?x,{ds=?d}) | |- !statictype(?x,"DS_CURSOR")
or
 Cursor(?x,{ds=?d}) | |- !statictype(?x,"DS_DYNAMIC_CURSOR")


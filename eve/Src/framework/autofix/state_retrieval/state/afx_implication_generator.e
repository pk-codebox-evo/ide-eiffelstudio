note
	description: "Summary description for {AFX_IMPLICATION_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_IMPLICATION_GENERATOR

inherit
	AFX_RELEVANT_STATE_EXPRESSION_GENERATOR

	AFX_ACCESS_AGENT_UTILITY

	AFX_SOLVER_FACTORY

feature -- Access

	implications: like possible_implications
			-- Implications generated by last `generate'

feature -- Generation

	generate (a_spot: AFX_TEST_CASE_INFO; a_expressions: HASH_TABLE [AFX_EXPR_RANK, EPA_EXPRESSION])
			-- <Precursor>
		local
			l_implications: DS_HASH_SET [AFX_IMPLICATION_EXPR]
			l_exprs: DS_HASH_SET [EPA_EXPRESSION]
		do
				-- Find implications from source code.
			l_implications := possible_implications (a_spot.recipient_written_class, atomic_predicates (a_spot.recipient_written_class, a_spot.recipient_))
--			l_implications := possible_implications (a_spot.recipient_class_, atomic_predicates (a_spot.recipient_class_, a_spot.recipient_))
			implications := l_implications
			create l_exprs.make (l_implications.count)
			l_exprs.set_equality_tester (create {EPA_EXPRESSION_EQUALITY_TESTER})

			l_implications.do_all (
				agent (a_imp: AFX_IMPLICATION_EXPR; a_store: DS_HASH_SET [EPA_EXPRESSION])
					do
						a_store.force_last (a_imp.as_expression)
					end (?, l_exprs))

			update_expressions_with_ranking (a_expressions, l_exprs, {AFX_EXPR_RANK}.rank_implication)
		end

feature{NONE} -- Implementation

	non_reflective_combinations (a_class: CLASS_C): LINKED_LIST [TUPLE [premise: EPA_EXPRESSION; consequent: EPA_EXPRESSION]]
			-- Non-reflective relation from `a_atomic_preds'
		local
			l_premise: EPA_EXPRESSION
			l_conse: EPA_EXPRESSION
			l_finder: AFX_IMPLICATION_FINDER
		do
			create l_finder.make
			l_finder.generate (a_class, Void)
			Result := l_finder.last_implications
		end

	implication_mutants (a_class: CLASS_C): DS_HASH_SET [AFX_IMPLICATION_EXPR]
			-- Implication mutations from `a_class'
		local
			l_preds: like implications_from_term
			l_combinations: like non_reflective_combinations
		do
			l_combinations := non_reflective_combinations (a_class)
			create Result.make (l_combinations.count * 4)
			Result.set_equality_tester (create {AFX_IMPLICATION_EXPR_EQUALITY_TESTER})

			from
				l_combinations := non_reflective_combinations (a_class)
				l_combinations.start
			until
				l_combinations.after
			loop
				from
					l_preds := implications_from_term (
						l_combinations.item_for_iteration.premise,
						l_combinations.item_for_iteration.consequent,
						a_class)

					l_preds.start
				until
					l_preds.after
				loop
					Result.force_last (l_preds.item_for_iteration)
					l_preds.forth
				end
				l_combinations.forth
			end
		end

	non_equivelant_implications (a_implications: DS_HASH_SET [AFX_IMPLICATION_EXPR]; a_atomic_predicates: like atomic_predicates): DS_HASH_SET [AFX_IMPLICATION_EXPR]
			-- Implications from `a_implications' with are not equavilant with any of the predicates in `a_predicates'
			-- in the context of `a_atomic_predicates'.`a_theory'
		local
			l_temp_exprs: LINKED_LIST [EPA_EXPRESSION]
			l_valid: BOOLEAN
			l_impl: AFX_IMPLICATION_EXPR
			l_expr: EPA_AST_EXPRESSION
			l_status: LINKED_LIST [BOOLEAN]
		do
			create l_temp_exprs.make

				-- Construct formulae for equavilance checking in `l_temp_exprs'.
			from
				a_implications.start
			until
				a_implications.after
			loop
				l_impl := a_implications.item_for_iteration
				from
					a_atomic_predicates.start
				until
					a_atomic_predicates.after
				loop
					create l_expr.make_with_text (l_impl.class_, l_impl.feature_, "(" + l_impl.text + ") = (" + a_atomic_predicates.item_for_iteration.text + ")", l_impl.written_class)
					l_temp_exprs.extend (l_expr)
					a_atomic_predicates.forth
				end
				a_implications.forth
			end

				-- Check for equavilance.
			l_status := solver_launcher.expression_validity (l_temp_exprs, a_atomic_predicates.theory)
			create Result.make (a_implications.count)
			Result.set_equality_tester (create {AFX_IMPLICATION_EXPR_EQUALITY_TESTER})

				-- Setup result.
			from
				a_implications.start
				l_status.start
			until
				a_implications.after
			loop
				l_impl := a_implications.item_for_iteration
				l_valid := False
				from
					a_atomic_predicates.start
				until
					a_atomic_predicates.after
				loop
					if l_status.item_for_iteration = {AFX_SOLVER_FACILITY}.predicate_valid then
						l_valid := True
					end
					a_atomic_predicates.forth
					l_status.forth
				end
				if not l_valid then
					Result.force_last (l_impl)
				end
				a_implications.forth
			end
		end

	possible_implications (a_class: CLASS_C; a_atomic_predicates: AFX_STATE_SKELETON): DS_HASH_SET [AFX_IMPLICATION_EXPR]
			-- Possible implications from `a_class'.
			-- All implications which are equivalent to any predicate
			-- in `a_atomic_predicates' are removed from the result.
		local
			l_implications: DS_HASH_SET [AFX_IMPLICATION_EXPR]
			l_satisfiable_implications: like predicate_satisfiability
			l_non_equiv_implications: like predicate_satisfiability
		do
				-- Get a set of implications from source code, and only keep those
				-- satisfiable implications.
			l_implications := implication_mutants (a_class)
			l_satisfiable_implications := predicate_satisfiability (l_implications, a_class, False, {AFX_SOLVER_FACILITY}.predicate_satisfiable)
			l_satisfiable_implications := predicate_satisfiability (l_satisfiable_implications, a_class, True, {AFX_SOLVER_FACILITY}.predicate_satisfiable)
			l_non_equiv_implications := non_equivelant_implications (l_satisfiable_implications, a_atomic_predicates)
			result := l_non_equiv_implications
		end

	predicate_satisfiability (a_predicates: DS_HASH_SET [AFX_IMPLICATION_EXPR]; a_class: CLASS_C; a_conjunction: BOOLEAN; a_required_satisfiability: NATURAL_8): DS_HASH_SET [AFX_IMPLICATION_EXPR]
			-- Predicate satisfiability table for predicates in `a_predicates'
			-- Key is the predicate, value is the satisfiacbility of that predicate:
			-- 0: Satisfiable
			-- 1: Valid
			-- 2: Contradictary			
		local
			l_normal_preds: LINKED_LIST [AFX_IMPLICATION_EXPR]
			l_exprs: DS_HASH_SET [EPA_EXPRESSION]
			l_validity: HASH_TABLE [NATURAL_8, EPA_EXPRESSION]
			l_valid: BOOLEAN
			l_negation_valid: BOOLEAN
			l_satis: NATURAL_8
			l_expr: EPA_EXPRESSION
			l_negated_expr: EPA_EXPRESSION
			l_skeleton: AFX_STATE_SKELETON
		do
				-- Transform predicates into {AFX_EXPRESSION}.
			create l_exprs.make (a_predicates.count)
			l_exprs.set_equality_tester (create {EPA_EXPRESSION_EQUALITY_TESTER})
			from
				a_predicates.start
			until
				a_predicates.after
			loop
				if a_conjunction then
					l_exprs.force_last (a_predicates.item_for_iteration.as_conjuction)
				else
					l_exprs.force_last (a_predicates.item_for_iteration.as_expression)
				end
				a_predicates.forth
			end

				-- Verify the satisfiability of `l_exprs'.
			create l_skeleton.make_with_expressions (a_class, Void, l_exprs.to_array.linear_representation)
			l_validity := solver_launcher.predicate_satisfiability (l_exprs, l_skeleton.theory)
			check l_validity.count = a_predicates.count end

				-- Select only predicates with the same satisfiability as `a_required_satisfiability'.
			create Result.make (a_predicates.count)
			Result.set_equality_tester (create {AFX_IMPLICATION_EXPR_EQUALITY_TESTER})
			from
				l_exprs.start
				a_predicates.start
				l_validity.start
			until
				a_predicates.after
			loop
				if l_validity.item (l_exprs.item_for_iteration) = a_required_satisfiability then
					Result.force_last (a_predicates.item_for_iteration)
				end
				a_predicates.forth
				l_validity.forth
				l_exprs.forth
			end
		end

	implications_from_term (a_premise: EPA_EXPRESSION; a_consequent: EPA_EXPRESSION; a_written_class: CLASS_C): LINKED_LIST [AFX_IMPLICATION_EXPR]
			-- All four possible ways to connect `a_premise' and `consequent' into an implication:
			-- 1. `a_premise' -> `a_consequent'.
			-- 2. `a_premise' -> not `a_consequent'.
			-- 3. not `a_premise' -> `a_consequent'.
			-- 4. not `a_premise' -> not `a_consequent'.
		local
			l_implication: AFX_IMPLICATION_EXPR
		do
			create Result.make
			create l_implication.make (
				create {AFX_MODIFIED_EXPRESSION}.make (a_premise, False),
				create {AFX_MODIFIED_EXPRESSION}.make (a_consequent, False),
				a_written_class)
			Result.extend (l_implication)

			create l_implication.make (
				create {AFX_MODIFIED_EXPRESSION}.make (a_premise, False),
				create {AFX_MODIFIED_EXPRESSION}.make (a_consequent, True),
				a_written_class)
			Result.extend (l_implication)

			create l_implication.make (
				create {AFX_MODIFIED_EXPRESSION}.make (a_premise, True),
				create {AFX_MODIFIED_EXPRESSION}.make (a_consequent, False),
				a_written_class)
			Result.extend (l_implication)

			create l_implication.make (
				create {AFX_MODIFIED_EXPRESSION}.make (a_premise, True),
				create {AFX_MODIFIED_EXPRESSION}.make (a_consequent, True),
				a_written_class)
			Result.extend (l_implication)
		ensure
			good_result: Result.count = 4
		end

	atomic_predicates (a_class: CLASS_C; a_feature: FEATURE_I): AFX_STATE_SKELETON
			-- List of predicates that are used as atomic terms
			-- in implication generation
		local
			l_gen: AFX_NESTED_EXPRESSION_GENERATOR
		do
			create l_gen.make
			l_gen.set_level (2)
			l_gen.expression_veto_agents.force (
				current_expression_veto_agent, 1)

			l_gen.expression_veto_agents.force (
				anded_agents (<<
					feature_expression_veto_agent,
					nested_not_on_basic_veto_agent,
					feature_not_obsolete_veto_agent,
					feature_with_few_arguments_veto_agent (0),
					boolean_expression_veto_agent>>)
				, 2)
			l_gen.generate (a_class, a_feature)

			create Result.make_with_accesses (a_class, a_feature, l_gen.accesses)
		end

note
	copyright: "Copyright (c) 1984-2009, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

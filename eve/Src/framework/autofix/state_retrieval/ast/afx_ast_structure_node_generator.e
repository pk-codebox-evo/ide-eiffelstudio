note
	description: "Summary description for {AFX_AST_STRUCTURE_NODE_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_AST_STRUCTURE_NODE_GENERATOR

inherit
	AST_ITERATOR
		redefine
			process_if_as,
			process_elseif_as,
			process_loop_as,
			process_inspect_as,
			process_case_as,
			process_check_as,
			process_debug_as,
			process_tagged_as,
			process_retry_as,
			process_instr_call_as,
			process_creation_as,
			process_assign_as,
			process_assigner_call_as
		end

	REFACTORING_HELPER

	AUT_CONTRACT_EXTRACTOR

feature -- Access

	structure: detachable AFX_FEATURE_AST_STRUCTURE_NODE
			-- Structure generated by the last `generate'

feature -- Basic operations

	generate (a_class: CLASS_C; a_feature: FEATURE_I)
			-- Generate AST structure for `a_feature' in context class `a_class',
			-- and store result in `structure'.
		local
			l_ast: AFX_HASHABLE_AST
		do
			fixme ("Does not support inline agent, rescue clause for the moment. 12.12.2009 Jasonw")

			written_class := a_class
			current_feature := a_feature
			structure := Void

			if attached {BODY_AS} a_feature.body.body as l_body then
				if attached {ROUTINE_AS} l_body.content as l_routine then
					if attached {DO_AS} l_routine.routine_body as l_do then
						next_bpslot := a_feature.first_breakpoint_slot_index - 1
						create l_ast.make (l_do, a_class)
						create {AFX_FEATURE_AST_STRUCTURE_NODE} structure.make (l_ast, a_class, a_feature, 0, Void)
						fixme ("The following lines related to setting next_bpslot for a feature which does not have preconditions is a hack. 31.1.2010 Jasonw")
							-- When a feature does not have precondition, the FEATURE_I.first_breakpoint_slot_index still reports 2.
							-- But in the actual trace, the break point number is 1.
						if precondition_of_feature (current_feature, written_class).is_empty and then current_feature.first_breakpoint_slot_index > 1 then
							structure.set_first_breakpoint_slot_number (1)
							next_bpslot := 0
						else
							structure.set_first_breakpoint_slot_number (next_bpslot + 1)
						end
						set_parent_node (structure)
						structure.extend_trunk
						safe_process (l_do.compound)
						structure.set_last_breakpoint_slot_number (next_bpslot)
					end
				end
			end
		end

feature{NONE} -- Impelementation

	current_feature: FEATURE_I
			-- Feature which is currently being processed

	written_class: CLASS_C
			-- Class where `structure' is written

	next_bpslot: INTEGER
			-- Next breakpoint slot that can be used

	parent_node: detachable AFX_AST_STRUCTURE_NODE
			-- Parent node that is currently being processed

feature{NONE} -- Implementation

	set_parent_node (a_node: like parent_node)
			-- Set `parent_node' with `a_node'.
		do
			parent_node := a_node
		ensure
			parent_node_set: parent_node = a_node
		end

	hashable_ast (a_ast: AST_EIFFEL): AFX_HASHABLE_AST
			-- Hashable AST for `a_ast'
		do
			create Result.make (a_ast, written_class)
		end

feature{NONE} -- Process

	process_if_as (l_as: IF_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
		do
			l_parent := parent_node
			next_bpslot := next_bpslot + 1

				-- Register `l_as' into `parent_node'.
			create l_node.make (hashable_ast (l_as), written_class, current_feature, next_bpslot, l_parent)
			l_parent.extend_child_to_last_trunk (l_node)

				-- Process then branch.
			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.compound)

				-- Process elseif branches.	
			set_parent_node (l_node)
			safe_process (l_as.elsif_list)

				-- Process else branch.
			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.else_part)

			set_parent_node (l_parent)
		end

	process_elseif_as (l_as: ELSIF_AS)
		local
			l_node: AFX_AST_STRUCTURE_NODE
			l_parent: like parent_node
		do
				-- Register itself.
			l_parent := parent_node
			next_bpslot := next_bpslot + 1
			create l_node.make (hashable_ast (l_as), written_class, current_feature, next_bpslot, parent_node)
			l_parent.extend_child_to_last_trunk (l_node)

				-- Process elseif content.
			set_parent_node (l_parent)
			l_parent.extend_trunk
			safe_process (l_as.compound)

			set_parent_node (l_parent)
		end

	process_loop_as (l_as: LOOP_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
			l_cond: AFX_AST_STRUCTURE_NODE
			l_cond_bpslot: INTEGER
		do
			fixme ("Do not support loop invariant and variant for the moment. 12.12.2009 Jasonw")
				-- Register itself.
			l_parent := parent_node
			create l_node.make (hashable_ast (l_as), written_class, current_feature, 0, l_parent)
			l_parent.extend_child_to_last_trunk (l_node)

				-- Process from part.
			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.from_part)
			next_bpslot := next_bpslot + 1
			l_cond_bpslot := next_bpslot
			create l_cond.make (hashable_ast (l_as.stop), written_class, current_feature, next_bpslot, l_node)
			l_node.extend_child_to_last_trunk (l_cond)

				-- Process loop body.
			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.compound)
			create l_cond.make (hashable_ast (l_as.stop), written_class, current_feature, l_cond_bpslot, l_node)
			l_node.extend_child_to_last_trunk (l_cond)

			set_parent_node (l_parent)
		end

	process_inspect_as (l_as: INSPECT_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
		do
			l_parent := parent_node

				-- Register itself.
			next_bpslot := next_bpslot + 1
			create l_node.make (hashable_ast (l_as), written_class, current_feature, next_bpslot, l_parent)

				-- Process case list.
			set_parent_node (l_node)
			safe_process (l_as.case_list)

				-- Process else part.
			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.else_part)

			set_parent_node (l_parent)
		end

	process_case_as (l_as: CASE_AS)
		local
			l_parent: like parent_node
		do
			l_parent := parent_node
			l_parent.extend_trunk
			safe_process (l_as.compound)
			set_parent_node (l_parent)
		end

	process_check_as (l_as: CHECK_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
		do
			l_parent := parent_node
			create l_node.make (hashable_ast (l_as), written_class, current_feature, 0, l_parent)
			l_parent.extend_child_to_last_trunk (l_node)

			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.check_list)

			set_parent_node (l_parent)
		end

	process_tagged_as (l_as: TAGGED_AS)
		local
			l_node: AFX_AST_STRUCTURE_NODE
		do
			if attached l_as.expr then
				next_bpslot := next_bpslot + 1
				create l_node.make (hashable_ast (l_as), written_class, current_feature, next_bpslot, parent_node)
				parent_node.extend_child_to_last_trunk (l_node)
			end
		end

	process_debug_as (l_as: DEBUG_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
		do
			l_parent := parent_node
			create l_node.make (hashable_ast (l_as), written_class, current_feature, 0, l_parent)
			l_parent.extend_child_to_last_trunk (l_node)

			set_parent_node (l_node)
			l_node.extend_trunk
			safe_process (l_as.compound)

			set_parent_node (l_parent)
		end

	process_instruction_as (l_as: INSTRUCTION_AS)
		local
			l_parent: like parent_node
			l_node: AFX_AST_STRUCTURE_NODE
		do
			l_parent := parent_node
			next_bpslot := next_bpslot + 1
			create l_node.make (hashable_ast (l_as), written_class, current_feature, next_bpslot, l_parent)
			l_parent.extend_child_to_last_trunk (l_node)
		end

	process_retry_as (l_as: RETRY_AS)
		do
			process_instruction_as (l_as)
		end

	process_instr_call_as (l_as: INSTR_CALL_AS)
		do
			process_instruction_as (l_as)
		end

	process_creation_as (l_as: CREATION_AS)
		do
			process_instruction_as (l_as)
		end

	process_assign_as (l_as: ASSIGN_AS)
		do
			process_instruction_as (l_as)
		end

	process_assigner_call_as (l_as: ASSIGNER_CALL_AS)
		do
			process_instruction_as (l_as)
		end

end

note
	description: "Alias relation (commutative, irreflexive) between expressions."
	author: "Bertrand Meyer"
	date: "$Date$"
	revision: "$Revision$"
	related: "[
			The associated classes ALIASES_SORTED and ALIASES_CANONICAL provide
			specific representations of an alias relation. They are not, however,
			defined as heirs (no need).
			]"
	MODIFICATION_RULE: "[
			Any routine that can change the contents of the relation must,
			prior to carrying out any such changes, call `invalidate_sorted_representation'.
			]"

class
	ALIAS_RELATION

inherit
	HASH_TABLE [HASH_TABLE [EXPRESSION, EXPRESSION], EXPRESSION]
		rename
			put as ht_put, remove as ht_remove, make as ht_make, has as ht_has
		redefine
			copy, is_equal, empty_duplicate
		select
			copy, is_equal
		end

	HASHABLE
		rename copy as old_copy, is_equal as old_is_equal end

	SIZING
		rename copy as old_copy1, is_equal as old_is_equal1 end

create
	make

create {ALIAS_RELATION}
	make_sized

feature -- Initialization

	make
			-- Initialize with room for `Min_expressions' expressions.
		do
			make_sized (Min_expressions)
		end

	make_sized (n: INTEGER)
			-- Initialize with room for `n' expressions.
		require
			positive: n > 0
		do
			ht_make (n)
			invalidate_sorted_representation	-- Not necessary thanks to automatic initialization,
												-- included for clarity
			create successors.make (Min_expressions)
		end

feature -- Access

	successors: HASH_TABLE [HASH_TABLE [INTEGER, EXPRESSION], VARIABLE]
			-- For every variable ` x', the expressions starting with
			-- `x' (i.e. `x.e' for some `e') in the alias relations.
			-- The integers in subtables do not matter (by default
			-- we set them all to zero).
			-- The semantics of `successors' is possibly conservative
			-- as we do not always bother to remove elements: if `x.e'
			-- appears in the relation, then `successors [x]' includes an entry
			-- of key `x.e', but not necessarily the other way around.

	aliases (e: EXPRESSION): SORTED_TWO_WAY_LIST [EXPRESSION]
			-- List (possibly empty) of expressions directly aliased
			-- to `e' in current alias relation.
			-- `Direct' because in looking up the aliases of `a.b'
			-- we don't consider the aliases of `a' and the aliases
			-- of `b', just the aliases recorded for `a.b'.
		local
			eht: HASH_TABLE [EXPRESSION, EXPRESSION]
		do
			create {SORTED_TWO_WAY_LIST [EXPRESSION]} Result.make
			if ht_has (e) then
				from
					eht := item (e)
					eht.start
				until
					eht.off
				loop
					debug ("MULTIDOT_ASSIGNMENT") print ("Extending list of aliases: ") ;	eht.item_for_iteration.printout end
					Result.extend (eht.key_for_iteration)
					eht.forth
				end
--				Result.sort		-- We do not need to sort here, see `printout'. BM ,Dec 2009
			end
		ensure
			list_exists: Result /= Void
			irreflexive: not Result.has (e)
		end

	sorted_representation: ALIASES_SORTED
			-- List of aliased expressions, each with its list of aliases.
		local

		do
			if not has_sorted_representation then
				create computed_sorted_representation.make (Current)
				validate_sorted_representation
			end
			Result := computed_sorted_representation
		ensure
			exists: Result /= Void
		end

feature -- Measurement

	hash_code: INTEGER
			-- Hashing value (currently just the number of aliases).
		do
			Result := count
		end

feature -- Comparison

	is_equal (other: ALIAS_RELATION): BOOLEAN
			-- Equality: should be defined as deep equality?
		local
			rep, rep_other: ALIASES_SORTED
		do
				-- The following version causes a postcondition violation in is_deep_equal!
--			Result := is_deep_equal (other)
				-- Other rejected versions. FIXME: These lines should just be removed at some point BM 5 Jan 2010
--			Result := Precursor {HASH_TABLE} (other)
--			Result :=
--				keys ~ other.keys and
--				content ~ other.content and
--				deleted_marks ~ other.deleted_marks and
--				(has_default = other.has_default)
--			Result :=
--				keys.is_deep_equal (other.keys) and
--				content.is_deep_equal (other.content) and
--				deleted_marks.is_deep_equal (other.deleted_marks) and
--				(has_default = other.has_default)

				-- The following version seems to do what we want, albeit expensively:
			rep := sorted_representation
			rep_other := other.sorted_representation
			Result := rep.is_equal (rep_other)
		end

	difference (other: ALIAS_RELATION): STRING
			-- What kind of difference is there with `other'?
			-- (Only useful if not equal)
		do
			create Result.make_empty
			if not keys.is_deep_equal (other.keys) then	Result := Result + " Unequal keys " end
			if not 	content.is_deep_equal (other.content) then 	Result := Result + " Unequal content " end
			if not deleted_marks.is_deep_equal (other.deleted_marks) then	Result := Result + " Unequal deletion marks " end
			if  not	(has_default = other.has_default) then	Result := Result + " Unequal defaults " end
		end

feature -- Status report

	has (e, f: EXPRESSION): BOOLEAN
			-- Is pair [`e', `f'] in relation?
		local
			eht: HASH_TABLE [EXPRESSION, EXPRESSION]
		do
			eht := item (e)
			Result := (eht /= Void) and then eht.has (f)
		ensure
			symmetric: Result = has (f, e)
		end

feature -- Status setting

	invalidate_sorted_representation
			-- Record that sorted representation is no longer up to date.
		do
			has_sorted_representation := False
		end

	validate_sorted_representation
			-- Record that sorted representation is now up to date.
		do
			has_sorted_representation := True
		end


feature -- Element change

	put (e, f: EXPRESSION)
			-- If `e' and `f' are different, insert pairs [`e', `f']
			-- and [`f',`e']; do nothing if equal.
		do
			debug ("PUT_IN_ALIAS_RELATION")
				io.put_string ("-- Argument 1: "); io.put_string (e.name)
				io.put_string (". Argument 2: "); io.put_string (f.name)
				io.put_new_line
			end
			invalidate_sorted_representation
			if e /~ f then
				put_successor (e, f)
				put_successor (f, e)
			end
		ensure
			present_if_distinct: (e /~ f) implies has (e, f)
		end

	add (other: ALIAS_RElATION)
			-- Add all aliases from òther'.
		require
			exists: other /= Void
			different: other /= Current
		local
			oht: HASH_TABLE [EXPRESSION, EXPRESSION]
			e: EXPRESSION
		do
			invalidate_sorted_representation
			from
				other.start
			until
				other.off
			loop
				oht := other.item_for_iteration
				e := other.key_for_iteration
				from
					oht.start
				until
					oht.off
				loop
					put_successor (e, oht.key_for_iteration)
							-- FIXME Why put_successor directly, and not put? BM 7 Jan 2010
					oht.forth
				end
				other.forth
			end
		end

	remove (e, f: EXPRESSION)
			-- Remove pairs [`e', `f'] and [`f,`e'].
			-- Do nothing if they were not present.
		local
			eht, fht: HASH_TABLE [EXPRESSION, EXPRESSION]
		do
			invalidate_sorted_representation
			if ht_has (e) then
						check ht_has (f) end
				eht := item (e)
				fht := item (f)
				eht.remove (f)
				fht.remove (e)
			end

		ensure
			absent: not has (e, f)
		end

	remove_item (e: EXPRESSION)
			-- Remove `e' entirely from relation,
			-- i.e. remove all pairs including `e'.
		local
			assoc: LIST [EXPRESSION]
		do
			invalidate_sorted_representation
			from
				assoc := aliases (e)
				assoc.start
			until assoc.after loop
				remove (e, assoc.item)
				assoc.forth
			end

		end

feature -- Duplication

	copy (other: like Current)
			-- Re-initialize from `other'.
		do
			invalidate_sorted_representation
			Precursor {HASH_TABLE} (other)
--			deep_copy (other)	-- This does not work (deep_copy calls copy!
			successors := other.successors.twin
		end




feature -- Input and output

	printout (tag: STRING)
			-- Produce text representation of relation, including message `tag'.
			-- For the moment: print sorted representation.
		require
			exists: tag /= Void
		do
			sorted_representation.printout (tag)
		end


feature -- Basic operations

	update (i: INSTRUCTION)
			-- Take into account aliases induced by `i'.
		require
			instruction_exists: i /= Void
			applicable: i.is_applicable (Current)
		do
			invalidate_sorted_representation
			i.update (Current)
		end

feature {NONE} -- Implementation

	put_successor (e, f: EXPRESSION)
			-- Add `f' to successors of `e'.
		require
			different: e /~ f
		local
			eht: HASH_TABLE [EXPRESSION, EXPRESSION]
		do
			invalidate_sorted_representation
			if ht_has (e) then
				eht := item (e)
			else
				create eht.make (Average_aliases)
				ht_put (eht, e)
			end
			check eht = item (e) end
			eht.force (f, f)
		end

	has_sorted_representation: BOOLEAN
			-- Is sorted representation available and up to date?
			-- RULE: call `invalidate_sorted_representation' whenever modifying the relation.

	computed_sorted_representation: ALIASES_SORTED
			-- Sorted representation, computed and stored for reuse
			-- if needed again when the relation has not changed.

	empty_duplicate (n: INTEGER_32): ALIAS_RELATION
			-- Create an empty copy of Current that can accommodate `n' items
			-- (export status {NONE})
		do
			create Result.make_sized (n)
		end

invariant
	consistent_computed_representation: has_sorted_representation implies (computed_sorted_representation /= Void)
	successors_exist: successors /= Void

end

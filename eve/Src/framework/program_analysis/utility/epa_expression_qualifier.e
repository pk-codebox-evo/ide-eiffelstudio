note
	description: "Class to generate qualified expressions out of unqualified expressions"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	EPA_EXPRESSION_QUALIFIER

inherit
	EPA_TRANSITION_EXPRESSION_REWRITER
		redefine
			process_access_name,
			process_un_old_as
		end

	EPA_UTILITY

feature -- Status report

	is_local_detected: BOOLEAN
			-- Is there any local variable detected during last `process_expression'?

	is_old_detected: BOOLEAN
			-- Is there any old expression detected during last `process_expression'?

feature -- Access

	last_expression: STRING
			-- Last expression generated by last `process_expression'

feature -- Basic operation

	process_expression (a_expression: EPA_EXPRESSION; a_replacements: HASH_TABLE [STRING, STRING])
			-- Process `a_expression'.
		local
			l_qualified_expr: STRING
		do
			feature_ := a_expression.feature_
			context_class := a_expression.context_class
			written_class := a_expression.written_class
			create feature_context.make (feature_, create {ETR_CLASS_CONTEXT}.make (context_class))
			local_table := feature_context.local_by_name
			if local_table = Void then
				create local_table.make (0)
				local_table.compare_objects
			end
			arguments := arguments_of_feature (feature_)
			create output.make
			is_local_detected := False
			is_old_detected := False
			last_replacements := a_replacements
			l_qualified_expr := expression_text (a_expression, last_replacements)
			last_expression := output.string_representation
		end

feature{NONE} -- Implementation

	feature_: FEATURE_I
			-- Feature where the expression being processed belongs to

	context_class: CLASS_C
			-- Context class

	written_class: CLASS_C
			-- Class where the expression being processed is written

	feature_context: ETR_FEATURE_CONTEXT
			-- Featue context

	local_table: detachable HASH_TABLE [ETR_TYPED_VAR, STRING]
			-- Table for locals
			-- Keys are local names, values are types of those locals

	arguments: like arguments_of_feature
			-- Table for arguments of `feature_'
			-- Keys are argument names, values are 1-based argument index.

	last_replacements: HASH_TABLE [STRING, STRING]
			-- Replacements
			-- Keys are text appearing in expressions
			-- values are text that should replace keys.


feature{NONE} -- Processing

	process_access_name (a_name: STRING)
			-- Process accessed variable named `a_name'.
		local
			l_name: STRING
			l_encountered: like encountered_names
			l_is_local: BOOLEAN
			l_is_argument: BOOLEAN
		do
			if last_was_unqualified then
					-- Check for local variables.	
				if attached {HASH_TABLE[ETR_TYPED_VAR, STRING]} local_table as l_locals then
					if l_locals.has (a_name) then
						if not is_local_detected then
							is_local_detected := True
							l_is_local := True
						end
					end
				end
					-- Check for arguments.					
				if not l_is_local then
					l_is_argument := arguments.has (a_name)
				end

				if l_is_local or l_is_argument then
					if last_was_unqualified then
						if last_was_unqualified then
							last_replacements.search (a_name)
							if last_replacements.found then
								output.append_string (last_replacements.found_item)
							else
								output.append_string (a_name)
							end
						end
					else
						output.append_string (a_name)
					end
				else
						-- This is a feature access
					if last_was_unqualified then
						if written_class.feature_named (a_name) /= Void then
							if last_was_unqualified then
								last_replacements.search (once "")
								if last_replacements.found then
									output.append_string (last_replacements.found_item)
								end
								output.append_string (a_name)
							end
						else
							output.append_string (a_name)
						end
					end
				end
			else
				output.append_string (a_name)
			end
		end

	process_un_old_as (l_as: UN_OLD_AS)
		do
			if not is_old_detected then
				is_old_detected := True
			end
			Precursor (l_as)
		end

end

note
	description: "Class to generate feature which is used to retrieve object(s) state"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AUT_OBJECT_STATE_RETRIEVAL_FEATURE_GENERATOR

inherit
	AUT_SHARED_INTERPRETER_INFO

	SHARED_WORKBENCH

	EPA_UTILITY

	EPA_STRING_UTILITY

	EPA_SHARED_EQUALITY_TESTERS

feature -- Access

	feature_text: STRING
			-- Text of the feature to retrieve object(s) state,
			-- generated by last `generate_for_feature'.

	config: detachable AUT_OBJECT_STATE_CONFIG
			-- Configuration for object state retrieval

feature -- Status report

	is_for_feature: BOOLEAN
			-- Is `feature_text' for acquiring states for operands in a feature?

	is_for_objects: BOOLEAN
			-- Is `feature_text' for acquiring states for arbitrary objects?
		do
			Result := not is_for_feature
		end

feature -- Setting

	set_config (a_config: like config)
			-- Set `config' with `a_config'.
		do
			config := a_config
		ensure
			config_set: config = a_config
		end

feature -- Basic operations

	generate_for_feature (a_context_class: CLASS_C; a_feature: FEATURE_I; a_prestate: BOOLEAN; a_is_creation: BOOLEAN; a_target_type: TYPE_A)
			-- Generate feature to retrieve states for operands of `a_feature' viewed in `a_context_class',
			-- make result available in `feature_text'.
			-- `a_prestate' indicates whether the found expressions are to be evaluated before
			-- the execution of the test case. This is important because expressions such as "Result"
			-- does not make sense to be evaluated before the test case execution.
			-- `a_is_creation' indicates if `a_feature' is used as a creation procedure.
			-- `a_target_type' indicates the type of the target of `a_feature'.
		local
			l_finder: AUT_OBJECT_STATE_EXPRESSION_FINDER
			l_operands: like operands_of_feature
		do
			is_for_feature := True
				-- Search for expressions that are included in state model.
			create l_finder.make
			l_finder.search_for_feature (a_context_class, a_feature, a_prestate, a_is_creation, interpreter_root_class, a_target_type)

			if attached {AUT_OBJECT_STATE_CONFIG} config as l_config and then l_config.is_all then
				functions_by_target := l_finder.functions_by_target
			else
				collect_argumentless_queries (l_finder.functions_by_target)
			end

			attributes_by_target := l_finder.attributes_by_target
			variables := l_finder.variables
			operand_map := l_finder.operand_map

				-- Generate body for the state retrieval feature.
			generate_feature_text
		end

	generate_for_objects (a_objects: HASH_TABLE [TYPE_A, INTEGER])
			-- Generate feature to retrieve states for objects.
			-- `a_objects' is a table, key is the object id (used in object pool),
			-- value is type of that object.
		local
			l_finder: AUT_OBJECT_STATE_EXPRESSION_FINDER
			l_variables: HASH_TABLE [TYPE_A, STRING]
			l_cursor: CURSOR
			l_operand_map: like operand_map
		do
			is_for_feature := False
			create l_variables.make (a_objects.count)
			l_variables.compare_objects
			l_cursor := a_objects.cursor
			from
				a_objects.start
			until
				a_objects.after
			loop
				l_variables.put (a_objects.item_for_iteration, variable_name (a_objects.key_for_iteration))
				a_objects.forth
			end
			a_objects.go_to (l_cursor)

			create l_finder.make
			l_finder.search_for_variables (l_variables)
			if attached {AUT_OBJECT_STATE_CONFIG} config as l_config and then l_config.is_all then
				functions_by_target := l_finder.functions_by_target
			else
				collect_argumentless_queries (l_finder.functions_by_target)
			end
			attributes_by_target := l_finder.attributes_by_target
			remove_non_integer_expressions
			variables := l_finder.variables
			operand_map := l_finder.operand_map
			create operand_map.make (a_objects.count)
			l_operand_map := operand_map
			l_cursor := a_objects.cursor
			from
				a_objects.start
			until
				a_objects.after
			loop
				l_operand_map.put (variable_name (a_objects.key_for_iteration), a_objects.key_for_iteration)
				a_objects.forth
			end

				-- Generate body for the state retrieval feature.
			generate_feature_text
		end

feature{NONE} -- Implementation

	generate_feature_text
			-- Generate `feature_text'.
		do
			create feature_text.make (2048)
			feature_text.append (feature_name_for_byte_code_injection)
			feature_text.append_character ('%N')
			generate_locals
			generate_body
			feature_text.append ("end%N")
		end

	generate_body
			-- Generate feature body for `feature_text'.
		do
			feature_text.append ("do%N")
			feature_text.append ("create vtbl.make (5)%N")
			generate_variable_lookup
			generate_state_retrieval
		end

	generate_variable_lookup
			-- Generate variable lookup part of `feature_text'.
		local
			l_cursor: DS_HASH_TABLE_CURSOR [STRING, INTEGER]
			l_text: like feature_text
		do
			l_text := feature_text
			from
				l_cursor := operand_map.new_cursor
				l_cursor.start
			until
				l_cursor.after
			loop
				l_text.append (l_cursor.item)
				l_text.append (once " ?= variable_at_index (")
				l_text.append (anonymous_variable_name (l_cursor.key))
				l_text.append (once ")%N")
				l_cursor.forth
			end
		end

	generate_state_retrieval
			-- Generate state retrieval part of `feature_text'.
		local
			l_text: like feature_text
			l_variables: like variables
			l_expressions_by_target: like functions_by_target
			l_attrs_by_target: like attributes_by_target
			l_var_name: STRING
			l_var_type: TYPE_A
			l_queries: DS_HASH_SET [EPA_EXPRESSION]
			l_operand_index: INTEGER
			l_map_cursor: DS_HASH_TABLE_CURSOR [STRING, INTEGER]
			l_anony_operand_index: STRING
			l_replacements: HASH_TABLE [STRING, STRING]
			l_expr_text: STRING
		do
			l_text := feature_text
			l_variables := variables
			l_expressions_by_target := functions_by_target
			l_attrs_by_target := attributes_by_target
			l_map_cursor := operand_map.new_cursor
				-- Create variable name replacements.
			create l_replacements.make (operand_map.count)
			from
				l_map_cursor.start
			until
				l_map_cursor.after
			loop
				l_replacements.put (double_square_surrounded_integer (l_map_cursor.key), l_map_cursor.item)
				l_map_cursor.forth
			end

				-- Generate queries.
			from
				l_map_cursor.start
			until
				l_map_cursor.after
			loop
				l_var_name := l_map_cursor.item
				l_var_type := l_variables.item (l_var_name)
				l_operand_index := l_map_cursor.key
				l_anony_operand_index := anonymous_variable_name (l_operand_index)
				l_text.append (once "if not vtbl.has (")						-- if not vtbl.has
				l_text.append (l_anony_operand_index)
				l_text.append (once ") then%N")
				l_text.append (once "vtbl.put (0, ")
				l_text.append (l_anony_operand_index)
				l_text.append (once ")%N")
				if l_var_type.is_basic then
					l_text.append (once "record_basic_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ", ")
					l_text.append (l_var_name)
					l_text.append (once ".out)%N")
				else
					l_text.append (once "if ")
					l_text.append (l_var_name)
					l_text.append (once " /= Void then%N")
					l_text.append (once "is_last_invariant_violated := False%N")
					l_text.append (once "check_invariant (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ", ")
					l_text.append (l_var_name)
					l_text.append (once ")%N")
					l_text.append (once "if is_last_invariant_violated then%N")
					l_text.append (once "record_invariant_violating_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ")%N")
					l_text.append (once "is_last_invariant_violated := False%N")
					l_text.append ("else%N")

						-- Generate attribute queries.
					l_attrs_by_target.search (l_var_name)
					if l_attrs_by_target.found then
						l_queries := l_attrs_by_target.found_item
						from
							l_queries.start
						until
							l_queries.after
						loop
							l_text.append (once "record_attribute_value (%"")
							l_expr_text := expression_text_with_replacement (l_queries.item_for_iteration, l_replacements)
							l_text.append (l_expr_text)
							l_text.append (once "%", ")
							l_text.append (l_queries.item_for_iteration.text)
							l_text.append (")%N")
							l_queries.forth
						end
					end

						-- Generate function queries.
					l_expressions_by_target.search (l_var_name)
					if l_expressions_by_target.found then
						l_queries := l_expressions_by_target.found_item
						from
							l_queries.start
						until
							l_queries.after
						loop
							l_text.append (once "record_function_value (%"")
							l_expr_text := expression_text_with_replacement (l_queries.item_for_iteration, l_replacements)
							l_text.append (l_expr_text)
							l_text.append (once "%", agent ")
							l_text.append (l_queries.item_for_iteration.text)
							l_text.append (")%N")
							l_queries.forth
						end
					end
					l_text.append (once "end%N")
					l_text.append (once "else%N")
					l_text.append (once "record_void_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ")%N")
					l_text.append (once "end%N")
				end
				l_text.append (once "end%N")
				l_map_cursor.forth
			end
		end

	generate_locals
			-- Generate local definitions for `feature_text'.
		local
			l_variables: like variables
			l_cursor: CURSOR
			l_text: like feature_text
			l_operands: like operands_of_feature
		do
			l_text := feature_text
			l_text.append ("local%N")

			l_variables := variables
			l_cursor := l_variables.cursor
			from
				l_variables.start
			until
				l_variables.after
			loop
				l_text.append (l_variables.key_for_iteration)
				l_text.append (once ": ")
				l_text.append (l_variables.item_for_iteration.name)
				l_text.append_character ('%N')
				l_variables.forth
			end
			l_variables.go_to (l_cursor)

			l_text.append (once "vtbl: HASH_TABLE [INTEGER, INTEGER]%N")
		end

	functions_by_target: HASH_TABLE [DS_HASH_SET [EPA_EXPRESSION], STRING]
			-- Table of functions expressoins by their target variable
			-- Key is the variale name, value is the set of expressions of the same target.
			-- Each expression must be a qualified call, for example "v_1.exhausted".

	attributes_by_target: HASH_TABLE [DS_HASH_SET [EPA_EXPRESSION], STRING]
			-- Table of attribute expressoins by their target variable
			-- Key is the variale name, value is the set of expressions of the same target.
			-- Each expression must be a qualified call, for example "v_1.count".

	variables: HASH_TABLE [TYPE_A, STRING]
			-- Table of variables found by last `search_for_feature'
			-- Key is variable name, value is the resolved type of that variable

	operand_map: DS_HASH_TABLE [STRING, INTEGER]
			-- Operand map for `variables'
			-- Key is 0-based operand index, key is variable name

	variable_name (a_index: INTEGER): STRING
			-- Name of variable with `a_index'.
		do
			create Result.make (5)
			Result.append (once "v_")
			Result.append (a_index.out)
		end

	remove_non_integer_expressions
			-- Remove non-integer expressions in `functions_by_target'.
		local
			l_tbl: like functions_by_target
			l_cursor: CURSOR
			l_set: DS_HASH_SET [EPA_EXPRESSION]
			l_new_set: DS_HASH_SET [EPA_EXPRESSION]
		do
			l_tbl := functions_by_target
			l_cursor := l_tbl.cursor
			from
				l_tbl.start
			until
				l_tbl.after
			loop
				l_set := l_tbl.item_for_iteration
				create l_new_set.make (l_set.count)
				l_new_set.set_equality_tester (expression_equality_tester)
				l_new_set.do_if (agent l_new_set.force_last, agent (a_expr: EPA_EXPRESSION): BOOLEAN do Result := a_expr.is_integer end)
				l_tbl.put (l_new_set, l_tbl.key_for_iteration)
				l_tbl.forth
			end
			l_tbl.go_to (l_cursor)
		end

	collect_argumentless_queries (a_funcs_by_target: like functions_by_target)
			-- Collect argument-less queries from `a_funcs_by_target' and set them into `functions_by_target'.
		local
			l_funcs_by_target: like functions_by_target
			l_funcs: DS_HASH_SET [EPA_EXPRESSION]
			l_new_funcs: DS_HASH_SET [EPA_EXPRESSION]
		do
			create functions_by_target.make (a_funcs_by_target.count)
			l_funcs_by_target := functions_by_target
			l_funcs_by_target.compare_objects
			from
				a_funcs_by_target.start
			until
				a_funcs_by_target.after
			loop
				l_funcs := a_funcs_by_target.item_for_iteration
				create l_new_funcs.make (l_funcs.count)
				l_new_funcs.set_equality_tester (expression_equality_tester)
				from
					l_funcs.start
				until
					l_funcs.after
				loop
					if not l_funcs.item_for_iteration.text.has ('(') then
						l_new_funcs.force_last (l_funcs.item_for_iteration)
					end
					l_funcs.forth
				end
				l_funcs_by_target.force (l_new_funcs, a_funcs_by_target.key_for_iteration)
				a_funcs_by_target.forth
			end
		end

note
	copyright: "Copyright (c) 1984-2010, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

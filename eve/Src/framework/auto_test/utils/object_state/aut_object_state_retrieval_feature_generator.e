note
	description: "Class to generate feature which is used to retrieve object(s) state"
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AUT_OBJECT_STATE_RETRIEVAL_FEATURE_GENERATOR

inherit
	AUT_SHARED_INTERPRETER_INFO

	SHARED_WORKBENCH

	EPA_UTILITY

	EPA_STRING_UTILITY

	EPA_SHARED_EQUALITY_TESTERS

feature -- Access

	feature_text: STRING
			-- Text of the feature to retrieve object(s) state,
			-- generated by last `generate_for_feature'.

	config: detachable AUT_OBJECT_STATE_CONFIG
			-- Configuration for object state retrieval

	feature_: FEATURE_I
			-- Feature under consideration

	class_: CLASS_C
			-- Class where `feature_' is from

feature -- Setting

	set_config (a_config: like config)
			-- Set `config' with `a_config'.
		do
			config := a_config
		ensure
			config_set: config = a_config
		end

feature -- Basic operations

	generate_for_feature (a_context_class: CLASS_C; a_feature: FEATURE_I; a_prestate: BOOLEAN; a_is_creation: BOOLEAN; a_target_type: TYPE_A)
			-- Generate feature to retrieve states for operands of `a_feature' viewed in `a_context_class',
			-- make result available in `feature_text'.
			-- `a_prestate' indicates whether the found expressions are to be evaluated before
			-- the execution of the test case. This is important because expressions such as "Result"
			-- does not make sense to be evaluated before the test case execution.
			-- `a_is_creation' indicates if `a_feature' is used as a creation procedure.
			-- `a_target_type' indicates the type of the target of `a_feature'.
		local
			l_finder: AUT_OBJECT_STATE_EXPRESSION_FINDER
			l_operands: like operands_of_feature
		do
			should_return_reference_operand_address := False

				-- Search for expressions that are included in state model.
			create l_finder.make
			l_finder.search_for_feature (a_context_class, a_feature, a_prestate, a_is_creation, interpreter_root_class, a_target_type)

			if attached {AUT_OBJECT_STATE_CONFIG} config as l_config and then l_config.is_all then
				functions_by_target := l_finder.functions_by_target
			else
				collect_argumentless_queries (l_finder.functions_by_target)
			end

			attributes_by_target := l_finder.attributes_by_target
			variables := l_finder.variables
			operand_map := l_finder.operand_map

				-- Generate body for the state retrieval feature.
			generate_feature_text
		end

	generate_for_objects (a_objects: HASH_TABLE [TYPE_A, INTEGER])
			-- Generate feature to retrieve states for objects.
			-- `a_objects' is a table, key is the object id (used in object pool),
			-- value is type of that object.
		local
			l_finder: AUT_OBJECT_STATE_EXPRESSION_FINDER
			l_variables: HASH_TABLE [TYPE_A, STRING]
			l_cursor: CURSOR
			l_operand_map: like operand_map
		do
			should_return_reference_operand_address := False
			create l_variables.make (a_objects.count)
			l_variables.compare_objects
			l_cursor := a_objects.cursor
			from
				a_objects.start
			until
				a_objects.after
			loop
				l_variables.put (a_objects.item_for_iteration, variable_name (a_objects.key_for_iteration))
				a_objects.forth
			end
			a_objects.go_to (l_cursor)

			create l_finder.make
			l_finder.search_for_variables (l_variables)
			if attached {AUT_OBJECT_STATE_CONFIG} config as l_config and then l_config.is_all then
				functions_by_target := l_finder.functions_by_target
			else
				collect_argumentless_queries (l_finder.functions_by_target)
			end
			attributes_by_target := l_finder.attributes_by_target
			remove_non_integer_expressions
			variables := l_finder.variables
			operand_map := l_finder.operand_map
			create operand_map.make (a_objects.count)
			l_operand_map := operand_map
			l_cursor := a_objects.cursor
			from
				a_objects.start
			until
				a_objects.after
			loop
				l_operand_map.put (variable_name (a_objects.key_for_iteration), a_objects.key_for_iteration)
				a_objects.forth
			end

				-- Generate body for the state retrieval feature.
			generate_feature_text
		end

	generate_for_expressions (a_expressions: LINKED_LIST [EPA_EXPRESSION]; a_context_class: CLASS_C; a_feature: FEATURE_I; a_prestate: BOOLEAN; a_is_creation: BOOLEAN; a_target_type: TYPE_A)
			-- Generate feature to evaluate variable values and values of single-rooted expressions from `a_expressions'
			-- in the context of `a_feature' from `a_context_class'. Make result available in `feature_text'.
			-- `a_prestate' indicates whether the found expressions are to be evaluated before
			-- the execution of the test case. This is important because expressions such as "Result"
			-- does not make sense to be evaluated before the test case execution.
			-- `a_is_creation' indicates if `a_feature' is used as a creation procedure.
			-- `a_target_type' indicates the type of the target of `a_feature'.
		local
			l_finder: AUT_OBJECT_STATE_EXPRESSION_FINDER
		do
			should_return_reference_operand_address := True
			feature_ := a_feature
			class_ := a_context_class

				-- Collect expressions to evalute.
			create l_finder.make
			l_finder.search_for_expressions (a_context_class, a_feature, a_is_creation, a_expressions, interpreter_root_class, a_target_type)
			variables := l_finder.variables
			attributes_by_target := l_finder.attributes_by_target
			functions_by_target := l_finder.functions_by_target
			object_equality_comparisons := l_finder.object_equality_comparisons
			reference_equality_comparisons := l_finder.reference_equality_comparisons
			operand_map := l_finder.operand_map

				-- Generate body for the expression evaluation feature.
			generate_feature_text
		end

feature{NONE} -- Implementation

	should_return_reference_operand_address: BOOLEAN
			-- Should address of operands of reference types be returned?

	generate_feature_text
			-- Generate `feature_text'.
		do
			create feature_text.make (2048)
			feature_text.append (feature_name_for_byte_code_injection)
			feature_text.append_character ('%N')
			generate_locals
			generate_body
			feature_text.append ("end%N")
		end

	generate_body
			-- Generate feature body for `feature_text'.
		do
			feature_text.append ("do%N")
			feature_text.append ("create vtbl.make (5)%N")
			generate_variable_lookup
			generate_state_retrieval
			generate_object_comparison (True)
			generate_object_comparison (False)
		end

	generate_variable_lookup
			-- Generate variable lookup part of `feature_text'.
		local
			l_cursor: DS_HASH_TABLE_CURSOR [STRING, INTEGER]
			l_text: like feature_text
		do
			l_text := feature_text
			from
				l_cursor := operand_map.new_cursor
				l_cursor.start
			until
				l_cursor.after
			loop
				l_text.append (l_cursor.item)
				l_text.append (once " ?= variable_at_index (")
				l_text.append (anonymous_variable_name (l_cursor.key))
				l_text.append (once ")%N")
				l_cursor.forth
			end
		end

	generate_state_retrieval
			-- Generate state retrieval part of `feature_text'.
		local
			l_text: like feature_text
			l_variables: like variables
			l_expressions_by_target: like functions_by_target
			l_attrs_by_target: like attributes_by_target
			l_var_name: STRING
			l_var_type: TYPE_A
			l_queries: DS_HASH_SET [EPA_EXPRESSION]
			l_operand_index: INTEGER
			l_map_cursor: DS_HASH_TABLE_CURSOR [STRING, INTEGER]
			l_anony_operand_index: STRING
			l_replacements: HASH_TABLE [STRING, STRING]
			l_expr_text: STRING
			l_func_text: STRING
			l_partial_func: STRING
			l_lparan_index: INTEGER
			l_rparan_index: INTEGER
			l_dot_index: INTEGER
			l_feature: FEATURE_I
			l_feat_name: STRING
			l_target_type: TYPE_A
			l_argument_type: TYPE_A
			l_feat: FEATURE_I
		do
			l_text := feature_text
			l_variables := variables
			l_expressions_by_target := functions_by_target
			l_attrs_by_target := attributes_by_target
			l_map_cursor := operand_map.new_cursor
				-- Create variable name replacements.
			create l_replacements.make (operand_map.count)
			from
				l_map_cursor.start
			until
				l_map_cursor.after
			loop
				l_replacements.put (double_square_surrounded_integer (l_map_cursor.key), l_map_cursor.item)
				l_map_cursor.forth
			end

				-- Generate queries.
			from
				l_map_cursor.start
			until
				l_map_cursor.after
			loop
				l_var_name := l_map_cursor.item
				l_var_type := l_variables.item (l_var_name)
				l_operand_index := l_map_cursor.key
				l_anony_operand_index := anonymous_variable_name (l_operand_index)
				l_text.append (once "if not vtbl.has (")
				l_text.append (l_anony_operand_index)
				l_text.append (once ") then%N")
				l_text.append (once "vtbl.put (0, ")
				l_text.append (l_anony_operand_index)
				l_text.append (once ")%N")
				if l_var_type.is_basic then
					l_text.append (once "record_basic_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ", ")
					l_text.append (l_var_name)
					l_text.append (once ".out)%N")
				else
					l_text.append (once "if ")
					l_text.append (l_var_name)
					l_text.append (once " /= Void then%N")
					l_text.append (once "is_last_invariant_violated := False%N")
					l_text.append (once "check_invariant (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ", ")
					l_text.append (l_var_name)
					l_text.append (once ")%N")
					l_text.append (once "if is_last_invariant_violated then%N")
					l_text.append (once "record_invariant_violating_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ")%N")
					l_text.append (once "is_last_invariant_violated := False%N")
					l_text.append ("else%N")

					if should_return_reference_operand_address then
						l_text.append (once "record_evaluated_value (%"")
						l_text.append (double_square_surrounded_integer (l_map_cursor.key))
						l_text.append (once "%", ")
						l_text.append (l_var_name)
						l_text.append_character (')')
						l_text.append_character ('%N')
					end

						-- Generate attribute queries.
					l_attrs_by_target.search (l_var_name)
					if l_attrs_by_target.found then
						l_queries := l_attrs_by_target.found_item
						from
							l_queries.start
						until
							l_queries.after
						loop
							l_text.append (once "record_attribute_value (%"")
							l_expr_text := expression_text_with_replacement (l_queries.item_for_iteration, l_replacements)
							l_text.append (l_expr_text)
							l_text.append (once "%", ")
							l_text.append (l_queries.item_for_iteration.text)
							l_text.append (")%N")
							l_queries.forth
						end
					end

						-- Generate function queries.
					l_expressions_by_target.search (l_var_name)
					if l_expressions_by_target.found then
						l_queries := l_expressions_by_target.found_item
						from
							l_queries.start
						until
							l_queries.after
						loop
							l_func_text := l_queries.item_for_iteration.text.twin
							l_expr_text := expression_text_with_replacement (l_queries.item_for_iteration, l_replacements)
							l_lparan_index := l_func_text.index_of ('(', 1)
							if l_lparan_index > 0 then
									-- This is a query with argument.

									-- Get the feature of the query.
								l_dot_index := l_func_text.index_of ('.', 1)
								l_feat_name := l_func_text.substring (l_dot_index + 1, l_lparan_index - 1)
								l_feat_name.left_adjust
								l_feat_name.right_adjust
								l_target_type := l_variables.item (l_var_name)
								l_feat := l_target_type.associated_class.feature_named (l_feat_name)
									-- We ignore features with more than one argument.
								if l_feat /= Void and then l_feat.argument_count = 1 then
									l_argument_type := l_feat.arguments.first.actual_type.instantiation_in (l_target_type, l_target_type.associated_class.class_id)

										-- Generate different query recordings depending on the type of the argument.
										-- This is needed (at least for the moment) because otherwise, the agent evaluation
										-- will fail due to `valid_operands'. 21.5.2010 Jasonw
									if l_argument_type.is_integer then
										l_text.append (once "record_integer_function_value (%"")
									elseif l_argument_type.is_boolean then
										l_text.append (once "record_boolean_function_value (%"")
									else
										l_text.append (once "record_argumented_function_value (%"")
									end
									l_rparan_index := l_func_text.index_of (')', l_lparan_index + 1)
									l_text.append (l_expr_text)
									l_text.append (once "%", agent ")
									l_text.append (l_func_text.substring (1, l_lparan_index - 1))
									l_text.append (once ", ")
									l_text.append (l_func_text.substring (l_lparan_index + 1, l_rparan_index - 1))
									l_text.append (once ")%N")
								end
							else
									-- This is an argument-less query.
								l_text.append (once "record_function_value (%"")
								l_text.append (l_expr_text)
								l_text.append (once "%", agent ")
								l_text.append (l_func_text)
								l_text.append (")%N")
							end
							l_queries.forth
						end
					end
					l_text.append (once "end%N")
					l_text.append (once "else%N")
					l_text.append (once "record_void_value (")
					l_text.append (l_anony_operand_index)
					l_text.append (once ")%N")
					l_text.append (once "end%N")
				end
				l_text.append (once "end%N")
				l_map_cursor.forth
			end
		end

	generate_object_comparison (a_for_reference: BOOLEAN)
			-- Generate code to do object comparison.
		local
			l_text: like feature_text
			l_opd_map: like operands_of_feature
			l_opd_index1, l_opd_index2: INTEGER
			l_pairs: LINKED_LIST [TUPLE [expression1: EPA_EXPRESSION; expression2: EPA_EXPRESSION]]
		do
			if class_ /= Void and then feature_ /= Void then
				if a_for_reference then
					l_pairs := reference_equality_comparisons
				else
					l_pairs := object_equality_comparisons
				end
				l_opd_map := operands_of_feature (feature_)
				l_text := feature_text
				across l_pairs as l_comparisons loop
					if l_opd_map.has (l_comparisons.item.expression1.text) and then l_opd_map.has (l_comparisons.item.expression2.text) then
						l_opd_index1 := l_opd_map.item (l_comparisons.item.expression1.text)
						l_opd_index2 := l_opd_map.item (l_comparisons.item.expression2.text)
						if a_for_reference then
							l_text.append (once "record_reference_equality_comparison_value (%"")
						else
							l_text.append (once "record_object_equality_comparison_value (%"")
						end
						l_text.append (double_square_surrounded_integer (l_opd_index1))
						if a_for_reference then
							l_text.append (once " = ")
						else
							l_text.append (once " ~ ")
						end

						l_text.append (double_square_surrounded_integer (l_opd_index2))
						l_text.append_character ('%"')
						l_text.append_character (',')
						l_text.append_character (' ')
						l_text.append ({ITP_SHARED_CONSTANTS}.variable_name_prefix + l_opd_index1.out)
						l_text.append_character (',')
						l_text.append_character (' ')
						l_text.append ({ITP_SHARED_CONSTANTS}.variable_name_prefix + l_opd_index2.out)
						l_text.append_character (')')
						l_text.append_character ('%N')
					end
				end
			end
		end

	generate_locals
			-- Generate local definitions for `feature_text'.
		local
			l_variables: like variables
			l_cursor: CURSOR
			l_text: like feature_text
			l_operands: like operands_of_feature
		do
			l_text := feature_text
			l_text.append ("local%N")

			l_variables := variables
			l_cursor := l_variables.cursor
			from
				l_variables.start
			until
				l_variables.after
			loop
				l_text.append (l_variables.key_for_iteration)
				l_text.append (once ": ")

				l_text.append (output_type_name (l_variables.item_for_iteration.name))
				l_text.append_character ('%N')
				l_variables.forth
			end
			l_variables.go_to (l_cursor)

			l_text.append (once "vtbl: HASH_TABLE [INTEGER, INTEGER]%N")
		end

	functions_by_target: HASH_TABLE [DS_HASH_SET [EPA_EXPRESSION], STRING]
			-- Table of functions expressoins by their target variable
			-- Key is the variale name, value is the set of expressions of the same target.
			-- Each expression must be a qualified call, for example "v_1.exhausted".

	attributes_by_target: HASH_TABLE [DS_HASH_SET [EPA_EXPRESSION], STRING]
			-- Table of attribute expressoins by their target variable
			-- Key is the variale name, value is the set of expressions of the same target.
			-- Each expression must be a qualified call, for example "v_1.count".

	object_equality_comparisons: LINKED_LIST [TUPLE [expression1: EPA_EXPRESSION; expression2: EPA_EXPRESSION]]
			-- Object equality comparision pairs

	reference_equality_comparisons: LINKED_LIST [TUPLE [expression1: EPA_EXPRESSION; expression2: EPA_EXPRESSION]]
			-- Reference equality comparision pairs

	variables: HASH_TABLE [TYPE_A, STRING]
			-- Table of variables found by last `search_for_feature'
			-- Key is variable name, value is the resolved type of that variable

	operand_map: DS_HASH_TABLE [STRING, INTEGER]
			-- Operand map for `variables'
			-- Key is 0-based operand index, key is variable name

	variable_name (a_index: INTEGER): STRING
			-- Name of variable with `a_index'.
		do
			create Result.make (5)
			Result.append ({ITP_SHARED_CONSTANTS}.variable_name_prefix)
			Result.append (a_index.out)
		end

	remove_non_integer_expressions
			-- Remove non-integer expressions in `functions_by_target'.
		local
			l_tbl: like functions_by_target
			l_cursor: CURSOR
			l_set: DS_HASH_SET [EPA_EXPRESSION]
			l_new_set: DS_HASH_SET [EPA_EXPRESSION]
		do
			l_tbl := functions_by_target
			l_cursor := l_tbl.cursor
			from
				l_tbl.start
			until
				l_tbl.after
			loop
				l_set := l_tbl.item_for_iteration
				create l_new_set.make (l_set.count)
				l_new_set.set_equality_tester (expression_equality_tester)
				l_new_set.do_if (agent l_new_set.force_last, agent (a_expr: EPA_EXPRESSION): BOOLEAN do Result := a_expr.is_integer end)
				l_tbl.put (l_new_set, l_tbl.key_for_iteration)
				l_tbl.forth
			end
			l_tbl.go_to (l_cursor)
		end

	collect_argumentless_queries (a_funcs_by_target: like functions_by_target)
			-- Collect argument-less queries from `a_funcs_by_target' and set them into `functions_by_target'.
		local
			l_funcs_by_target: like functions_by_target
			l_funcs: DS_HASH_SET [EPA_EXPRESSION]
			l_new_funcs: DS_HASH_SET [EPA_EXPRESSION]
		do
			create functions_by_target.make (a_funcs_by_target.count)
			l_funcs_by_target := functions_by_target
			l_funcs_by_target.compare_objects
			from
				a_funcs_by_target.start
			until
				a_funcs_by_target.after
			loop
				l_funcs := a_funcs_by_target.item_for_iteration
				create l_new_funcs.make (l_funcs.count)
				l_new_funcs.set_equality_tester (expression_equality_tester)
				from
					l_funcs.start
				until
					l_funcs.after
				loop
					if not l_funcs.item_for_iteration.text.has ('(') then
						l_new_funcs.force_last (l_funcs.item_for_iteration)
					end
					l_funcs.forth
				end
				l_funcs_by_target.force (l_new_funcs, a_funcs_by_target.key_for_iteration)
				a_funcs_by_target.forth
			end
		end

note
	copyright: "Copyright (c) 1984-2011, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

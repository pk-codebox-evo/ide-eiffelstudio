note
	description: "Summary description for {AUT_LINEAR_CONSTRAIN_SOLVABLE_VISITOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AUT_PRECONDITION_ANALYZER

inherit
	AST_ITERATOR
		redefine
			process_id_as,
			process_access_feat_as,
			process_nested_as,
			process_keyword_as,
			process_symbol_as,
			process_bool_as,
			process_char_as,
			process_typed_char_as,
			process_void_as,
			process_string_as,
			process_verbatim_string_as,
			process_current_as,
			process_integer_as,
			process_real_as,
			process_unary_as,
			process_binary_as,
			process_bracket_as,
			process_object_test_as,
			process_class_type_as,
			process_static_access_as,
			process_symbol_stub_as,
			process_like_id_as,
			process_like_cur_as,
			process_keyword_stub_as
		end

	EPA_ARGUMENTLESS_PRIMITIVE_FEATURE_FINDER

	SHARED_WORKBENCH

	SHARED_SERVER

	ERL_G_TYPE_ROUTINES

	AUT_SHARED_TYPE_FORMATTER

	SHARED_ERROR_HANDLER

	AUT_SHARED_PREDICATE_FACTORY

	EPA_UTILITY

create
	make

feature{NONE} -- Initialization

	make is
			-- Initialize.
		do
			create {DS_HASH_TABLE [STRING, INTEGER]} constrained_variables.make (2)
			create integer_operands.make (2)
			create operands.make (2)
			create constraining_queries.make (2)
			create accessed_variables.make (2)
			create last_predicates.make
			create last_predicate_access_patterns.make
			create type_checker

			integer_operands.set_key_equality_tester (string_equal_tester)
			operands.set_key_equality_tester (string_equal_tester)
			constraining_queries.set_equality_tester (string_equal_tester)
		end

feature -- Access

	last_predicates: DS_LINKED_LIST [AUT_PREDICATE]
			-- Predicates generated by the last call to
			-- `generate_precondition_predicates'.

	last_predicate_access_patterns: DS_LINKED_LIST [AUT_PREDICATE_ACCESS_PATTERN]
			-- Last predicate access patterns generated by
			-- the last call to `generate_precondition_predicates'.

feature -- Basic operation

	generate_precondition_predicates (a_feature: AUT_FEATURE_OF_TYPE) is
			-- Generate predicates from preconditions of `a_feature'.
			-- Store result in `last_predicates' and
			-- `last_predicate_access_patterns'.
		local
			l_precondition_extractor: EPA_CONTRACT_EXTRACTOR
			l_asserts: LINKED_LIST [EPA_EXPRESSION]
			l_assertion: EPA_EXPRESSION
			l_solvables: DS_LINKED_LIST [AUT_PREDICATE]
			l_unsolvables: DS_LINKED_LIST [AUT_PREDICATE]
			l_not_void_pred: like target_not_void_predicate_and_access_pattern
			l_assert_text: STRING
		do
			last_predicates.wipe_out
			last_predicate_access_patterns.wipe_out
			current_feature := a_feature

				-- Generate predicates for each of the precondition assertions.
			create l_solvables.make
			create l_unsolvables.make
			from
				create l_precondition_extractor
				l_asserts := l_precondition_extractor.precondition_of_feature (a_feature.feature_, a_feature.associated_class)
				l_asserts.start
			until
				l_asserts.after
			loop
				l_assertion := l_asserts.item_for_iteration

					-- We ignore "require else", type expressions such as "{G}" for the moment.
				l_assert_text := l_assertion.text
				fixme ("Support require else, type expressions in the future. 2009.6.11 Jasonw")
				if
					not l_assertion.is_require_else and then
					not l_assert_text.has ('{') and then
					not l_assert_text.has_substring (once "attached")
				then
					current_break_point_slot := l_asserts.index
					check_assertion (l_assertion, a_feature)
				end
				l_asserts.forth
			end

			if
				last_predicates.there_exists (agent is_linear_solvable_predicate) and then
				(not last_predicate_access_patterns.there_exists (agent has_target_operand)) and then
				last_predicates.there_exists (agent has_constraining_query)
			then
				l_not_void_pred := target_not_void_predicate_and_access_pattern (current_feature.type)
				last_predicates.force_last (l_not_void_pred.predicate)
				last_predicate_access_patterns.force_last (l_not_void_pred.access_pattern)
			end
		end

feature{NONE} -- Process

	process_id_as (l_as: ID_AS)
		do
			check_access_name (l_as.name.as_lower)
		end

	process_access_feat_as (l_as: ACCESS_FEAT_AS)
		local
			l_name: STRING
			l_parameters: EIFFEL_LIST [EXPR_AS]
		do
			if l_as.internal_parameters /= Void then
					-- If there is a feature call with arguments, then
					-- we consider the current assertion to be non linearly solvable.
				is_linear_solvable := False
			end

			check_access_name (l_as.access_name.as_lower)

			if l_as.internal_parameters /= Void then
				text.append (" (")
				from
					l_parameters := l_as.internal_parameters.parameters.twin
					l_parameters.start
				until
					l_parameters.after
				loop
					nested_list.force_last (create {DS_LINKED_STACK [BOOLEAN]}.make)
					safe_process (l_parameters.item_for_iteration)
					if l_parameters.index < l_parameters.count then
						text.append (", ")
					end
					l_parameters.forth
					nested_list.remove_last
				end
				text.append_character (')')
			end
		end

	process_nested_as (l_as: NESTED_AS)
		local
			l_stack: DS_LINKED_STACK [BOOLEAN]
		do
			is_linear_solvable := False

			l_stack := nested_list.last
			l_stack.force (True)
			safe_process (l_as.target)
			l_stack.replace (False)
			text.append_character ('.')
			safe_process (l_as.message)
			l_stack.remove
		end

	process_keyword_as (l_as: KEYWORD_AS)
			-- Process `l_as'.
		do
			text.append_character (' ')
			text.append_string (text_from_ast (l_as))
			text.append_character (' ')
		end

	process_keyword_stub_as (l_as: KEYWORD_STUB_AS)
			-- Process `l_as'.
		do
			text.append_string (text_from_ast (l_as))
		end

	process_symbol_as (l_as: SYMBOL_AS)
			-- Process `l_as'.
		do
			text.append_string (text_from_ast (l_as))
		end

	process_symbol_stub_as (l_as: SYMBOL_STUB_AS)
			-- Process `l_as'.
		do
			text.append_string (l_as.literal_text (Void))
		end

	process_bool_as (l_as: BOOL_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_char_as (l_as: CHAR_AS)
		do
			fixme ("Have problem of output precondition for HIGH_BUILDER.build_dollar_p. The index in LEAF_AS is not correct.")
--			text.append_string (text_of_ast (l_as))
			text.append_character ('%'')
			text.append (l_as.value.to_character_8.out)
			text.append_character ('%'')
		end

	process_typed_char_as (l_as: TYPED_CHAR_AS)
			-- Process `l_as'.
		do
			text.append_string (text_from_ast (l_as))
		end

	process_void_as (l_as: VOID_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_string_as (l_as: STRING_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_verbatim_string_as (l_as: VERBATIM_STRING_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_current_as (l_as: CURRENT_AS)
		local
			l_text: STRING
		do
			l_text := place_holder (0)
			text.append_string (l_text)
			accessed_variables.force_last (current_feature.type, 0)
		end

	process_integer_as (l_as: INTEGER_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_real_as (l_as: REAL_AS)
		do
			text.append_string (text_from_ast (l_as))
		end

	process_unary_as (l_as: UNARY_AS)
		do
			text.append (l_as.operator_name.as_lower)
			text.append_character (' ')
			l_as.expr.process (Current)
		end

	process_binary_as (l_as: BINARY_AS)
		do
			l_as.left.process (Current)
			text.append_character (' ')
			text.append (l_as.op_name.name)
			text.append_character (' ')
			l_as.right.process (Current)
		end

	process_bracket_as (l_as: BRACKET_AS)
		do
			l_as.target.process (Current)
			text.append_character ('[')
			l_as.operands.process (Current)
			text.append_character (']')
		end

	process_object_test_as (l_as: OBJECT_TEST_AS)
		do
			if l_as.is_attached_keyword then
				text.append (ti_attached_keyword)
				text.append_character (' ')
				if l_as.type /= Void then
					safe_process (l_as.type)
					text.append_character (' ')
				end
				l_as.expression.process (Current)
				text.append_character (' ')
				text.append (ti_as_keyword)
				text.append_character (' ')
				safe_process (l_as.name)
			else
				l_as.name.process (Current)
				l_as.type.process (Current)
				l_as.expression.process (Current)
			end
		end

	process_class_type_as (l_as: CLASS_TYPE_AS)
		do
			text.append (ti_l_curly)
			text.append (full_type_name (text_from_ast (l_as.class_name), current_assertion.written_class))
			text.append (ti_r_curly)
		end

	process_static_access_as (l_as: STATIC_ACCESS_AS)
		local
			l_stack: DS_LINKED_STACK [BOOLEAN]
		do
			l_as.class_type.process (Current)
			l_stack := nested_list.last
			l_stack.force (False)
			text.append (ti_dot)
			process_access_feat_as (l_as)
			l_stack.remove
		end

	process_like_id_as (l_as: LIKE_ID_AS)
		do
			process_anchored_type (l_as)
		end

	process_anchored_type (l_as: TYPE_AS) is
			-- Process `l_as'.
		local
			l_type: TYPE_A
			l_type2: TYPE_A
			l_like_feat: LIKE_FEATURE
			l_type_checker: TYPE_A_CHECKER
		do
				-- Resolve type in `l_as'.
			l_type := type_a_generator.evaluate_type_if_possible (l_as, current_assertion.written_class)
			l_type_checker := type_checker
			l_type_checker.init_for_checking (current_feature.feature_, current_written_class, Void, error_handler)
			l_type2 := l_type_checker.check_and_solved (l_type, l_as).actual_type.deep_actual_type

			text.append (ti_l_curly)
			text.append (type_name_with_context (l_type2, current_assertion.written_class, current_feature.feature_))
			text.append (ti_r_curly)
		end

	process_like_cur_as (l_as: LIKE_CUR_AS)
		do
			process_anchored_type (l_as)
		end

	nested_list: DS_LINKED_LIST [DS_LINKED_STACK [BOOLEAN]]
			-- List for nested structures

	check_access_name (a_name: STRING) is
			-- Check if access identifier is of type integer.
			-- `a_name' is assumed to be in lower case.
		local
			l_feat: FEATURE_I
			l_text: STRING
			l_operand_index: INTEGER
			i: INTEGER
			l_type: TYPE_A
		do
				-- Check if current assertion is linearly constraint solvable.
			if is_linear_solvable then
				if integer_operands.has (a_name) then
					is_integer_operand_mentioned := True
					constrained_variables.force_last (a_name, integer_operands.item (a_name))
				elseif operands.has (a_name) then
					is_linear_solvable := False
				else
					l_feat := final_feature (a_name, current_assertion.written_class, current_feature.type.associated_class)
					is_linear_solvable := l_feat /= Void and then l_feat.argument_count = 0 and then l_feat.type.is_integer
					if is_linear_solvable then
						constraining_queries.force_last (l_feat.feature_name.as_lower)
					end
				end
			end

				-- Check which variable is accessed, either the target object, or an argument.
			if nested_list.last.is_empty or else (nested_list.last.count = 1 and then nested_list.last.item) then
				l_operand_index := 0
				if operands.has (a_name) then
					l_operand_index := operands.item (a_name)
				else
					l_operand_index := operand_index (a_name, current_assertion, current_feature.feature_)
				end

				if l_operand_index > 0 then
					l_type := current_feature.feature_.arguments.i_th (l_operand_index).instantiation_in (current_feature.type, current_feature.associated_class.class_id)
					check not l_type.actual_type.is_like end
					accessed_variables.force_last (l_type.actual_type, l_operand_index)
					text.append (place_holder (l_operand_index))

						-- The accessed entity is used as the target of a nested message.
					if not nested_list.last.is_empty then
						current_targets.force_last (l_operand_index)
					end
				else
					l_feat := final_feature (a_name, current_assertion.written_class, current_feature.type.associated_class)
					if l_feat /= Void then
						accessed_variables.force_last (current_feature.type, 0)
						current_targets.force_last (0)
						text.append (place_holder (0))
						text.append_character ('.')
						text.append (l_feat.feature_name)
					else
						text.append (a_name)
					end
				end
			else
				text.append (a_name)
			end
		end

	operand_index (a_name: STRING; a_assertion: EPA_EXPRESSION; a_feature: FEATURE_I): INTEGER is
			-- 0-based operand index of an operand with `a_name' in `a_assertion' of `a_feature'.
			-- Operand index here can only be larger than 0 because target is not included, so
			-- if current feature returns 0, it means that `a_name' is not an argument name.
		require
			a_name_attached: a_name /= Void
			not_a_name_is_empty: not a_name.is_empty
			a_assertion_attached: a_assertion /= Void
			a_feature_attached: a_feature /= Void
		local
			l_feature: FEATURE_I
			i: INTEGER
			l_operand_count: INTEGER
		do
			l_feature := a_assertion.written_class.feature_of_rout_id_set (a_feature.rout_id_set)
			from
				l_operand_count := l_feature.argument_count
				i := 1
			until
				i > l_operand_count or Result > 0
			loop
				if l_feature.arguments.item_name (i).is_case_insensitive_equal (a_name) then
					Result := i
				end
				i := i + 1
			end
		ensure
			good_result: Result >= 0 and then Result <= a_feature.argument_count
		end

feature{NONE} -- Implementation

	current_assertion: detachable EPA_EXPRESSION
			-- Assertion that is currently processed

	current_feature: detachable AUT_FEATURE_OF_TYPE
			-- Feature where `current_assertion' is written

	current_context_class: CLASS_C is
			-- Context class where `current_feature' is viewed
		do
			Result := current_feature.associated_class
		end

	current_written_class: CLASS_C is
			-- Class where `current_feature' is written
		do
			Result := current_feature.feature_.written_class
		end

	current_targets: DS_HASH_SET [INTEGER]
			-- Indexes of predicate arguments (1-based) that are used as target
			-- of some feature call

	current_break_point_slot: INTEGER
			-- Current break point slot

	integer_operands: DS_HASH_TABLE [INTEGER, STRING];
			-- Table of integer operands in the feature
			-- where currently processed assertion is
			-- written.
			-- [operand index, operand name]
			-- Operand index is 0-based, but indexes here can
			-- only be larger than 0, because we integer object as target
			-- is not supported.

	operands: DS_HASH_TABLE [INTEGER, STRING]
			-- Set of argument names for `current_feature'
			-- [operand index, operand name]
			-- Operand index is 0-based, but indexes here can
			-- only be larger than 0, because target is not included here.

	is_integer_operand_mentioned: BOOLEAN
			-- Is some integer operand mentioned in `current_assertion?
			-- An assertion needs linearly constraint solving only when
			-- its integer operands are mentioned.

	find_integer_operands is
			-- Find arguments of integer type in the feature where `current_assertion'
			-- is written and put them into `integer_operands'.
		require
			current_assertion_attached: current_assertion /= Void
			current_feature_attached: current_feature /= Void
		local
			l_feature: FEATURE_I
			l_arg_count: INTEGER
			i: INTEGER
			l_arg_name: STRING
		do
			l_feature := current_feature.feature_
			l_arg_count := l_feature.argument_count
			if l_arg_count > 0 then
				from
					i := 1
				until
					i > l_arg_count
				loop
					l_arg_name := l_feature.arguments.item_name (i).as_lower
					operands.force_last (i, l_arg_name)
					if l_feature.arguments.i_th (i).is_integer then
						integer_operands.force_last (i, l_arg_name)
					end
					i := i + 1
				end
			end
		ensure
			integer_operands_attached: integer_operands /= Void
			integer_operands_valid: integer_operands.for_all (
				agent (a_index: INTEGER): BOOLEAN
					do
						Result := a_index > 0 and then a_index <= current_feature.argument_count
					end (?)
				)
		end

--	is_top_level_nested_as (a_nested_as: NESTED_AS): BOOLEAN is
--			-- Is `a_nested_as' is top level structure?
--			-- Top level means that `a_nested_as' is not a message (see NESTED_AS)
--			-- of another nested structure.
--		do
--			if last_processed_nested_as /= Void then
--				Result := last_processed_nested_as.message /= a_nested_as
--			else
--				Result := True
--			end
--		end

--	last_processed_nested_as: detachable NESTED_AS
--			-- Last process nested structure

	place_holder (a_index: INTEGER): STRING is
			-- Place holder for `a_index'-th variable accessed in
			-- currently processed assertion
		do
			create Result.make (3)
			Result.append_character ('$')
			Result.append_integer(a_index)
			Result.append_character ('$')
		end

	replace_text (a_call_index: INTEGER; a_predicate_index: INTEGER) is
			--
		local
			l_call_str: STRING
			l_pred_str: STRING
		do
			create l_call_str.make (3)
			l_call_str.append_character ('$')
			l_call_str.append (a_call_index.out)
			l_call_str.append_character ('$')

			create l_pred_str.make (3)
			l_pred_str.append_character ('{')
			l_pred_str.append (a_predicate_index.out)
			l_pred_str.append_character ('}')

			text.replace_substring_all (l_call_str, l_pred_str)
		end

	analyze_predicate is
			-- Analyze the last processed assertion
			-- and generate a predicate out of it.
			-- Store result in `last_predicates' and
			-- `last_predicate_access_patterns'.
		local
			l_sorted_args: DS_LIST [INTEGER]
			l_pred_types: DS_LINKED_LIST [TYPE_A]
			l_access_pattern: DS_HASH_TABLE [INTEGER, INTEGER]
			l_predicate_of_feat: AUT_PREDICATE_ACCESS_PATTERN
			l_predicate: AUT_PREDICATE
			l_constrained_args: DS_HASH_SET [INTEGER]
			i: INTEGER
			l_args_as_target: DS_HASH_SET [INTEGER]
		do
				-- Sorted indexes of entity objects that are accessed in current analyzed
				-- AST node. index 0 means the target object, index 1 means the first argument,
				-- and so on.
			l_sorted_args := sorted_keys (accessed_variables)

				-- Decide argument types for the predicate.
			create l_pred_types.make
			create l_args_as_target.make (current_targets.count)
			from
				i := 1
				l_sorted_args.start
			until
				l_sorted_args.after
			loop
				l_pred_types.force_last (accessed_variables.item (l_sorted_args.item_for_iteration))
				if current_targets.has (l_sorted_args.item_for_iteration) then
					l_args_as_target.force_last (i)
				end
				i := i + 1
				l_sorted_args.forth
			end

				-- Update `text' with correct argument position for the predicate
				-- and generate access pattern.
			create l_access_pattern.make (l_sorted_args.count)
			from
				l_sorted_args.start
				i := 1
			until
				l_sorted_args.after
			loop
					-- Although the the indexes of `l_sorted_args' is 0-based,
					-- the indexes of the predicate is 1-based.
				replace_text (l_sorted_args.item_for_iteration, i)
				l_access_pattern.put (l_sorted_args.item_for_iteration, i)
				i := i + 1
				l_sorted_args.forth
			end
			check
				l_access_pattern.for_all_with_key (
					agent (a_item, a_key: INTEGER): BOOLEAN
						do
							Result := a_item >= 0 and then a_item <= current_feature.argument_count and then a_key > 0
						end)
					end

				-- Generate predicate.
			if is_linear_solvable then
				create l_constrained_args.make (3)
				from
					i := 1
					l_sorted_args.start
				until
					l_sorted_args.after
				loop
					if constrained_variables.has (l_sorted_args.item_for_iteration) then
						l_constrained_args.force_last (i)
					end
					i := i + 1
					l_sorted_args.forth
				end

				l_predicate := predicate_factory.linear_solvable_predicate (
					l_pred_types,
					text,
					current_feature.associated_class,
					l_constrained_args,
					constraining_queries)
			else
				l_predicate := predicate_factory.normal_predicate (
					l_pred_types,
					text,
					current_feature.associated_class)
			end

				-- We ignore precontions in creation procedures which contains unqualified calls.
			if l_predicate /= Void then
				if not (is_exported_creator (current_feature.feature_, current_context_class.actual_type) and then l_access_pattern.has_item (0)) then
					create l_predicate_of_feat.make (current_feature, l_predicate, l_access_pattern, current_assertion)
					l_predicate_of_feat.set_break_point_slot (current_break_point_slot)
					last_predicates.force_last (l_predicate)
					last_predicate_access_patterns.force_last (l_predicate_of_feat)
					l_predicate.set_arguments_as_target (l_args_as_target)
				end
			end
		end

	check_assertion (a_assertion: EPA_EXPRESSION; a_context_feature: AUT_FEATURE_OF_TYPE) is
			-- Analyze `a_assertion' from `a_context_feature'.
			-- If the constaints in `a_assertion' which is written in `a_context_feature'
			-- is linear solvable, set `is_linear_solvable' to True and put integer arguments
			-- which are linearly constrained into `constrained_variables', and put queries that
			-- contrains `constrained_variables' into `constraining_queries'.
			-- Also, put every accessed variables into `accessed_variables'.
		do
			is_linear_solvable := True
			is_integer_operand_mentioned := False
			constrained_variables.wipe_out
			operands.wipe_out
			integer_operands.wipe_out
			accessed_variables.wipe_out
			create nested_list.make
			create current_targets.make (2)
			nested_list.force_last (create {DS_LINKED_STACK [BOOLEAN]}.make)
			create text.make (64)

				-- Find integer argument in `a_context_feature'.
			current_assertion := a_assertion
			current_feature := a_context_feature
			find_integer_operands
			current_assertion.ast.process (Current)
			is_linear_solvable := is_linear_solvable and then is_integer_operand_mentioned

				-- Analyze just created predicate.
			analyze_predicate
		end

feature{NONE} -- Equality tester

	is_string_equal (a_str, b_str: STRING): BOOLEAN is
			-- Is `a_str' equal to `b_str'?
		do
			Result := a_str ~ b_str
		ensure
			good_result: Result = (a_str ~ b_str)
		end

feature{NONE} -- Implmentation

	is_linear_solvable: BOOLEAN
			-- Is linear constraint in the last process
			-- assertion solvable?

	string_equal_tester: AGENT_BASED_EQUALITY_TESTER [STRING] is
			-- Tester to decide if two strings are equal
		do
			create Result.make (agent is_string_equal)
		end

	constrained_variables: DS_HASH_TABLE [STRING, INTEGER]
			-- Name of the arguments in the last processed assertion
			-- that are constrained by assertions
			-- [Name, argument index], key is the name of the argument
			-- value is the 1-based index of the argument.
			-- The first argument has index 1.
			-- Note: Result has effect only if `is_linear_solvable' is True

	constraining_queries: DS_HASH_SET [STRING]
			-- Set of name of queries which constains `constrained_variables'
			-- Note: Result has effect only if `is_linear_solvable' is True

	accessed_variables: DS_HASH_TABLE [TYPE_A, INTEGER]
			-- Accessed variables in the last processed assertion
			-- variables is either the target object or an argument.
			-- The value is the type of the varaible,
			-- the key is its operand index. The index is 0-based,
			-- the 0-th variable is the target, the 1-th variable is
			-- the first argument, and so on.

	text: STRING
			-- Text of the last process assertion.

	type_checker: TYPE_A_CHECKER
			-- Type checker			

	sorted_keys (a_table: DS_HASH_TABLE [ANY, INTEGER]): DS_LIST [INTEGER] is
			-- ascendingly sorted list of keys in `a_table'
		local
			l_sorter: DS_QUICK_SORTER [INTEGER]
			l_keys: DS_ARRAYED_LIST [INTEGER]
		do
			create l_keys.make (a_table.keys.count)
			a_table.keys.do_all (agent l_keys.force_last)
			create l_sorter.make (create {AGENT_BASED_EQUALITY_TESTER [INTEGER]}.make (agent (a,b: INTEGER): BOOLEAN do Result := a < b end))
			l_sorter.sort (l_keys)
			Result := l_keys
		end

	target_not_void_predicate_and_access_pattern (a_type: TYPE_A): TUPLE [predicate: AUT_PREDICATE; access_pattern: AUT_PREDICATE_ACCESS_PATTERN] is
			-- "not_void" predicate for `a_type' and its access pattern.
		require
			a_type_attached: a_type /= Void
		local
			l_types: DS_LINKED_LIST [TYPE_A]
			l_predicate: AUT_PREDICATE
			l_access_pattern: AUT_PREDICATE_ACCESS_PATTERN
			l_pattern_table: DS_HASH_TABLE [INTEGER, INTEGER]
			l_assertion: EPA_AST_EXPRESSION
			l_target: ID_AS
			l_void: VOID_AS
			l_ne_binary: BIN_NE_AS
			l_ne_operator: SYMBOL_AS
		do
			create l_types.make
			l_types.force_last (a_type)
			l_predicate := predicate_factory.normal_predicate (l_types, "{1} /= Void", a_type.associated_class)
			create l_pattern_table.make (1)
			l_pattern_table.put_last (0, 1)

			create l_void.make_with_location (0, 0, 0, 0)
			create l_target.initialize ("a__target")
			create l_ne_binary.initialize (l_target, l_void, l_ne_operator)
			create l_ne_operator.make ({EIFFEL_TOKENS}.TE_NE, 0, 0, 0, 0)
			create l_assertion.make (l_ne_binary, current_context_class, current_written_class)
			create l_access_pattern.make (current_feature, l_predicate, l_pattern_table, l_assertion)

			Result := [l_predicate, l_access_pattern]
		ensure
			result_attached: Result /= Void
		end

feature -- Status report

	is_linear_solvable_predicate (a_predicate: AUT_PREDICATE): BOOLEAN is
			-- Is `a_predicate' linearly solvable?
		require
			a_predicate_attached: a_predicate /= Void
		do
			Result := a_predicate.is_linear_solvable
		ensure
			good_result: Result = a_predicate.is_linear_solvable
		end

	has_target_operand (a_access_pattern: AUT_PREDICATE_ACCESS_PATTERN): BOOLEAN is
			-- Does `a_access_pattern' contain a normal predicate and then
			-- access the target operand (the 0-th) object of a feature call?
		require
			a_access_pattern_attached: a_access_pattern /= Void
		do
			if attached {AUT_NORMAL_PREDICATE} a_access_pattern.predicate as normal_pred then
				Result := a_access_pattern.access_pattern.has_item (0)
			end
		end

	has_constraining_query (a_predicate: AUT_PREDICATE): BOOLEAN is
			-- Is `a_predicate' a linear solvable predicate containing
			-- constraining queries?
		require
			a_predicate_attached: a_predicate /= Void
		do
			if attached {AUT_LINEAR_SOLVABLE_PREDICATE} a_predicate as linear_pred then
				Result := not linear_pred.constraining_queries.is_empty
			end
		end

note
	copyright: "Copyright (c) 1984-2010, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

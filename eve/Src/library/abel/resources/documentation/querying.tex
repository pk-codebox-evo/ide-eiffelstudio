\section{Advanced Queries}
\label{sec:query}

\subsection{The query mechanism}

As you already know, queries to the database are done by creating a new OBJECT\_QUERY and letting it be executed by the CRUD\_EXECUTOR.
The generic parameter of the OBJECT\_QUERY instance determines the type of the objects that will be returned, including every conforming types (e.g. descendants of that class).

%\subsection{Handling references}

ABEL will by default load an object completely, that means all objects that can be reached by following references will be loaded as well. 
There is however a mechanism in ABEL that ensures that an object will not be loaded twice in a single query (see also ~\ref{sec:references}).


\subsection{Criteria}

You can filter your query results by setting criteria in the query object, using the OBJECT\_QUERY.set\_criteria feature.
There are two types: predefined and agent criteria.

\subsubsection{Predefined Criteria}
Predefined criteria take an attribute name, an operator and a value. 
You can only use attributes that are of a basic type, like strings or numbers.
During retrieval, they check the object's own value against the value set in the criterion, and filter objects that don't satisfy the criterion.

The supported operators are pretty self-describing (see Listing 4), except for the ``like''-operator. 
That does pattern-matching on strings.
You can give the criterion a pattern as a value, which can contain the wildcard characters '*' and '?'.
The asterisk stands for any number (including zero) of undefined characters, and the question mark means exactly one undefined character.

Not every type of attribute supports every operator. Valid combinations for each type are:

 \begin{itemize}
  \item Strings: =, like
  \item Any numeric value: $=, <, <=, >, >=$
  \item Booleans: =
 \end{itemize}

Note that for performance reasons it is usually better to use predefined criteria, because they can be compiled to SQL and therefore the result will be filtered in the database.

\subsubsection{Agent Criteria}

An agent criterion will filter the objects according to the result of an agent applied to them.

The criterion is initialized with an agent of type PREDICATE [ANY, TUPLE [ANY]]. 
There should be either an open target or a single open argument, and the type of the objects in the query result should conform to the agent's open operand.


\subsubsection{Creating criteria objects}

The criteria instances are best created using the CRITERION\_FACTORY class.

The main functions to the class are the following: 

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={The CRITERION\_FACTORY interface}, label={lst:factory_interface}]
class
	PS_CRITERION_FACTORY
create
	default_create

feature -- Creating a criterion

	new alias "[]" (tuple: TUPLE [ANY]): PS_CRITERION
			-- This function creates a new criterion according to the tuple in the argument.
			-- The tuple should either contain a single PREDICATE or three values of the form [STRING, STRING, ANY]



	new_agent (a_predicate: PREDICATE [ANY, TUPLE [ANY]]): PS_CRITERION
			-- creates a criterion with an agent

	new_predefined (object_attribute: STRING; operator: STRING; value: ANY): PS_CRITERION
			-- creates a predefined criterion

feature -- Operators

	equals: STRING = "="

	greater: STRING = ">"

	greater_equal: STRING = ">="

	less: STRING = "<"

	less_equal: STRING = "<="

	like_string: STRING = "like"

end
\end{lstlisting}

To create a new criterion, you basically have two possibilities.
The first one is the more traditional one, using CRITERION\_FACTORY.new\_agent or CRITERION\_FACTORY.new\_predefined.

The second uses some syntactic sugar:
The criterion is created with two brackets after the factory object, of which one is an overloaded operator and the other a tuple definition.
It can be used for both types of criteria, and it is up to you to choose which approach you like best.

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, , label={lst:factory_usage}]

	create_criteria_traditional : PS_CRITERION
		-- Create a new criteria using the traditional approach
		do

			-- for predefined criteria
			Result:= 
				factory.new_predefined ("age", factory.less, 5)

			-- for agent criteria
			Result := 
				factory.new_agent (agent age_less_than (?, 5))
		end


	create_criteria_double_bracket : PS_CRITERION
		-- Create a new criteria using the double bracket syntax
		do

			-- for predefined criteria
			Result:= factory[["age", factory.less, 5]]

			-- for agent criteria
			Result := factory[[agent age_less_than (?, 5)]]
		end			


	age_less_than (person: PERSON; age: INTEGER): BOOLEAN
		-- Just a little example agent
		do
			Result:= person.age < age
		end

\end{lstlisting}



\subsubsection{Combining criteria}

If you want to set multiple criterion objects, you can combine them using the standard Eiffel keywords. 
For example, if you want to search for a person called ``Albo Bitossi'' with age $\ne$ 20, you can just create a criterion object for each of the constraints and combine them:  

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:search_albo_bitossi}]

	search_albo_bitossi : PS_CRITERION
		-- Create a criterion object that searches for an Albo Bitossi which is not 20 years old
		local
			first_name_criterion:PS_CRITERION
			last_name_criterion: PS_CRITERION
			age_criterion: PS_CRITERION
		do
			first_name_criterion:= 
				factory[[ "first_name", factory.equals, "Albo" ]]

			last_name_criterion := 
				factory[[ "last_name", factory.equals, "Bitossi" ]]

			age_criterion := 
				factory[[ "age", factory.equals, 20 ]]
			
			Result := first_name_criterion and last_name_criterion and not age_criterion

			-- or a bit shorter
			Result := factory[[ "first_name", "=", "Albo" ]] 
				and factory[[ "last_name", "=", "Bitossi" ]] 
				and not factory[[ "age", "=", 20 ]]
		end
\end{lstlisting}

ABEL supports the three standard logical operators AND, OR and NOT. 
Their precedence is the same as in Eiffel, which means that NOT is stronger than AND, which in turn is stronger than OR.


\subsection{Deletion queries}
\label{subsection:deletion_query}


As already mentioned previously, there is another way to perform a delete in the repository.
When you call CRUD\_EXECUTOR.execute\_deletion\_query, ABEL will delete all objects in the database that would have been retrieved by executing the query normally.
You can look at the following example and compare it with its variation in the delete section ~\ref{subsection:simple_delete}

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:deletion_query}]
	delete_person (name:STRING)
		-- Delete `name' using a deletion query.
		local
			deletion_query: PS_OBJECT_QUERY[PERSON]
			criterion:PS_PREDEFINED_CRITERION
		do
			create deletion_query.make
			create criterion.make ("last_name", "=", name)
			deletion_query.set_criterion (criterion)
			executor.execute_deletion_query (deletion_query)
		end
\end{lstlisting}

It depends on the situation if you want to use deletion queries or a direct delete command. 
Usually, a direct command is better if you already have the object in memory, whereas deletion queries are nicer to use if the object is not yet loaded from the database.

\subsection{Tuple queries}

So far, we've only looked at queries that return objects. However, in ABEL there is a second option to query data which returns tuples as a result.
Consider an example where you just want to have a list of all first an last names of persons in the database. 
To load every object of type PERSON might lead to a very bad performance, especially if there is a big object graph attached to each person object.

To solve this problem, you can instead send a TUPLE\_QUERY to the executor. 
The result is an iterator over a list of tuples in which the attributes of an object are collected. The order of these attributes is the one defined in TUPLE\_QUERY.projection

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:tuple_query_simple}]
	print_all_last_names
		-- Print the last name of all PERSON objects in the database
		local
			query: PS_TUPLE_QUERY[PERSON]
			last_name_index:INTEGER
			single_result: TUPLE
		do
			create query.make
			-- Find out at which position in the tuple the last_name is returned
			last_name_index:= find_index_of_attribute("last_name")

			from
				executor.execute_query (query)
			until
				query.result_cursor.after
			loop
				single_result:= query.result_cursor.item
				print (single_result [last_name_index] )
			end			
		end
\end{lstlisting}

\subsubsection{Tuple queries and projections}
By default, a TUPLE\_QUERY will only return attributes of an object that are of a basic type, so no references are followed during a retrieve.
You can change this default by calling TUPLE\_QUERY.set\_projection, which expects a list of names of the attributes you would like to have.
If you include an attribute name whose type is not a basic one, ABEL will actually retrieve and build the attribute object, and not just another tuple.

\subsubsection{Tuple queries and criteria}
As you can't use agents on tuples (as they expect an object and not a tuple), you are restricted to use predefined criteria in tuple queries. You can still combine them as usual.
It is ok to include a criterion on an attribute that is not present in the projection list - these attributes will be loaded internally to check if the object satisfies the criterion, but then they are discarded for the actual result.

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:tuple_projection_selection}]
	print_last_names_of_20_year_old
		-- Print the last name of all PERSON objects with age=20
		local
			query: PS_TUPLE_QUERY[PERSON]
		do
			create query.make

			-- Only return the last_name of persons
			query.set_projection (<<"last_name">>)

			-- Only return persons with age=20
			query.set_criterion (factory [["age", "=", 20]])

			from
				executor.execute_query (query)
			until
				query.result_cursor.after
			loop
				-- As we only have the last_name in the tuple,
				-- its index has to be 1
				print (query.result_cursor.item [1] )
			end			
		end
\end{lstlisting}

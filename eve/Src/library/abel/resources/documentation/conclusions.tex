\section{Conclusions}

In this thesis, we have developed a software library to access different persitence mechanism.
The library features a simple yet powerful programming interface, which is completely agnostic of the actual backend.

Below the API we developed a very flexible framework to adapt ABEL to a lot of existing storage engines.
The framework includes a reusable object-relational mapping layer, a database library wrapper, and some interfaces for extension and customization.

Based on this framework we have developed an in-memory backend which is useful for testing, and a test suite that is mostly independent of the actual backend.

Furthermore, we have developed a backend that uses a generic data\-base layout for storing objects, working both for MySQL and SQLite data\-bases.

\section{Current limitations}

\begin{itemize}
\item Due to a limitation in \lstinline!INTERNAL! the framework is not able to get ancestors or descendants of a class.
It therefore treats all classes as if they are flat, meaning that all inherited features are defined directly inside the class.
That way ABEL can handle classes inside an inheritance hierarchy, but the drawback of this approach is that a query to objects of class \lstinline!G! will not return descendants of \lstinline!G!.
\item If you adapt ABEL to a custom database layout, it can only handle object types that have corresponding tables in the database.
\item If a custom database layout isn't well designed, e.g. if there are redundancies, you might get into trouble when trying to adapt ABEL to it.
\item Some basic types are not fully supported:
\begin{itemize}
	\item \lstinline!REAL! has a rounding error.
	\item \lstinline!STRING_32! is converted to \lstinline!STRING_8!, which may distort them sometimes.
	\item \lstinline!CHARACTER! is converted to \lstinline!INTEGER! for storage.
	This is usually fine, but in custom database layouts it results in a type mismatch.
\end{itemize}
\item The generic database layout backend doesn't support \lstinline!SPECIAL! yet (or collections in general).
\item The library completely lacks any performance optimization.
\item The retrieval operation in the object-relational mapping layer doesn't support the depth parameter.
\item The error representation is not complete.
\end{itemize}

\section{Future work}
\begin{description}
 \item [Ordering] At the moment, a query result has no defined order. A mechanism to enforce an order in the result set might be useful.
 \item [Update Query] With the current API you can only do an update if the object has been retrieved or inserted before. 
To select the object to be updated, you could also use a \lstinline!QUERY! object, but additionally you need some mechanism to be able to say which attributes should be updated with a new value.
 \item [Performance] Currently there is no optimization in ABEL, and there is a lot that can be done in this area:
 \begin{itemize}
  \item Compile \lstinline!PREDEFINED_CRITERIA! to SQL in order to get smaller results from the database.
 \item Add support for lazy loading in the generic database layout implementation by using SQL cursors instead of normal SELECT statements.
 \item Use prepared statements and maybe even stored procedures instead of normal SQL statements.
 \item Optimize ABEL by trying to reduce network round trip times to a minimum.
 \item Finding and fixing performance bottlenecks in the code with the help of a profiler
\end{itemize}

 \item [Adaptor Framework] Adaption to a specific layout is a tedious task at the moment, as everything has to be hardcoded. 
It would be much easier if you could just define a mapping from classes to tables and attribute names to column names, and the framework takes care of the rest.
As an extension this mapping could be defined in an XML file.
\item [Backends] Extend ABEL to support more backends, e.g.
\begin{itemize}
 \item A serialization library
 \item An object database like db4o
 \item EiffelStore
 \item A NoSQL database like CouchDB
\end{itemize}
 \item [Inheritance] ABEL needs proper inheritance support as soon as the required features in \lstinline!INTERNAL! get implemented.
\item [Transaction management] Some backends, e.g. the in-memory backend or the serialization library, don't support transactions.
 Therefore it would be nice to implement an extension that provides local transaction management by using multiversion concurrency control at the \lstinline!BACKEND_STRATEGY! level.
\item [ESCHER] At the moment, there is an initial integration of ESCHER into the ABEL framework, but the functionality is limited to a simple version check and error reporting in case of a mismatch.
 This solution could be extended to support automatic conversion as well.
\end{description}

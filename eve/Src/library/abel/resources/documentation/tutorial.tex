
\section{Getting started}

\subsection{The setup}
In this tutorial, we are using \lstinline!PERSON! objects to show the usage of the API.
In the source code below you will see that ABEL handles objects "as they are", meaning that you don't need to inherit from any specific class to make them persistent.

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={The PERSON class}, label={lst:person_class}]
class PERSON

create
	make

feature {NONE} -- Initialization

	make (first, last: STRING)
			-- Create a new person
		do
			first_name := first
			last_name := last
			age:= 0
		end

feature -- Basic operations

	celebrate_birthday
			-- Increase age by 1
		do
			age:= age+1
		end

feature -- Access

	first_name: STRING
		-- First name of person
	last_name: STRING
		-- Last name of person

	age: INTEGER
		-- The person's age

end

\end{lstlisting}




There are three very important classes in ABEL:
\begin{itemize}
 \item The \lstinline!CRUD_EXECUTOR! is, as the name suggests, responsible to execute CRUD commands.
	It is the core interface in ABEL and completely transparent to the actual storage backend.

 \item The \lstinline!OBJECT_QUERY [G]! class is used to describe a read operation. 
	You can execute such a query in the \lstinline!CRUD_EXECUTOR!. 
	The result will be objects of type \lstinline!G!.

 \item The deferred class \lstinline!REPOSITORY! provides an abstraction to the actual storage mechanism.
	Every \lstinline!CRUD_EXECUTOR! is attached to a specific \lstinline!REPOSITORY!.
\end{itemize}

\subsection{Initialization}

To start using the library, we first need to create a \lstinline!REPOSITORY!.
For this tutorial we will use a simple \lstinline!IN_MEMORY_REPOSITORY!, which simulates a relational database but stores all values in memory.
Although this repository will not give us any persistency, we use it here because initialization is very easy.


\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={The TUTORIAL class}, label={lst:tutorial_class}]
class TUTORIAL

create
	make

feature {NONE} -- Initialization

	make
		-- Set up a simple in-memory repository
		local
			repository:PS_IN_MEMORY_REPOSITORY
		do
			create repository.make_empty
			create executor.make (repository)
		end

feature
	
	executor: PS_CRUD_EXECUTOR
		-- The CRUD executor used throughout the tutorial

end
\end{lstlisting}

We will use this class throughout the tutorial. You can assume that listings of Eiffel features are inside the \lstinline!TUTORIAL! class, if they are not enclosed in another class declaration.

If you want to set up ABEL using a real persistence mechanism you can read section ~\ref{section:advanced_initialization}, ``Advanced Initialization.''

\section{Basic operations}

\subsection{Query}

A query for objects is done by creating a \lstinline!OBJECT_QUERY [G]! object and executing it in the \lstinline!CRUD_EXECUTOR!.
The generic parameter \lstinline!G! denotes the type of objects that should be queried.
%In this tutorial they are objects of type PERSON, but ABEL will also return all objects that are descendants of type PERSON.

After a successful execution of the query, you can find the result in the iteration cursor \lstinline!OBJECT_QUERY.result_cursor!.
Having an iteration cursor as a result has several advantages, e.g. support for lazy loading or the across syntax, as you will see in the next example:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:simple_query}]
	simple_query: LINKED_LIST [PERSON]
		-- Query all person objects from the current repository
		local
			query:PS_OBJECT_QUERY[PERSON]
		do
			create Result.make
			create query.make
			executor.execute_query (query)

			across query as	query_result
			loop
				Result.extend (query_result.item)
			end
		end
\end{lstlisting}

Usually the result of such a query is very big, and you are probably only interested in objects that meet a certain criteria, e.g. all persons of age 20.
ABEL has a mechanism to support this kind of result filtering. You can read more about it in section ~\ref{sec:query}.

Please note that ABEL does not enforce any kind of order on a query result.

\begin{comment}
ABEL can also filter the query results in advance so you only get a result set that meets certain criteria: 

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:simple_filtered_query}]
	simple_filtered_query (name:STRING; age:INTEGER): detachable PERSON
		-- Query a person object from the current repository
		local
			query:PS_OBJECT_QUERY[PERSON]
			criterion:PS_PREDEFINED_CRITERION
		do
			create query.make
			create criterion.make ("last_name", "=", name)
			query.set_criterion (criterion)

			from
				executor.execute_query (query)
			until 
				query.result_cursor.after
			loop
				if query.result_cursor.item.age = age then 
					Result:= query.result_cursor.item
				end
			end
		end
\end{lstlisting}

This is just a very simple example for a query with a certain criterion.
ABEL has a powerful mechanism that also supports a logical combinations of multiple criteria, or using agents for filtering.
You can read more about criteria in section XY.

\end{comment}

\subsection{Insert and update}

Inserting and updating an object is done through \lstinline!CRUD_EXECUTOR.insert! (or \lstinline!CRUD_EXECUTOR.update!, respectively): 

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:simple_insert}]
	simple_insert_and_update (a_person:PERSON)
		-- Insert `a_person' into the current repository
		do
			executor.insert (a_person)
			a_person.celebrate_birthday
			executor.update (a_person)
		end
\end{lstlisting}


\subsection{Deletion}
\label{subsection:simple_delete}

Deletion is done through the \lstinline!CRUD_EXECUTOR.delete! feature, like shown in the following example:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:simple_delete}]
	delete_person (name:STRING)
		-- Delete the person called `name'.
		local
			query: PS_OBJECT_QUERY[PERSON]
		do
			-- First retrieve the person from the database
			create query.make
			executor.execute_query (query)
			across query as query_result
			loop
				if query_result.item.last_name.is_equal (name) then

					-- Now delete him
					executor.delete (query_result.item)
				end
			end
		end
\end{lstlisting}

Another way to delete objects is described in section ~\ref{subsection:deletion_query}.

\subsection{Recognizing Objects}
\label{subsection:recognize_objects}

ABEL keeps track of objects that have been inserted or queried.
This is important because in case of an update or delete, the library internally needs to map the object in the current execution of the program to its specific entry in the database.

Because of that, you can't update or delete an object that is not yet known to ABEL.
As an example, the following two functions will fail:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:failing_update_delete}]
	failing_update
		-- Try and fail to update a new person object
		local
			a_person:PERSON
		do
			create a_person.make ("Albo", "Bitossi")
			executor.update (a_person)
				-- Results in a precondition violation
		end

	failing_delete (name:STRING)
		-- Try and fail to delete a new person object
		local
			a_person:PERSON
		do
			create a_person.make ("Albo", "Bitossi")
			executor.delete (a_person) 
				-- Results in a precondition violation
		end
\end{lstlisting}

Please note that there's another way to delete objects, described in section ~\ref{subsection:deletion_query}, which doesn't have this restriction.

The \lstinline!CRUD_EXECUTOR.is_persistent! feature can tell you if a specific object is known to ABEL and hence has a link to its entry in the data\-base.



%Insert the section about advanced queries here:
\input{querying}


\section{Dealing with references}
\label {sec:references}

In ABEL, a basic type is an object of type \lstinline!STRING!, \lstinline!BOOLEAN!, \lstinline!CHARACTER! or any numeric class like \lstinline!REAL! or \lstinline!INTEGER!.
The \lstinline!PERSON! class only has attributes that are of a basic type.

However, in Eiffel there's also the fact that an object can contain references to other objects.
ABEL is able to handle these references by storing and reconstructing the whole object graph 
(an object graph is sloppily defined as all objects that can be reached by recursively following all references, starting at some root object).

Let's look at the new class \lstinline!CHILD!:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={The CHILD class}, label={lst:child_class}]

class 
	CHILD

create
	make

feature {NONE} -- Initialization

	make (first, last: STRING)
			-- Create a new child
		do
			first_name := first
			last_name := last
			age:= 0
		end

feature -- Access

	celebrate_birthday
			-- Increase age by 1
		do
			age:= age+1
		end

feature -- Status report

	first_name: STRING
		-- First name of child
	last_name: STRING
		-- Last name of child

	age: INTEGER
		-- The child's age

feature	-- Parents 

	mother: detachable CHILD
		-- `Current's mother

	father: detachable CHILD
		-- `Current's father
	
	set_mother (a_mother: CHILD)
		-- Set the mother
		do
			mother:= a_mother
		end

	set_father (a_father: CHILD)
		-- Set the father
		do
			father:= a_father
		end
end
\end{lstlisting}


This adds in some complexity: 
Instead of having a single object, ABEL has to insert a \lstinline!CHILD!'s mother and father as well, and if their parent attribute is attached as well it has to repeat this procedure.
The good news for you is that the examples above will work exactly the same.

However, there are some additional caveats to take into consideration. 
Let's consider a simple example with \lstinline!CHILD! objects ``Baby Doe'', ``John Doe'' and ``Grandpa Doe''.
From the name of the object instances you can already guess what the object graph looks like: 

	\begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,
  thick,main node/.style={rectangle,fill=white,draw}]

  \node[main node] (1) {$Baby Doe$};
  \node[main node] (2) [right of=1] {$John Doe$};
  \node[main node] (3) [right of=2] {$Grandpa Doe$};

 

  \path
    (1) edge node {$father$} (2)
    (2) edge node {$father$} (3);
\end{tikzpicture}
	\end{center}

Now if you insert ``Baby Doe'', ABEL will by default follow all references and insert every single object along the object graph, which means that ``John Doe'' and ``Grandpa Doe'' will be inserted as well.
This is usually the desired behaviour, as objects are stored completely that way, but it also has some side effects:

\begin{itemize}
\item Assume an insert of ``Baby Doe'' has happened to an empty database. 
If you now query the database for \lstinline!CHILD! objects, it will return exactly the same object graph as above, but the query result will actually have three items, as the object graph consists of three single \lstinline!CHILD! objects.
	
\item After you've inserted ``Baby Doe'', it has no effect if you insert ``John Doe'' or ``Grandpa Doe'' afterwards, because they have already been inserted by the first statement.
\end{itemize}

\subsection{Updates}

By default, ABEL does not follow references during an update. 
So for example the following statement has no effect on the database.

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:reference_update}]
	celebrate_fathers_birthday (a_child: CHILD)
		-- Increase age of `a_child's father
		require
			child_persistent: executor.is_persistent (a_child)

		do
			a_child.father.celebrate_birthday

			-- This won't have any effect
			executor.update (a_child)

			-- however, it works that way
			executor.update (a_child.father)
		end
\end{lstlisting}

\subsection{Going deeper}

ABEL has no limits regarding the depth of an object graph, and it will detect and handle reference cycles correctly. 
You are welcome to test ABEL's capability with very complex objects, however please keep in mind that this will cause a big performance impact.

To overcome this problem, you can either use simple object structures, or you can tell ABEL to only load or store an object up to a certain depth.
You can see how this is done in section ~\ref{subsection:obect_graph_settings} in the technical documentation, where the whole concept of an object graphs and its depth is described more detailed.



\section{Advanced Initialization}
\label{section:advanced_initialization}

The in-memory repository we've used so far doesn't store data permanently.
This is acceptable for testing or a tutorial, but not in a real application.
Therefore, ABEL ships with repositories for a MySQL database and an SQLite database.

To use them, you currently have to assemble the parts that are needed.
For MySQL, you need to create a \lstinline!MYSQL_DATABASE! and \lstinline!MYSQL_STRINGS! object.
You need them to create a \lstinline!GENERIC_LAYOUT_SQL_BACKEND!, which you need in turn to create the \lstinline!RELATIONAL_REPOSITORY!.

The following little factory class show the process for either a MySQL or an SQLite \cite{SQLite} database:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:advanced_initialization}]

class 
	REPOSITORY_FACTORY

feature -- Connection details
	
	username:STRING = "tutorial"
	password:STRING = "tutorial"

	db_name:STRING = "tutorial"
	db_host:STRING = "127.0.0.1"
	db_port:INTEGER = 3306

	sqlite_filename: STRING = "tutorial.db"

feature -- Factory methods

	create_mysql_repository: PS_RELATIONAL_REPOSITORY
		-- Create a MySQL repository
		local
			database: PS_MYSQL_DATABASE
			mysql_strings: PS_MYSQL_STRINGS
			backend: PS_GENERIC_LAYOUT_SQL_BACKEND
		do
			create database.make (username, password, db_name, db_host, db_port)
			create mysql_strings
			create backend.make (database, mysql_strings)
			create Result.make (backend)
		end

	create_sqlite_repository: PS_RELATIONAL_REPOSITORY
		-- Create an SQLite repository
		local
			database: PS_SQLITE_DATABASE
			sqlite_strings: PS_SQLITE_STRINGS
			backend: PS_GENERIC_LAYOUT_SQL_BACKEND
		do
			create database.make (sqlite_filename)
			create sqlite_strings
			create backend.make (database, sqlite_strings)
			create Result.make (backend)
		end
end

\end{lstlisting}

All examples from this tutorial work exactly the same, no matter if you use the \lstinline!IN_MEMORY_REPOSITORY! or any of the database repositories.


\section{Transaction handling}

Every CRUD operation in ABEL is executed within a transaction. 
Transactions are created and commited implicitly, which has the advantage that - especially when dealing with complex object graphs - an object doesn't get ``halfway inserted'' in case of an error.

As a user, you also have the possibility to use transactions explicitly. 
This is done by manually creating an object of type \lstinline!TRANSACTION! and using the \lstinline!*_within_transaction! features in \lstinline!CRUD_EXECUTOR! instead of the normal ones.
For your convenience there is a factory method for transactions built into the executor.

Let's consider an example where you want to update the age of every person by one:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:update_all_ages}]
	update_ages
		-- Increase everyone's age by one
		local
			query: PS_OBJECT_QUERY[PERSON]
			transaction: PS_TRANSACTION
		do
			create query.make
			transaction := executor.new_transaction

			executor.execute_query_within_transaction (query, transaction)

			across query as query_result
			loop
				query_result.item.celebrate_birthday
				executor.update_within_transaction 
					(query_result.item, transaction)
			end

			transaction.commit

			-- The commit may have failed
			if transaction.has_error then
				print ("Commit has not been successful")
			end
		end
\end{lstlisting}

You can see here that a commit can fail in some situations, e.g. when a write conflict happened in the database.
The errors are reported in the \lstinline!TRANSACTION.has_error! attribute.
In case of an error, all changes of the transaction are rolled back automatically.

You can also abort a transaction manually by calling \lstinline!TRANSACTION.rollback!. 

\subsection{Transaction isolation levels}

ABEL supports the four standard transaction isolation levels found in almost every database system:
\begin{itemize}
 \item Read Uncommitted
 \item Read Committed
 \item Repeatable Read
 \item Serializable
\end{itemize}

The different levels are defined in \lstinline!TRANSACTION_ISOLATION_LEVEL!.

You can change the transaction isolation level by calling the feature \lstinline!REPOSITORY.set_transaction_isolation_level!.
The default transaction isolation level of ABEL is defined by the actual storage backend.

Please note: Not every backend supports all isolation levels.
Therefore a backend can also use a higher isolation level than you actually instruct it to use, but it is not allowed to use a lesser isolation level.



\section{Error handling}

As ABEL is dealing with IO and databases, runtime errors may happen. 
The library will in general raise an exception in case of an error and expose the error to the library user as an \lstinline!ERROR! object.
ABEL distinguishes between two different kinds of errors.

\begin{itemize}

\item Fatal errors: Irrecoverable errors happening in a scenario like a broken connection or an integrity constraint violation in the database.
The usual measure is to rollback the current transaction and raise an exception. 
If you catch the exception in a rescue clause and manage to resolve the problem, you can continue using ABEL.

\item Resolvable failures: Those are not really visible to the user, because no exception is raised when they occur.
A typical example is a conflict between two transactions.
ABEL will detect the failure and, in case of implicit transaction management, retry.

If you use explicit transaction management, it will just doom the current transaction to fail at commit time.
\end{itemize}

ABEL maps database specific error messages to its own representation for errors, which is a set of classes with the common ancestor \lstinline!ERROR!.
The following list shows all error classes that are currently defined.

If not explicitly stated otherwise, the errors in this lists belong to the first category (fatal errors).

\begin{itemize}
\item \lstinline!CONNECTION_PROBLEM!: A broken internet link, or a deleted serialization file.
\item \lstinline!TRANSACTION_CONFLICT!: A write conflict between two transactions. This is a resolvable failure.
\item \lstinline!UNRESOLVABLE_TRANSACTION_CONFLICT!: A write conflict between implicit transactions that doesn't resolve after a retry.
\item \lstinline!ACCESS_RIGHT_VIOLATION!: Insufficient privileges in database, or no write permission to serialization file.
\item \lstinline!VERSION_MISMATCH!: The stored version of an object isn't compatible any more to the current type.
\item \lstinline!INTERNAL_ERROR!: Any error happening inside the library, e.g. a wrong SQL compilation.
\item \lstinline!GENERAL_ERROR!: Anything that doesn't fit into one of the categories above.
\end{itemize}

If you want to handle an error, you have to add a rescue clause somewhere in your code.

You can get the actual error from the feature \lstinline!CRUD_EXECUTOR.error! or \lstinline!TRANSACTION.error! or - due to the fact that the \lstinline!ERROR! class inherits from \lstinline!DEVELOPER_EXCEPTION! -
by performing an object test on Eiffel's \lstinline!EXCEPTION_MANAGER.last_exception!.

For your convenience, there is a visitor pattern for all ABEL error types. 
You can just implement the appropriate functions and use it for your error handling code.

The following code shows an example. 
Note that only some important features are shown:

\begin{lstlisting}[language=OOSC2Eiffel, captionpos=b, caption={}, label={lst:error_visitor_example}]

class
	MY_PRIVATE_VISITOR
inherit
	PS_ERROR_VISITOR

feature
	shall_retry: BOOLEAN
		-- Should my client retry the operation?

	visit_access_right_violation (
		error: PS_ACCESS_RIGHT_VIOLATION)
		-- Visit an access right violation error
		do
			add_some_privileges
			shall_retry:=True
		end

	visit_connection_problem (error: PS_CONNECTION_PROBLEM)
		-- Visit a connection problem error
		do
			notify_user_of_abort
			shall_retry:=False
		end

end



class
	TUTORIAL

feature

	my_visitor: MY_PRIVATE_VISITOR
		-- A user-defined visitor to react to an error

	executor: PS_CRUD_EXECUTOR
		-- The CRUD executor used throughout the tutorial


	do_something_with_error_handling
		-- Perform some operations. Deal with errors in case of a problem
		do
			-- Some complicated operations
		rescue
			my_visitor.visit (executor.error)
			if my_visitor.shall_retry then
				retry
			else
				-- The exception propagates upwards, and maybe
				-- another feature can handle it
			end
		end
end

\end{lstlisting}




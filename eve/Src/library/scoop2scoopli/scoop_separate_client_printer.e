indexing
	description: "SCOOP_SEPARATE_CLIENT_PRINTER implements the starting point of the client class creation step."
	legal: "See notice at end of class."
	date: "$Date$"
	revision: "$Revision$"

class
	SCOOP_SEPARATE_CLIENT_PRINTER

inherit
		-- to get common used visitor node processing functionality
	SCOOP_CLIENT_CONTEXT_AST_PRINTER
		export
			{NONE} all
			{SCOOP_VISITOR_FACTORY} setup
			{DEGREE_SCOOP} get_context
		redefine
			process_class_as,
			process_create_as,
			process_feature_clause_as,
			process_feature_as
		end

create
	make,
	make_with_default_context

feature -- Access

	process_class is
			-- Process current `class_as'.
			-- This is the entry point to start the client class creation.
		do
			process_class_as (class_as)
		end

feature {NONE} -- Roundtrip: process nodes

	process_class_as (l_as: CLASS_AS) is
			-- Process `l_as', the AST class node.
		require else
			class_as_not_void: class_as /= Void
			class_c_not_void: class_c /= Void
		local
			s: STRING_AS
			l_parent_visitor: SCOOP_CLIENT_PARENT_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- inicial comments to indicate the automated class generation
			context.add_string ("-- This class has been generated by SCOOP2SCOOPLI")
			context.add_string ("%N-- It implements separate clients for objects based on class " + class_as.class_name.name + "%N%N")

			-- since we produce only override classes we skip the indexing part
			-- safe_process (l_as.internal_top_indexes)
			if l_as.internal_top_indexes /= Void then
				last_index := l_as.internal_top_indexes.last_token (match_list).index
			end

			safe_process (l_as.frozen_keyword (match_list))
			safe_process (l_as.deferred_keyword (match_list))
			safe_process (l_as.expanded_keyword (match_list))
			safe_process (l_as.separate_keyword (match_list))
			safe_process (l_as.external_keyword (match_list))
			safe_process (l_as.class_keyword (match_list))
			safe_process (l_as.class_name)

			-- process internal generics
			if l_as.internal_generics /= Void then
				process_leading_leaves (l_as.internal_generics.index)
				l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
				l_generics_visitor.process_class_internal_generics (l_as.internal_generics, true, false)
				last_index := l_generics_visitor.get_last_index
			end

			safe_process (l_as.alias_keyword (match_list))
			s ?= l_as.external_class_name
			safe_process (s)
			safe_process (l_as.obsolete_keyword (match_list))
			safe_process (l_as.obsolete_message)

			-- process parents
			l_parent_visitor := scoop_visitor_factory.new_client_parent_visitor (context)
			l_parent_visitor.process_internal_conforming_parents(l_as.internal_conforming_parents)
			l_parent_visitor.process_internal_non_conforming_parents (l_as.internal_non_conforming_parents)
			if l_as.conforming_parents /= Void or l_as.non_conforming_parents /= Void then
				last_index := l_parent_visitor.get_last_index
			end

			context.add_string ("%N%N")
			safe_process (l_as.creators)
			safe_process (l_as.convertors)

			-- process feature clauses
			safe_process (l_as.features)

			-- add infix prefix feature wrappers
			-- Remove this call with EiffelStudio 6.4
			insert_infix_prefix_wrappers

--			if l_as.internal_invariant /= Void then
--				last_index := l_as.internal_invariant.invariant_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_invariant)
--			end

			-- process indexes
			if l_as.internal_bottom_indexes /= Void then
				context.add_string ("%N%N")
				last_index := l_as.internal_bottom_indexes.first_token (match_list).index - 1
				safe_process (l_as.internal_bottom_indexes)
			else
				last_index := l_as.end_keyword.index - 1
				context.add_string ("%N%N")
			end

			-- process end keyword
			safe_process (l_as.end_keyword)
		end

	process_create_as (l_as: CREATE_AS) is
			-- Process `l_as', class creation feature list.
		do
			safe_process (l_as.create_creation_keyword (match_list))
			-- process client list
			process_clients (l_as.clients)
			safe_process (l_as.feature_list)
		end

	process_feature_clause_as (l_as: FEATURE_CLAUSE_AS) is
			-- Process `l_as', AST feature clause list.
		do
			last_index := l_as.first_token (match_list).index
			context.add_string ("%N%N")
			safe_process (l_as.feature_keyword)
			process_clients (l_as.clients)
			safe_process (l_as.features)
		end

	process_clients (l_as: CLIENT_AS) is
			-- Processes `l_as', the export list by iterating it in the `process_client_list' feature.
		do
			if l_as /= Void and then l_as.clients /= Void then
				safe_process (l_as.clients.lcurly_symbol (match_list))
				process_client_list (l_as.clients)
				safe_process (l_as.clients.rcurly_symbol (match_list))
			end
		end

	process_client_list (l_as: EIFFEL_LIST [ID_AS]) is
			-- Iterates a given client class list and makes some changes:
			--   - it adds the proxy class of the current class to the list
			--   - it filters class 'NONE' from the list because of the change before
		local
			i, l_count: INTEGER
			l_none_str: STRING
		do
			create l_none_str.make_from_string ("NONE")

			if l_as.count > 0 then
				-- set first client a reference to the proxy class.
				process_leading_leaves (l_as.first.index)
				context.add_string ("SCOOP_SEPARATE__" + class_c.name_in_upper)
				if not l_as.first.name.is_equal (l_none_str) then
					context.add_string (", ")
				end
				-- iterate over list and filter class "NONE"
				from
					l_as.start
					i := 1
					if l_as.separator_list /= Void then
						l_count := l_as.separator_list.count
					end
				until
					l_as.after
				loop
					if not l_as.item.name.is_equal (l_none_str) then
						safe_process (l_as.item)
						if i <= l_count then
							safe_process (l_as.separator_list_i_th (i, match_list))
							i := i + 1
						end
					else
						last_index := l_as.item.index
						if i <= l_count then
							i := i + 1
						end
					end
					l_as.forth
				end
			end
		end

	process_feature_as (l_as: FEATURE_AS) is
			-- Process `l_as', the AST feature node and invokes the `SCOOP_CLIENT_FEATURE_VISITOR'.
		local
			l_feature_visitor: SCOOP_CLIENT_FEATURE_VISITOR
		do
			process_leading_leaves (l_as.feature_names.index)
			-- Process the feature node with the feature visitor
			l_feature_visitor := scoop_visitor_factory.new_client_feature_visitor (context)
			l_feature_visitor.process_feature(l_as)
			last_index := l_as.last_token (match_list).index
		end

feature {NONE} -- Implementation

	insert_infix_prefix_wrappers is
			-- Inserts the wrapper feature of `scoop_workbench_objects.proxy_infix_prefix_wrappers'.
			-- Remove this item with EiffelStudio 6.4
		local
			i, nb: INTEGER
			l_wrapper_list: LINKED_LIST [STRING]
		do
			l_wrapper_list := scoop_workbench_objects.proxy_infix_prefix_wrappers
			if l_wrapper_list /= Void and then l_wrapper_list.count > 0 then

				-- add a feature clause
				context.add_string ("%N%Nfeature {NONE} -- Wrapper features for infix / prefix features")

				-- add the features				
				from
					i := 1
					nb := l_wrapper_list.count
				until
					i > nb
				loop
					context.add_string (l_wrapper_list.i_th (i))

					i := i + 1
				end
			end
		end

invariant
	context_not_void: context /= Void

end

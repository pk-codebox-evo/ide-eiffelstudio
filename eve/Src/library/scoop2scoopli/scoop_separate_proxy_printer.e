note
	description: "SCOOP_SEPARATE_PROXY_PRINTER implements the starting point of the proxy class creation step."
	legal: "See notice at end of class."
	status: "See notice at end of class."
	date: "$Date$"
	revision: "$Revision$"

class
	SCOOP_SEPARATE_PROXY_PRINTER

inherit
	SCOOP_CONTEXT_AST_PRINTER
		-- Get common used visitor node processing functionality
		export
			{NONE} all
			{SCOOP_VISITOR_FACTORY} setup
			{DEGREE_SCOOP} get_context
		redefine
			process_class_as,
			process_feature_clause_as,
			process_feature_as,
			process_class_type_as,
			process_generic_class_type_as,
			process_named_tuple_type_as,
			process_type_dec_as,
			process_class_list_as,
			process_create_as,
			process_like_cur_as,
			process_keyword_as,
			process_invariant_as
		end

	SCOOP_WORKBENCH
		export
			{NONE} all
		end

	SCOOP_CLASS_NAME
		export
			{NONE} all
		end

	SHARED_ERROR_HANDLER
		-- for creating an error when unexpected node processing happens
		export
			{NONE} all
		end

create
	make,
	make_with_default_context

feature {NONE} -- Initialization

	make (a_ctxt: ROUNDTRIP_CONTEXT)  is
			-- Initialize, set `context' with `a_ctxt'.
		require
			a_ctxt_not_void: a_ctxt /= Void
		do
			context := a_ctxt
		end

	make_with_default_context is
			-- Initialize, create context of type `ROUNDTRIP_STRING_LIST_CONTEXT'.
		do
			make (create {ROUNDTRIP_STRING_LIST_CONTEXT}.make)
		end

feature -- Access

	process is
			-- Process current `class_as'.
			-- Entry point to start client class creation.
		do
			-- initialize type visitors for visiting signatures and locals
			l_type_signature := scoop_visitor_factory.new_proxy_type_signature_printer (context)
			l_type_locals := scoop_visitor_factory.new_proxy_type_local_printer (context)
			-- start class processing
			process_class_as (class_as)
		end

feature {NONE} -- Roundtrip: process nodes

	process_class_as (l_as: CLASS_AS) is
			-- Process `l_as', the AST class node.
		require else
			class_as_not_void: class_as /= Void
			class_c_not_void: class_c /= Void
		local
			s: STRING_AS
			l_parent_visitor: SCOOP_PROXY_PARENT_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- inicial comments to indicate the automated class generation
			context.add_string ("-- This class has been generated by SCOOP2SCOOPLI")
			context.add_string ("%N-- It implements separate proxies for objects based on class " + class_as.class_name.name + "%N%N")

			-- since we produce only override classes we skip the indexing part
			-- safe_process (l_as.internal_top_indexes)
			if l_as.internal_top_indexes /= Void then
				last_index := l_as.internal_top_indexes.last_token (match_list).index
			end

			safe_process (l_as.frozen_keyword (match_list))
			safe_process (l_as.deferred_keyword (match_list))

			-- if class is expanded then set proxy class deferred
			if l_as.is_expanded then
				process_leading_leaves (l_as.expanded_keyword_index)
				context.add_string ("deferred ")
			end

			safe_process (l_as.external_keyword (match_list))
			safe_process (l_as.class_keyword (match_list))
			process_leading_leaves (l_as.class_name.index)
			process_class_name (l_as.class_name, True, context, match_list)
			if l_as.class_name /= Void then
				last_index := l_as.class_name.last_token (match_list).index
			end

			-- process internal generics
			if l_as.internal_generics /= Void then
				process_leading_leaves (l_as.internal_generics.index)
				l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
				l_generics_visitor.process_class_internal_generics (l_as.internal_generics, True, False)
				last_index := l_generics_visitor.get_last_index
			end

			safe_process (l_as.alias_keyword (match_list))
			s ?= l_as.external_class_name
			safe_process (s)
			safe_process (l_as.obsolete_keyword (match_list))
			safe_process (l_as.obsolete_message)

			-- process parents
			l_parent_visitor := scoop_visitor_factory.new_proxy_parent_visitor (context)
			l_parent_visitor.process_internal_conforming_parents (l_as.internal_conforming_parents)
			l_parent_visitor.process_internal_non_conforming_parents (l_as.internal_non_conforming_parents)
			if l_as.conforming_parents /= Void or l_as.non_conforming_parents /= Void then
				last_index := l_parent_visitor.get_last_index
			end

			-- process creation and conversion clause
			process_creators_and_conversions (l_as.creators)

			-- process features
			safe_process (l_as.features)

			-- add SCOOP feature clause with reference to client object.
			context.add_string ("%N%Nfeature -- Separateness")
			-- add attribute of actual object
			context.add_string ("%N%N%Timplementation_: " + l_as.class_name.name.as_upper)
			-- formal paramters
			if l_as.internal_generics /= Void then
				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, True, True)
			end
			context.add_string ("%N%T%T-- reference to actual object")

			-- add SCOOP feature: wrappers for creation features.
			if not l_as.is_deferred or l_as.is_expanded then
				context.add_string ("%N%Nfeature -- Creation Wrappers%N")
				if l_as.creators /= Void then
					last_index := l_as.creators.index - 1
					safe_process (l_as.creators)
				else
					process_default_create_wrappers
				end
			end

			-- process invariants (skip it - see `process_invariant_as')
--			if l_as.internal_invariant /= Void then
--				last_index := l_as.internal_invariant.invariant_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_invariant)
--			end


			context.add_string ("%N%N")

			context.add_string (";") -- fix for notes at the end of the class  ::remove when activating invariants!::

			-- process indexes
			if l_as.internal_bottom_indexes /= Void then
				last_index := l_as.internal_bottom_indexes.first_token (match_list).index - 1
				safe_process (l_as.internal_bottom_indexes)
			else
				last_index := l_as.end_keyword.index - 1
			end





			-- process end keyword
			safe_process (l_as.end_keyword)
		end

	process_feature_clause_as (l_as: FEATURE_CLAUSE_AS) is
			-- Process `l_as', the AST feature clause list.
		do
			-- remember the current feature clause
			set_current_feature_clause_as (l_as)
			-- process feature clause
			last_index := l_as.first_token (match_list).index
			context.add_string ("%N%N")
			safe_process (l_as.feature_keyword)
			safe_process (l_as.clients)
			-- process feature clause comment
			if not l_as.features.is_empty then
				process_leading_leaves (l_as.features.first_token (match_list).index)
			else
				process_leading_leaves (l_as.last_token (match_list).index + 1)
			end
			-- set value for pretty printing
			set_is_first_feature (True)
			-- process features
			safe_process (l_as.features)
			-- reset the current feature clause
			set_current_feature_clause_as_void
		end

	process_feature_as (l_as: FEATURE_AS) is
			-- Process `l_as', the AST feature node, invokes the `SCOOP_PROXY_FEATURE_VISITOR'.
		local
			l_feature_visitor: SCOOP_PROXY_FEATURE_VISITOR
			l_feature_object: SCOOP_CLIENT_FEATURE_OBJECT
		do
			create l_feature_object.make
			set_feature_object (l_feature_object)
			l_feature_visitor := scoop_visitor_factory.new_proxy_feature_visitor (context)
			l_feature_visitor.process_feature(l_as)
			last_index := l_as.last_token (match_list).index
		end

	process_class_type_as (l_as: CLASS_TYPE_AS) is
			-- Process `l_as', the AST class type node.
			-- This node should not be processed since all type nodes
			-- are already handled by the type visitors.
			-- This process feature can also be deleted.
		do
			-- create error
			error_handler.insert_error (create {INTERNAL_ERROR}.make("SCOOP coding error: Unexpected node processing."))
		end

	process_generic_class_type_as (l_as: GENERIC_CLASS_TYPE_AS) is
			-- Process `l_as', the AST generic class type node.
			-- This node should not be processed since all type nodes
			-- are already handled by the type visitors.
			-- This process feature can also be deleted.
		do
			-- create error
			error_handler.insert_error (create {INTERNAL_ERROR}.make("SCOOP coding error: Unexpected node processing."))
		end

	process_named_tuple_type_as (l_as: NAMED_TUPLE_TYPE_AS) is
			-- Process `l_as', the AST named tuple type node.
			-- This node should not be processed since all type nodes
			-- are already handled by the type visitors.
			-- This process feature can also be deleted.
		do
			-- create error
			error_handler.insert_error (create {INTERNAL_ERROR}.make("SCOOP coding error: Unexpected node processing."))
		end

	process_like_cur_as (l_as: LIKE_CUR_AS) is
			-- Process `l_as', the AST like current node.
			-- This node should not be processed since all type nodes
			-- are already handled by the type visitors.
			-- This process feature can also be deleted.
		do
			-- create error
			error_handler.insert_error (create {INTERNAL_ERROR}.make("SCOOP coding error: Unexpected node processing."))
		end

	process_create_as (l_as: CREATE_AS) is
			-- Process `l_as', the class creation feature list.
			-- Call `process_default_create_wrappers' when a `default_create' feature is listed.
		local
			i, nb: INTEGER
			l_is_creator_default_create: BOOLEAN
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_feature_name: STRING
		do
			if l_as.feature_list /= Void then
				l_feature_name_visitor := scoop_visitor_factory.new_feature_name_visitor

				from
					i := 1
					nb := l_as.feature_list.count
				until
					i > nb
				loop
					l_feature_name_visitor.process_feature_name (l_as.feature_list.i_th (i), False)
					l_feature_name := l_feature_name_visitor.feature_name

					if l_feature_name.is_equal ("default_create") then
						l_is_creator_default_create := True
					else
						process_creation_procedure_wrappers (l_feature_name)
					end
					i := i + 1
				end

				if l_is_creator_default_create then
					process_default_create_wrappers
				end
			end
		end

	process_type_dec_as (l_as: TYPE_DEC_AS) is
			-- Process 'l_as', the internal argument list.
		do
			process_identifier_list (l_as.id_list)
			safe_process (l_as.colon_symbol (match_list))
			-- process type
			l_type_signature.process_type (l_as.type)
		end

	process_class_list_as (l_as: CLASS_LIST_AS) is
			-- Process `l_as', the class list node.
			-- If a class name (other than ANY or NONE) appears in the list, add its separate proxy as well.
		do
			safe_process (l_as.lcurly_symbol (match_list))

			-- add class names with prefix
			if l_as /= Void then
				process_class_name_list_with_prefix (l_as, True, context, match_list)
			end
			last_index := l_as.rcurly_symbol_index - 1
			safe_process (l_as.rcurly_symbol (match_list))
		end

	process_keyword_as (l_as: KEYWORD_AS) is
			-- Process `l_as', the AST keyword node.
		do
			if l_as.is_separate_keyword then
				-- skip	
				last_index := l_as.index
			elseif l_as.is_frozen_keyword then
				Precursor (l_as)
				-- add a space
				context.add_string (" ")
			elseif l_as.is_prefix_keyword or l_as.is_infix_keyword then
				-- skip	
				Precursor (l_as)
				context.add_string ("_")
			else
				Precursor (l_as)
			end
		end

	process_invariant_as (l_as: INVARIANT_AS) is
			-- Process `l_as', the AST invariant node.
		do
			-- skip node
			if l_as.full_assertion_list /= Void then
				last_index := l_as.last_token (match_list).index
			end
		end

feature {NONE} -- Roundtrip: Implementation

	process_creators_and_conversions (l_as: EIFFEL_LIST [CREATE_AS]) is
			-- Process creators and convertors
		local
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- creator & convertor
			if not class_as.is_deferred then
				-- creator
				-- context.add_string ("%N%Ncreate%N%Tmake_from_local, set_processor_")
				context.add_string ("%N%Ncreate%N%Tset_processor_")

--				-- convertor Removed by `damienm', conversion is done on client side

--				context.add_string ("%N%Nconvert%N%Tmake_from_local ({" + class_as.class_name.name.as_upper)

--				-- formal paramters
--				l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
--				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, True, True)

--				-- convertor end
--				context.add_string ("})")
			end

			-- skip original creators and convertors
			if class_as.creators /= Void or class_as.convertors /= Void then
				if class_as.features /= Void then
					last_index := class_as.features.index - 1
				elseif class_as.internal_invariant /= Void then
					last_index := class_as.internal_invariant.first_token (match_list).index - 1
				elseif class_as.internal_bottom_indexes /= Void then
					last_index := class_as.internal_bottom_indexes.index -1
				else
					last_index := class_as.end_keyword.index - 1
				end
			end

			-- wrapping creation instruciton
			if not class_as.is_deferred and then class_as.is_expanded then
				if class_as.creators /= Void then
					safe_process (class_as.creators)
				else
					process_default_create_wrappers
				end
			end
		end

	process_default_create_wrappers is
			-- Generate two additional procedures:
			-- `default_create_scoop_separate_class_name' and `effective_default_create_scoop_separate_class_name'
			-- for wrapping creation instructions.
		do
			-- 'default_create_scoop_separate_class_name'
			context.add_string ("%N%Nfeature -- default creation instruction wrapper")
			context.add_string ("%N%N%Tdefault_create_scoop_separate_")
			context.add_string (class_as.class_name.name.as_lower)
			context.add_string (" (a_caller_: SCOOP_SEPARATE_CLIENT)")
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for creation procedure `default_create'.%N%T%T")
			context.add_string ("%N%T%Tdo")

			context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_default_create_scoop_separate_" + class_as.class_name.name.as_lower)
			context.add_string (")%N%T%Tend")

			-- 'effective_default_create_scoop_separate_class_name'
			context.add_string ("%N%N%Teffective_default_create_scoop_separate_" + class_as.class_name.name.as_lower + " is")
			context.add_string ("%N%T%T%T-- Wrapper for creation procedure `default_create'.")
			context.add_string ("%N%T%Tdo")
			if not class_as.class_name.name.as_upper.is_equal ("METHOD_BAS") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_STRING") or else
				class_as.class_name.name.as_upper.is_equal ("STRING_BUILDER") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_ARRAY") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_OBJECT")
			then
				context.add_string ("%N%T%T%Tcreate implementation_")
			end
			context.add_string ("%N%T%Tend%N")
		end

	process_creation_procedure_wrappers (a_feature_name: STRING) is
			-- Generate two additional procedures:
			-- `feature_name_scoop_separate_class_name' and `effective_feature_name_scoop_separate_class_name'
			-- for wrapping creation instructions.
		local
			l_feature_i: FEATURE_I
			l_feature_as: FEATURE_AS
			lock_passing_possible: BOOLEAN
		do
				-- get feature
			if class_as.feature_table.has (a_feature_name) then
				l_feature_i := class_as.feature_table.item (a_feature_name)
			end

				-- only handle if not inherited.
			if l_feature_i.written_class.name_in_upper.is_equal (class_as.class_name.name.as_upper) then

				context.add_string ("%N%Nfeature -- creation instruction wrapper")

				l_feature_as := l_feature_i.body

				if l_feature_as /= Void and l_feature_as.body /= Void then

					context.add_string ("%N%N%T" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
					if l_feature_as.body.internal_arguments /= Void then
						-- print type with prefix
						last_index := l_feature_as.body.internal_arguments.first_token (match_list).index
						process_formal_argument_list_with_a_caller (l_feature_as.body.internal_arguments)
					else
						context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE) ") --CLIENT) ")
					end

					context.add_string (" is%N%T%T%T")
					context.add_string ("-- Wrapper for creation procedure `" + a_feature_name + "'.%N%T%T")

					if l_feature_as.body.internal_arguments /= Void then
						lock_passing_possible := process_auxiliary_local_variables (l_feature_as, a_feature_name)
					else
						context.add_string ("%N%T%Tdo")
					end
					is_like_item_proxy := true
					if lock_passing_possible then
						process_lock_passing_before
						context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, False, True)
						end
						context.add_string (")")
						process_lock_passing_after
						context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, False, True)
						end
						context.add_string (")")
						context.add_string ("%N%T%T%Tend")
					else
						context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, False, True)

						end
						context.add_string (")")
					end
					is_like_item_proxy := false
					context.add_string ("%N%T%Tend")
				end

				-- 'effective_feature_name_scoop_separate_class_name'
				context.add_string ("%N%N%Teffective_" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
				if l_feature_as.body.internal_arguments /= Void then
					process_flattened_formal_argument_list (l_feature_as.body.internal_arguments, False)
				end
				context.add_string (" is")
				context.add_string ("%N%T%T%T-- Wrapper for creation procedure `" + a_feature_name + "'.")
				context.add_string ("%N%T%Tdo%N%T%T%Tcreate implementation_." + a_feature_name)
				if l_feature_as.body.internal_arguments /= Void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (l_feature_as.body.internal_arguments, False)
				end
				context.add_string ("%N%T%Tend")
			else
				process_parent_creation_feature (l_feature_i)
			end
		end

	process_parent_creation_feature (featr : FEATURE_I)
			-- Create parent creation wrapper feature
		local
			lock_passing_possible : BOOLEAN
		do
			context.add_string ("%N%Nfeature -- creation instruction wrapper")
			context.add_string ("%N%N%T" + featr.feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")

			if featr.arguments /= void then
				process_formal_arguments_with_caller (featr.arguments)
			else
				context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE)")
			end

			context.add_string ("%N%T%T%T-- Wrapper for parent creation procedure `" + featr.feature_name + "'.%N%T%T")
			context.add_string ("%N%T%Tdo")
			context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, ")
			context.add_string ("agent effective_" + featr.feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if featr.arguments /= void then
				process_formal_arguments_as_actual_arguments (featr.arguments, False)
			end
			context.add_string (")")
			context.add_string ("%N%T%Tend")

			-- 'effective_feature_name_scoop_separate_class_name'
			context.add_string ("%N%N%Teffective_" + featr.feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if featr.arguments /= void then
				process_flattened_formal_arguments (featr.arguments, False)
			end
			context.add_string ("%N%T%T%T-- Wrapper for creation procedure `" + featr.feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%Tcreate implementation_." + featr.feature_name)
			context.add_string (" ")
			if featr.arguments /= void then
				process_formal_arguments_as_actual_arguments (featr.arguments, False)
			end
			context.add_string ("%N%T%Tend")
		end



	process_auxiliary_local_variables (a_feature: FEATURE_AS; a_feature_name: STRING): BOOLEAN is
		-- Generate auxiliary local variables for formal arguments.
		-- Generate conversion code for auxiliary variables.
		-- Return `True' if lock passing might occur (original feature takes separate formal arguments).
		local
			l_arguments: FORMAL_ARGU_DEC_LIST_AS
			l_argument: TYPE_DEC_AS
			l_argument_name: STRING
			l_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			i, j, nb, nbj: INTEGER
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
			l_type_expr_visitor: SCOOP_TYPE_EXPR_VISITOR
			l_type_a: TYPE_A
			l_class_as: CLASS_AS
			generic_position, x: INTEGER
			l_assign_finder: SCOOP_PROXY_ASSIGN_FINDER
			l_feature_name,feature_name: FEATURE_NAME
			generics_to_substitute: LINKED_LIST[TUPLE[INTEGER,INTEGER]]
			internal_argument:TUPLE[pos:INTEGER;type:TYPE_AS]
			l_index,pos: INTEGER
			l_id_as:ID_AS
			l_leaf: LEAF_AS
		do
			l_arguments := a_feature.body.internal_arguments
			create l_type_visitor

			-- Does original feature take any separate arguments?
			if l_arguments /= Void and then l_arguments.arguments /= Void then
				from
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					a_class_c := l_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						if l_type_visitor.is_separate then
							Result := True
						end
					end

					i := i + 1
				end
			end

			-- add local variables
			context.add_string ("%N%T%Tlocal")
			-- Get Feature name object
			from
				i := 1
				nb := a_feature.feature_names.count
			until
				i > nb
			loop
				l_feature_name := a_feature.feature_names.i_th (i)
				if l_feature_name.visual_name.is_equal (a_feature.feature_name.name) then
					feature_name := l_feature_name
				end
				i := i+1
			end
			if a_feature.is_function then
				context.add_string ("%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
				if a_feature.body.type /= void then
					-- Fix for redeclarations if feature is query type:
					-- If `l_as.type' is non separate but was separate in an ancestor version we need to make it separate
					-- Only a potential problem when return type is `non-separate' and a `CLASS_TYPE_AS'

					if attached {CLASS_TYPE_AS} a_feature.body.type as typ then
						create l_assign_finder
						if not typ.is_separate then
							if l_assign_finder.have_to_replace_return_type(feature_name, class_c, true) then
								context.add_string ({SCOOP_SYSTEM_CONSTANTS}.scoop_proxy_class_prefix+typ.class_name.name)
								add_result_substitution := true -- Remember we added the substitution so we dont add `proxy_' later					
							else
								-- No substitution needed, print normaly
								context.add_string (typ.class_name.name)
							end
						else
							-- Separate: No substitution needed, print normaly
							context.add_string ({SCOOP_SYSTEM_CONSTANTS}.scoop_proxy_class_prefix+typ.class_name.name)
						end
					else
						-- Nothing was done, no generics -> process normally
						l_type_locals.process_type (a_feature.body.type)
					end

					-- Print generics and check if they need a substitution
					if attached {GENERIC_CLASS_TYPE_AS}  a_feature.body.type as gen_typ then
							create l_assign_finder
							l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
							generics_to_substitute := l_assign_finder.generic_parameters_to_replace (feature_name, class_c, False, Void, True)
							if not generics_to_substitute.is_empty then
								l_generics_visitor.set_generics_to_substitute (generics_to_substitute)
							end
							l_generics_visitor.process_internal_generics (gen_typ.generics, True, True)


						--	last_index := l_generics_visitor.get_last_index
					end
					last_index := a_feature.body.type.last_token (match_list).index
				end
--				if not add_result_substitution then
--					-- Nothing was done -> process normally
--					l_type_locals.process_type (a_feature.body.type)
--				end
			--	l_type_locals.process_type (a_feature.body.type)
				context.add_string ("]")
			end

			if l_arguments /= Void and then l_arguments.arguments /= Void then
				-- create feature name visitor
				l_feature_name_visitor := scoop_visitor_factory.new_feature_name_visitor

				-- iterate over internal arguments to add for each a new local variable
				from
					pos :=1
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					l_argument := l_arguments.arguments.i_th (i)
					a_class_c := l_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						context.add_string ("%N%T%T%T")

						-- add feature names with prefix `aux_scoop_'
						from

							l_argument.id_list.id_list.start
							create l_id_as.initialize_from_id (1)
						until
							l_argument.id_list.id_list.after
						loop
							context.add_string ("aux_scoop_")
							l_index := l_argument.id_list.id_list.item
							if match_list.valid_index (l_index) then
								l_leaf := match_list.i_th (l_index)
									-- Note that we do not set the `name_id' for `l_id_as' since it will require
									-- updating the NAMES_HEAP and we do not want to do that. It is assumed in roundtrip
									-- mode that the text is never obtained from the node itself but from the `text' queries.
								l_id_as.set_position (l_leaf.line, l_leaf.column, l_leaf.position, l_leaf.location_count)
								l_id_as.set_index (l_index)
								last_index := l_id_as.first_token (match_list).index
								safe_process (l_id_as)
							end

							--l_feature_name_visitor.process_id_list (l_list, "aux_scoop_")
							context.add_string (l_feature_name_visitor.feature_name)

							context.add_string (": ")
							-- process normal type

							if l_type_visitor.is_a_like_type then
								if attached {LIKE_ID_AS} l_argument.type as typ then
									-- like something -> evaluate something
									l_type_expr_visitor := scoop_visitor_factory.new_type_expr_visitor
									l_type_expr_visitor.resolve_type_in_class (l_argument.type, class_c)
									l_type_a := l_type_expr_visitor.resolved_type

									if l_type_a.has_generics then
										-- get class_as from the evaluated class_a name (needs parsing because name comes with generics)
										context.add_string (l_type_a.name.substring (1, l_type_a.name.index_of ('[', 1)-2))
										l_class_as := class_as_by_name (l_type_a.name.substring (1, l_type_a.name.index_of ('[', 1)-2))
	--									l_class_as := class_as
										context.add_string ("[")
										from
											x := 1
										until
											x > l_type_a.generic_derivation.generics.count
										loop
											if x /= 1 then
												context.add_string (", ")
											end
											if l_type_a.generic_derivation.generics.item (x).is_formal then
												-- generic is formal, get the formal genetics from the actual class
												generic_position := l_type_a.generic_derivation.generics.item (x).name.substring (l_type_a.generic_derivation.generics.item (x).name.index_of ('#', 1)+1, l_type_a.generic_derivation.generics.item (x).name.count).to_integer
												context.add_string (l_class_as.generics.i_th (generic_position).name.name)
											else
												-- non formal free to print
												context.add_string (l_type_a.generic_derivation.generics.item (x).name)
											end
											x := x+1
										end
										context.add_string ("]")
									else
										-- no generics in the evaluated type
										context.add_string (l_type_a.name)
									end
								elseif attached {LIKE_CUR_AS} l_argument.type as typ then
									-- like current -> print currenr class signature
									context.add_string (class_as.class_name.name)
									if class_as.generics /= void then
										l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
										l_generics_visitor.process_class_internal_generics (class_as.generics, True, True)
										last_index := l_generics_visitor.get_last_index
									end
								end

							else
								if attached {GENERIC_CLASS_TYPE_AS} l_argument.type as gen_typ then
									create l_assign_finder
									create internal_argument.default_create
									internal_argument.pos := pos
									internal_argument.type := gen_typ
									generics_to_substitute := l_assign_finder.generic_parameters_to_replace (feature_name, class_c, False, internal_argument, False)
									if not generics_to_substitute.is_empty then
										l_type_locals.set_generics_to_substitute (generics_to_substitute)
									end
								end
								l_type_locals.process_type (l_argument.type)
							end
							l_argument.id_list.id_list.forth
							pos := pos +1;
							if not l_argument.id_list.id_list.after then
							context.add_string ("%N%T%T%T")
						end
					end
					last_index := l_argument.last_token (match_list).index
---------------------------------------

					end
					i := i + 1
				end

				if Result then
					context.add_string ("%N%T%T%Tscoop_passing_locks: BOOLEAN%N%T%T%Tscoop_locked_processors_stack_size, scoop_synchronous_processors_stack_size: INTEGER_32")
				end

				-- add do keyword
				context.add_string ("%N%T%Tdo")

				-- conversion code
				from
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					l_argument := l_arguments.arguments.i_th (i)
					a_class_c := l_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						if l_type_visitor.is_class_type then
							if l_type_visitor.is_separate then

								from
									j := 1
									nbj := l_argument.id_list.count
								until
									j > nbj
								loop
									l_argument_name := l_argument.item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name)
									context.add_string (" /= void and then (" + l_argument_name)
									context.add_string (".processor_ /= void) then%N%T%T%T%T")
									context.add_string ("aux_scoop_" + l_argument_name + " := " + l_argument_name)
									context.add_string ("%N%T%T%T%Tif aux_scoop_" + l_argument_name + ".processor_ = void then ")
									context.add_string ("aux_scoop_" + l_argument_name + ".set_processor_ (a_caller_.processor_) end")
									context.add_string ("%N%T%T%T%Tif a_caller_.processor_.locked_processors_has (aux_scoop_" + l_argument_name + ".processor_) then ")
									context.add_string ("scoop_passing_locks := True end%N%T%T%Tend")
									j := j + 1
								end
							else
									-- Non-separate type in the original feature.
								from
									j := 1
									nbj := l_argument.id_list.count
								until
									j > nbj
								loop
									l_argument_name := l_argument.item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name + " /= void then ")
									context.add_string ("%N%T%T%T%Taux_scoop_" + l_argument_name + " := ")
									context.add_string (l_argument_name + "%N%T%T%Tend")
									j := j + 1
								end
							end
						elseif l_type_visitor.is_a_like_type or l_type_visitor.is_tuple_type then
								-- Tuple type or a like type.
							from
								j := 1
								nbj := l_argument.id_list.count
							until
								j > nbj
							loop
								l_argument_name := l_argument.item_name (j)

								context.add_string ("%N%T%T%Taux_scoop_" + l_argument_name + " := ")
								context.add_string (l_argument_name)
								j := j + 1
							end
						end
					end

					i := i + 1
				end
			else
				-- add do keyword
				context.add_string ("%N%T%Tdo")
			end

			Result := Result -- and not is_lock_passing_ignored
		end

--	process_formal_arguments_with_auxiliary_variables (a_args: FEAT_ARG; with_a_caller, with_brackets: BOOLEAN) is
--			-- Process `a_list' as list of actual arguments. Substitute original arguments with auxiliary variables where necessary.
--			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
--			-- Addes brackets before and after the list if desired.
--		local
--			i : INTEGER
--			t : TYPE_A
--			a_prefix: STRING
--		do
--			if with_brackets then
--				context.add_string ("(")
--			end

--			if with_a_caller then
--				context.add_string ("a_caller_, ")
--			end

--			from
--				i := 1

--			until
--				i > a_args.count
--			loop
--				t := a_args [i]

--				if not t.is_formal and then not t.is_expanded and then
--				   not t.is_tuple then
--					a_prefix := "aux_scoop_"
--				else
--					a_prefix := ""
--				end

--				context.add_string (", ")
--				context.add_string (a_prefix + arg_number_name (i))

--				i := i + 1
--			end

--			if with_brackets then
--				context.add_string (")")
--			end
--		end

	process_formal_argument_list_with_auxiliary_variables (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller, with_brackets: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments. Substitute original arguments with auxiliary variables where necessary.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
			-- Addes brackets before and after the list if desired.
		local
			i, j, nbi, nbj: INTEGER
			l_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			a_prefix: STRING
			l_type_dec_as: TYPE_DEC_AS
			add_proxy_,add_implementation_: BOOLEAN
		do
			if with_brackets then
				context.add_string ("(")
			end

			create l_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			if a_list.arguments /= Void then
				from
					i := 1
					nbi := a_list.arguments.count
				until
					i > nbi
				loop
					l_type_dec_as := a_list.arguments.i_th (i)
					a_class_c := l_type_visitor.evaluate_class_from_type (l_type_dec_as.type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						create a_prefix.make_from_string ("aux_scoop_")
						if attached {LIKE_ID_AS} l_type_dec_as.type  then
							-- `like item' was evaluated and converted to non separate, need to reconvert -> add `proxy_'
							add_proxy_ := true
						end
						if attached {CLASS_TYPE_AS} l_type_dec_as.type then
							if feature_object /= void and then feature_object.is_internal_arguments_to_substitute_defined then
								-- Check if we need to substitute internal arguments
								add_implementation_ := true
							end
						end
					else
						create a_prefix.make_empty
					end

					from
						j := 1
						nbj := l_type_dec_as.id_list.count
					until
						j > nbj
					loop
						context.add_string (a_prefix + l_type_dec_as.item_name (j))
						if add_proxy_ and is_like_item_proxy then
							-- `like item' was created and converted to non separate, need to reconvert -> add `proxy_'
							context.add_string ("."+{SCOOP_SYSTEM_CONSTANTS}.proxy_conversion_feature_name)
							add_proxy_ := false
						end
						if add_implementation_ then
							from
								feature_object.internal_arguments_to_substitute.start
							until
								feature_object.internal_arguments_to_substitute.after
							loop
								if feature_object.internal_arguments_to_substitute.item.is_equal (l_type_dec_as.id_list.i_th (j)) then
									context.add_string ("."+{SCOOP_SYSTEM_CONSTANTS}.scoop_client_implementation)
								end
								feature_object.internal_arguments_to_substitute.forth

							end
						end
						if i < nbi or (i = nbi and j < nbj) then
							context.add_string (", ")
						end

						j := j + 1
					end

					i := i + 1
				end
			end
			if with_brackets then
				context.add_string (")")
			end
		end

	process_flattened_formal_arguments (a_args: FEAT_ARG; with_a_caller: BOOLEAN) is
			-- Process `a_list'. Substitute anchored types with flattened types.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i : INTEGER
		do
			context.add_string ("(")

			if with_a_caller then
				context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")
			end

			from
				i := 1
			until
				i > a_args.count
			loop
				context.add_string (arg_number_name (i) + ": " +  separate_type_string (a_args[i]))

				if i /= a_args.count then
					context.add_string (";")
				end

				i := i + 1
			end
			context.add_string (")")
		end

	process_flattened_formal_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list'. Substitute anchored types with flattened types.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j, nbj: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_argument: TYPE_DEC_AS
			a_class_c: CLASS_C
			l_proxy_type_visitor: SCOOP_PROXY_TYPE_VISITOR
		do
			create l_scoop_type_visitor

			context.add_string ("(")
			if with_a_caller then
				context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")
				l_proxy_type_visitor := l_type_signature
			else
				l_proxy_type_visitor := l_type_locals
			end

			from
				i := 1
				nb := a_list.arguments.count
			until
				i > nb
			loop
				l_argument := a_list.arguments.i_th (i)
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

				from
					j := 1
					nbj := l_argument.id_list.count
				until
					j > nbj
				loop
					context.add_string (l_argument.item_name (j) + ": ")
					l_proxy_type_visitor.process_type (l_argument.type)

					if i < nb or (i = nb and j < l_argument.id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_arguments_as_actual_arguments (a_args: FEAT_ARG; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i : INTEGER
		do
			context.add_string ("(")

			if with_a_caller then
				context.add_string ("a_caller_")
			end

			from
				i := 1
			until
				i > a_args.count
			loop
				context.add_string (arg_number_name (i))

				if i /= a_args.count then
					context.add_string (",")
				end

				i := i + 1
			end

			context.add_string (")")
		end

	process_formal_argument_list_as_actual_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j, nbj: INTEGER
			l_argument: TYPE_DEC_AS
		do
			context.add_string ("(")

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
				nb := a_list.arguments.count
			until
				i > nb
			loop
				l_argument := a_list.arguments.i_th (i)
				from
					j := 1
					nbj := l_argument.id_list.count
				until
					j > nbj
				loop
					context.add_string (l_argument.item_name (j))
					if i < nb or (i = nb and j < l_argument.id_list.count) then
						context.add_string (", ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_arguments_with_caller  (a_args: FEAT_ARG)
			-- Process `a_list'.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument.
		local
			i : INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			create l_scoop_type_visitor

			context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE ")

			from
				i  := 1
			until
				i > a_args.count
			loop
				context.add_string ("; " + arg_number_name (i) + ": " + separate_type_string (a_args [i]))
				i := i + 1
			end

			context.add_string (")")
		end

	separate_type_string (a : TYPE_A) : STRING
			-- ...
		do
			Result := ""

			if a.is_separate then
				Result := Result + "SCOOP_SEPARATE__"
			end

			Result := Result + a.associated_class.name_in_upper
			  -- FIXME: I'm not sure if this is the proper way to rip off the
			  -- `separate' tag from the type. I'm not sure what it does for generics.
		end

	arg_number_name (i : INTEGER) : STRING
			-- ...
		do
			Result := "arg___" + i.out
		end

	process_formal_argument_list_with_a_caller  (a_list: FORMAL_ARGU_DEC_LIST_AS) is
			-- Process `a_list'.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument.
		local
			pos,i, j, nb, nbj: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			l_argument: TYPE_DEC_AS
			l_assign_finder: SCOOP_PROXY_ASSIGN_FINDER
			generics_to_substitute: LINKED_LIST[TUPLE[INTEGER,INTEGER]]
			interal_argument_to_substitute: TUPLE[pos:INTEGER;type:TYPE_AS]
			feature_name: FEATURE_NAME
		do
			create l_scoop_type_visitor

			context.add_string ("(")
			context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")

			if a_list.arguments /= Void then
				pos := 1 -- # of argument
				from
					i := 1
					nb := a_list.arguments.count
				until
					i > nb
				loop
					l_argument := a_list.arguments.i_th (i)
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

					from
						j := 1
						nbj := l_argument.id_list.count
					until
						j > nbj
					loop
						context.add_string (l_argument.item_name (j) + ": ")
						if attached {GENERIC_CLASS_TYPE_AS}  l_argument.type as gen_typ then
							create l_assign_finder
							create interal_argument_to_substitute.default_create
							interal_argument_to_substitute.pos := pos
							interal_argument_to_substitute.type := gen_typ
							if feature_as /= void then
								from
									feature_as.feature_names.start
								until
									feature_as.feature_names.after
								loop
									if feature_as.feature_names.item.visual_name.is_equal (feature_as.feature_name.name) then
										feature_name := feature_as.feature_names.item
									end
									feature_as.feature_names.forth
								end
								generics_to_substitute := l_assign_finder.generic_parameters_to_replace (feature_name, class_c, False, interal_argument_to_substitute, False)
								if not generics_to_substitute.is_empty then
									l_type_signature.set_generics_to_substitute (generics_to_substitute)
								end
							end
						end
						l_type_signature.process_type (l_argument.type)
						if attached {CLASS_TYPE_AS} l_argument.type as typ then
							if typ.is_separate then
								if feature_as /= void then
									if need_internal_argument_substitution(feature_as.feature_name, class_c, pos) then
										feature_object.internal_arguments_to_substitute.append (l_argument.id_list)
									end
								end
							debug
								end
							end
						end
						pos := pos +1
						if i < nb or (i = nb and j < l_argument.id_list.count) then
							context.add_string ("; ")
						end
						j := j + 1
					end
					i := i + 1
				end
			end
			context.add_string (")")
			last_index := a_list.last_token (match_list).index
		end

feature {NONE} -- Redeclaration Implementation

need_internal_argument_substitution(a_feature_name: ID_AS; a_class_c: CLASS_C; arg_pos: INTEGER):BOOLEAN is
			-- Do we need a redeclaration substitution for internal arguments?
			-- Needed when current argument is separate and parent version was non separate
			local
				l_assign_finder: SCOOP_PROXY_ASSIGN_FINDER
				feature_i: FEATURE_I
				l_feature_name: FEATURE_NAME
				has_context: BOOLEAN
			do
				create l_assign_finder
				feature_i := a_class_c.feature_named (a_feature_name.name)
				if feature_i /= Void then
					from
						feature_i.body.feature_names.start
					until
						feature_i.body.feature_names.after
					loop
						if feature_i.body.feature_names.item.visual_name.is_equal (a_feature_name.name) then
							l_feature_name := feature_i.body.feature_names.item
						end
						feature_i.body.feature_names.forth
					end
					if a_class_c = class_c then
						has_context := true
					end
					if a_feature_name /= void and then l_assign_finder.have_to_replace_internal_arguments (l_feature_name, a_class_c, arg_pos, has_context) then
						Result := True
					end
				end
			end

feature {NONE} -- SCOOP Implementation

	process_lock_passing_before is
			-- Generate code for lock passing.
		do
			context.add_string ("%N%T%T%Tif scoop_passing_locks then")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.increment_lock_passing_counter")
			context.add_string ("%N%T%T%T%Tscoop_locked_processors_stack_size := processor_.locked_processors_count")
			context.add_string ("%N%T%T%T%Tscoop_synchronous_processors_stack_size := processor_.synchronous_processors_count")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_push_whole_stack (a_caller_.processor_.locked_processors)")
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_push_whole_stack (a_caller_.processor_.synchronous_processors)")
		end

	process_lock_passing_after is
			-- Generate code for cleanup after lock passing.
		do
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_trim (scoop_synchronous_processors_stack_size)")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_trim (scoop_locked_processors_stack_size)")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.decrement_lock_passing_counter")			
			context.add_string ("%N%T%T%Telse")
		end

feature{NONE} -- Implementation



	add_result_substitution: BOOLEAN
			-- Is the result type of the feature beeing changed from non separate to separate?
			-- Is the case when a feature with non separate return type has a parent feature redeclaration with separate return type.

	is_like_item_proxy : BOOLEAN
			-- Is `like item' a reference to a `proxy_' object?
			-- Used to determine if we have to add `proxy_' to the feature call

	l_type_signature: SCOOP_PROXY_TYPE_SIGNATURE_PRINTER
			-- prints 'TYPE_AS' to the context

	l_type_locals: SCOOP_PROXY_TYPE_LOCALS_PRINTER
			-- prints 'TYPE_AS' to the context

;note
	copyright:	"Copyright (c) 1984-2010, Chair of Software Engineering"
	license:	"GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options:	"http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			ETH Zurich
			Chair of Software Engineering
			Website http://se.inf.ethz.ch/
		]"

 end -- class SCOOP_SEPARATE_PROXY_PRINTER

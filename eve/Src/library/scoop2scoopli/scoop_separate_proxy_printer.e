indexing
	description: "Summary description for {SCOOP_SEPARATE_PROXY_PRINTER}. "
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SCOOP_SEPARATE_PROXY_PRINTER

inherit
	SCOOP_CONTEXT_AST_PRINTER
		export
			{NONE} all
			{SCOOP_VISITOR_FACTORY} setup
			{DEGREE_SCOOP} get_context
		redefine
			process_class_as,
			process_feature_clause_as,
			process_feature_as,
			process_class_type_as,
			process_generic_class_type_as,
			process_named_tuple_type_as,
			process_type_dec_as,
			process_class_list_as,
			process_create_as,
			process_like_cur_as,
			process_keyword_as,
			process_invariant_as
		end

	SCOOP_WORKBENCH
		export
			{NONE} all
		end

	SCOOP_CLASS_NAME
		export
			{NONE} all
		end

create
	make,
	make_with_default_context

feature {NONE} -- Initialization

	make (a_ctxt: ROUNDTRIP_CONTEXT)  is
			-- Initialize and set `context' with `a_ctxt'.
		require
			a_ctxt_not_void: a_ctxt /= Void
		do
			context := a_ctxt
		end

	make_with_default_context is
			-- Initialize and create context of type `ROUNDTRIP_STRING_LIST_CONTEXT'.
		do
			make (create {ROUNDTRIP_STRING_LIST_CONTEXT}.make)
		end

feature -- Access

	process is
			-- Process 'a_class_c'.
		do
			-- init
			l_type_signature := scoop_visitor_factory.new_proxy_type_signature_printer (context)
			l_type_locals := scoop_visitor_factory.new_proxy_type_local_printer (context)

			process_class_as (class_as)
		end

feature {NONE} -- Roundtrip: process nodes

	process_class_as (l_as: CLASS_AS) is
			-- Process `l_as'.
		require else
			class_as_not_void: class_as /= Void
			class_c_not_void: class_c /= Void
		local
			s: STRING_AS
			l_parent_visitor: SCOOP_PROXY_PARENT_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			if class_c.name_in_upper.starts_with ("INTEGER_INTERVAL") then
				io.put_string ("INTEGER_INTERVAL")
			end


			context.add_string ("-- This class has been generated by SCOOP2SCOOPLI")
			context.add_string ("%N-- It implements separate proxies for objects based on class " + class_as.class_name.name + "%N%N")

			-- since we produce only override classes we skip the indexing part
			-- safe_process (l_as.internal_top_indexes)
			if l_as.internal_top_indexes /= Void then
				last_index := l_as.internal_top_indexes.end_position
			end

			safe_process (l_as.frozen_keyword (match_list))
			safe_process (l_as.deferred_keyword (match_list))

			-- if class is expanded -> deferred.
			if l_as.is_expanded then
				process_leading_leaves (l_as.expanded_keyword_index)
				context.add_string ("deferred ")
			end

			safe_process (l_as.external_keyword (match_list))
			safe_process (l_as.class_keyword (match_list))
			process_leading_leaves (l_as.class_name.index)
			process_class_name (l_as.class_name, true, context, match_list)
			if l_as.class_name /= Void then
				last_index := l_as.class_name.end_position
			end

			-- process internal generics
			if l_as.internal_generics /= Void then
				process_leading_leaves (l_as.internal_generics.index)
				l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
				l_generics_visitor.process_class_internal_generics (l_as.internal_generics, true, false)
				last_index := l_generics_visitor.get_last_index
			end

			safe_process (l_as.alias_keyword (match_list))
			s ?= l_as.external_class_name
			safe_process (s)
			safe_process (l_as.obsolete_keyword (match_list))
			safe_process (l_as.obsolete_message)

			-- process parents.
			l_parent_visitor := scoop_visitor_factory.new_proxy_parent_visitor (context)
			l_parent_visitor.process_internal_conforming_parents (l_as.internal_conforming_parents)
			l_parent_visitor.process_internal_non_conforming_parents (l_as.internal_non_conforming_parents)
			if l_as.conforming_parents /= Void or l_as.non_conforming_parents /= Void then
				last_index := l_parent_visitor.get_last_index
			end

			process_creators_and_conversions (l_as.creators)

			-- process features.
			safe_process (l_as.features)

			-- add SCOOP feature: reference to client object.
			context.add_string ("%N%Nfeature -- Separateness")
			-- add attribute of actual object
			context.add_string ("%N%N%Timplementation_: " + l_as.class_name.name.as_upper)
			-- formal paramters
			if l_as.internal_generics /= Void then
				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, true, true)
			end
			context.add_string ("%N%T%T-- reference to actual object")

			-- add SCOOP feature: wrappers for creation features.
			if not l_as.is_deferred or l_as.is_expanded then
				context.add_string ("%N%Nfeature -- Creation Wrappers%N")
				if l_as.creators /= Void then
					last_index := l_as.creators.index - 1
					safe_process (l_as.creators)
				else
					process_default_create_wrappers
				end
			end

			-- process invariants (skip it - see `process_invariant_as')
--			if l_as.internal_invariant /= Void then
--				last_index := l_as.internal_invariant.invariant_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_invariant)
--			end

			-- process indexes
			-- since we produce only override classes we skip the indexing part
--			if l_as.internal_bottom_indexes /= Void then
--				last_index := l_as.internal_bottom_indexes.indexing_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_bottom_indexes)
--			end

				-- add end keyword.
			context.add_string ("%N%Nend%N")
		end

	process_feature_clause_as (l_as: FEATURE_CLAUSE_AS) is
		do
			last_index := l_as.start_position
			context.add_string ("%N%N")
			safe_process (l_as.feature_keyword)
			safe_process (l_as.clients)
			safe_process (l_as.features)
		end

	process_feature_as (l_as: FEATURE_AS) is
		local
			l_feature_visitor: SCOOP_PROXY_FEATURE_VISITOR
		do
			process_leading_leaves (l_as.feature_names.index)

			l_feature_visitor := scoop_visitor_factory.new_proxy_feature_visitor (context)
			l_feature_visitor.process_feature(l_as)
			last_index := l_as.end_position
		end

	process_class_type_as (l_as: CLASS_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_generic_class_type_as (l_as: GENERIC_CLASS_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_named_tuple_type_as (l_as: NAMED_TUPLE_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_create_as (l_as: CREATE_AS) is
		local
			i, nb: INTEGER
			l_is_creator_default_create: BOOLEAN
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_feature_name: STRING
		do
			if l_as.feature_list /= Void then
				l_feature_name_visitor := scoop_visitor_factory.new_feature_name_visitor

				from
					i := 1
					nb := l_as.feature_list.count
				until
					i > nb
				loop
					l_feature_name_visitor.process_feature_name (l_as.feature_list.i_th (i), false)
					l_feature_name := l_feature_name_visitor.get_feature_name

					if l_feature_name.is_equal ("default_create") then
						l_is_creator_default_create := true
					else
						process_creation_procedure_wrappers (l_feature_name)
					end
					i := i + 1
				end

				if l_is_creator_default_create then
					process_default_create_wrappers
				end
			end
		end

	process_like_cur_as (l_as: LIKE_CUR_AS) is
			-- process 'l_as'
		do
			context.add_string ("?????????")
		end

	process_type_dec_as (l_as: TYPE_DEC_AS) is
			-- process 'l_as' - internal argument list
		do
			process_identifier_list (l_as.id_list)
			safe_process (l_as.colon_symbol (match_list))
			-- process type
			l_type_signature.process_type (l_as.type)
		end

	process_class_list_as (l_as: CLASS_LIST_AS) is
			-- Process `l_as'.
			-- If a class name (other than ANY or NONE) appears in the list, add its separate proxy as well.
		do
			safe_process (l_as.lcurly_symbol (match_list))

			-- add class names with prefix
			if l_as /= Void then
				process_class_name_list_with_prefix (l_as, true, context, match_list)
			end
			last_index := l_as.rcurly_symbol_index - 1
			safe_process (l_as.rcurly_symbol (match_list))
		end

	process_keyword_as (l_as: KEYWORD_AS) is
			-- Process `l_as'.
		do
			if l_as.is_separate_keyword then
				-- skip	
				last_index := l_as.index
			elseif l_as.is_frozen_keyword then
				Precursor (l_as)
				-- add a space
				context.add_string (" ")
			elseif l_as.is_prefix_keyword or l_as.is_infix_keyword then
				-- skip	
				Precursor (l_as)
				context.add_string ("_")
			else
				Precursor (l_as)
			end
		end

	process_invariant_as (l_as: INVARIANT_AS) is
		do
			-- skip it
			if l_as.full_assertion_list /= Void then
				last_index := l_as.end_position
			end
		end

feature {NONE} -- Roundtrip: implementation

	process_creators_and_conversions (l_as: EIFFEL_LIST [CREATE_AS]) is
			-- Process creators and convertors
		local
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- creator & convertor
			if not class_as.is_deferred then
				-- creator
				context.add_string ("%N%Ncreate%N%Tmake_from_local, set_processor_")

				-- convertor
				context.add_string ("%N%Nconvert%N%Tmake_from_local ({" + class_as.class_name.name.as_upper)

				-- formal paramters
				l_generics_visitor := scoop_visitor_factory.new_generics_visitor (context)
				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, true, true)

				-- convertor end
				context.add_string ("})")
			end

			-- skip original creators and convertors
			if class_as.creators /= Void or class_as.convertors /= Void then
				if class_as.features /= Void then
					last_index := class_as.features.index - 1
				elseif class_as.internal_invariant /= Void then
					last_index := class_as.internal_invariant.start_position - 1
				elseif class_as.internal_bottom_indexes /= Void then
					last_index := class_as.internal_bottom_indexes.index -1
				else
					last_index := class_as.end_keyword.index - 1
				end
			end

			-- wrapping creation instruciton
			if not class_as.is_deferred and then class_as.is_expanded then
				if class_as.creators /= Void then
					safe_process (class_as.creators)
				else
					process_default_create_wrappers
				end
			end
		end

	process_default_create_wrappers is
			-- Generate two additional procedures
			-- 'default_create_scoop_separate_class_name' and 'effective_default_create_scoop_separate_class_name'
			-- for wrapping creation instructions.
		do
			-- 'default_create_scoop_separate_class_name'
			context.add_string ("%N%Nfeature -- default creation instruction wrapper")
			context.add_string ("%N%N%Tdefault_create_scoop_separate_")
			context.add_string (class_as.class_name.name.as_lower)
			context.add_string (" (a_caller_: SCOOP_SEPARATE_CLIENT)")
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for creation procedure `default_create'.%N%T%T")
			context.add_string ("%N%T%Tdo")

			context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_default_create_scoop_separate_" + class_as.class_name.name.as_lower)
			context.add_string (")%N%T%Tend")

			-- 'effective_default_create_scoop_separate_class_name'
			context.add_string ("%N%N%Teffective_default_create_scoop_separate_" + class_as.class_name.name.as_lower + " is")
			context.add_string ("%N%T%T%T-- Wrapper for creation procedure `default_create'.")
			context.add_string ("%N%T%Tdo")
			if not class_as.class_name.name.as_upper.is_equal ("METHOD_BAS") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_STRING") or else
				class_as.class_name.name.as_upper.is_equal ("STRING_BUILDER") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_ARRAY") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_OBJECT")
			then
				context.add_string ("%N%T%T%Tcreate implementation_")
			end
			context.add_string ("%N%T%Tend%N")
		end

	process_creation_procedure_wrappers (a_feature_name: STRING) is
			-- Generate two additional procedures
			-- 'feature_name_scoop_separate_class_name' and 'effective_feature_name_scoop_separate_class_name'
			-- for wrapping creation instructions.
		local
			l_feature_i: FEATURE_I
			l_feature_as: FEATURE_AS
			lock_passing_possible: BOOLEAN
		do
				-- get feature
			if class_as.feature_table.has (a_feature_name) then
				l_feature_i := class_as.feature_table.item (a_feature_name)
			end

				-- only handle if not inherited.
			if l_feature_i.written_class.name_in_upper.is_equal (class_as.class_name.name.as_upper) then

				context.add_string ("%N%Nfeature -- creation instruction wrapper")

				l_feature_as := l_feature_i.body

				if l_feature_as /= Void and l_feature_as.body /= Void then

					context.add_string ("%N%N%T" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
					if l_feature_as.body.internal_arguments /= Void then
						-- print type with prefix
						last_index := l_feature_as.body.internal_arguments.start_position
						process_formal_argument_list_with_a_caller (l_feature_as.body.internal_arguments)
					--	safe_process (l_feature_as.body.internal_arguments)
					--	last_index := l_feature_as.body.internal_arguments.end_position
					else
						context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE) ") --CLIENT) ")
					end

					context.add_string (" is%N%T%T%T")
					context.add_string ("-- Wrapper for creation procedure `" + a_feature_name + "'.%N%T%T")

					if l_feature_as.body.internal_arguments /= Void then
						lock_passing_possible := process_auxiliary_local_variables (l_feature_as, a_feature_name)
					else
						context.add_string ("%N%T%Tdo")
					end

					if lock_passing_possible then
						process_lock_passing_before
						context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
						process_lock_passing_after
						context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
						context.add_string ("%N%T%T%Tend")
					else
						context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
					end
					context.add_string ("%N%T%Tend")
				end

					-- 'effective_feature_name_scoop_separate_class_name'
				context.add_string ("%N%N%Teffective_" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
				if l_feature_as.body.internal_arguments /= Void then
					process_flattened_formal_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string (" is")
				context.add_string ("%N%T%T%T-- Wrapper for creation procedure `" + a_feature_name + "'.")
				context.add_string ("%N%T%Tdo%N%T%T%Tcreate implementation_." + a_feature_name)
				if l_feature_as.body.internal_arguments /= Void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string ("%N%T%Tend")
			end
		end

	process_auxiliary_local_variables (a_feature: FEATURE_AS; a_feature_name: STRING): BOOLEAN is
		-- Generate auxiliary local variables for formal arguments.
		-- Generate conversion code for auxiliary variables.
		-- Return `true' if lock passing might occur (original feature takes separate formal arguments).
		local
			l_arguments: FORMAL_ARGU_DEC_LIST_AS
			l_argument: TYPE_DEC_AS
			l_argument_name: STRING
			l_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			i, j, nb, nbj: INTEGER
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
		do
			l_arguments := a_feature.body.internal_arguments
			create l_type_visitor

			-- Does original feature take any separate arguments?
			if l_arguments /= Void then
				from
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					a_class_c := l_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						if l_type_visitor.is_separate then
							Result := True
						end
					end

					i := i + 1
				end
			end

			-- add local variables
			context.add_string ("%N%T%Tlocal")
			if a_feature.is_function then
				context.add_string ("%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
		--		process_result_type (a_feature.body.type, false, l_type_locals)
				l_type_locals.process_type (a_feature.body.type)
		--		l_type_signature.process_type (a_feature.body.type)
				context.add_string ("]")
			end

			if l_arguments /= Void then
				-- create feature name visitor
				l_feature_name_visitor := scoop_visitor_factory.new_feature_name_visitor

				-- iterate over internal arguments to add for each a new local variable
				from
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					l_argument := l_arguments.arguments.i_th (i)
					a_class_c := l_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						context.add_string ("%N%T%T%T")

						-- add feature names with prefix `aux_scoop_'
						l_feature_name_visitor.process_id_list (l_argument.id_list, "aux_scoop_")
						context.add_string (l_feature_name_visitor.get_feature_name)

						context.add_string (": ")
						-- process normal type
						l_type_locals.process_type (l_argument.type)
					end
					i := i + 1
				end

				if Result then
					context.add_string ("%N%T%T%Tscoop_passing_locks: BOOLEAN%N%T%T%Tscoop_locked_processors_stack_size, scoop_synchronous_processors_stack_size: INTEGER_32")
				end

				-- do keyword
				context.add_string ("%N%T%Tdo")

				-- Conversion code
				from
					i := 1
					nb := l_arguments.arguments.count
				until
					i > nb
				loop
					l_argument := l_arguments.arguments.i_th (i)
					a_class_c := l_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

					if not l_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_type_visitor.is_tuple_type then

						if l_type_visitor.is_class_type then
							if l_type_visitor.is_separate then

								from
									j := 1
									nbj := l_argument.id_list.count
								until
									j > nbj
								loop
									l_argument_name := l_argument.item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name)
									context.add_string (" /= void and then (" + l_argument_name)
									context.add_string (".processor_ /= void) then%N%T%T%T%T")
									context.add_string ("aux_scoop_" + l_argument_name + " := " + l_argument_name)
									context.add_string ("%N%T%T%T%Tif aux_scoop_" + l_argument_name + ".processor_ = void then ")
									context.add_string ("aux_scoop_" + l_argument_name + ".set_processor_ (a_caller_.processor_) end")
									context.add_string ("%N%T%T%T%Tif a_caller_.processor_.locked_processors_has (aux_scoop_" + l_argument_name + ".processor_) then ")
									context.add_string ("scoop_passing_locks := true end%N%T%T%Tend")
									j := j + 1
								end
							else
									-- Non-separate type in the original feature.
								from
									j := 1
									nbj := l_argument.id_list.count
								until
									j > nbj
								loop
									l_argument_name := l_argument.item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name + " /= void then ")
									context.add_string ("%N%T%T%T%Taux_scoop_" + l_argument_name + " := ")
									context.add_string (l_argument_name + ".implementation_%N%T%T%Tend")
									j := j + 1
								end
							end
						elseif l_type_visitor.is_a_like_type or l_type_visitor.is_tuple_type then
								-- Tuple type or a like type.
							from
								j := 1
								nbj := l_argument.id_list.count
							until
								j > nbj
							loop
								l_argument_name := l_argument.item_name (j)

								context.add_string ("%N%T%T%Taux_scoop_" + l_argument_name + " := ")
								context.add_string (l_argument_name + ".implementation_")
								j := j + 1
							end
						end
					end

					i := i + 1
				end
			else
				-- add do keyword
				context.add_string ("%N%T%Tdo")
			end

			Result := Result -- and not is_lock_passing_ignored
		end

	process_formal_argument_list_with_auxiliary_variables (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller, with_brackets: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments. Substitute original arguments with auxiliary variables where necessary.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
			-- Addes brackets before and after the list if desired.
		local
			i, j, nbi, nbj: INTEGER
			l_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			a_prefix: STRING
			l_type_dec_as: TYPE_DEC_AS
		do
			if with_brackets then
				context.add_string ("(")
			end

			create l_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
				nbi := a_list.arguments.count
			until
				i > nbi
			loop
				l_type_dec_as := a_list.arguments.i_th (i)
				a_class_c := l_type_visitor.evaluate_class_from_type (l_type_dec_as.type, class_c)

				if not l_type_visitor.is_formal and then not a_class_c.is_expanded
					and then not l_type_visitor.is_tuple_type then

					create a_prefix.make_from_string ("aux_scoop_")
				else
					create a_prefix.make_empty
				end

				from
					j := 1
					nbj := l_type_dec_as.id_list.count
				until
					j > nbj
				loop
					context.add_string (a_prefix + l_type_dec_as.item_name (j))

					if i < nbi or (i = nbi and j < nbj) then
						context.add_string (", ")
					end

					j := j + 1
				end

				i := i + 1
			end
			if with_brackets then
				context.add_string (")")
			end
		end

	process_flattened_formal_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list'. Substitute anchored types with flattened types.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j, nbj: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_argument: TYPE_DEC_AS
			a_class_c: CLASS_C
			l_proxy_type_visitor: SCOOP_PROXY_TYPE_VISITOR
		do
			create l_scoop_type_visitor

			context.add_string ("(")
			if with_a_caller then
				context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")
				l_proxy_type_visitor := l_type_signature
			else
				l_proxy_type_visitor := l_type_locals
			end

			from
				i := 1
				nb := a_list.arguments.count
			until
				i > nb
			loop
				l_argument := a_list.arguments.i_th (i)
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

				from
					j := 1
					nbj := l_argument.id_list.count
				until
					j > nbj
				loop
					context.add_string (l_argument.item_name (j) + ": ")
					l_proxy_type_visitor.process_type (l_argument.type)

					if i < nb or (i = nb and j < l_argument.id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_as_actual_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j, nbj: INTEGER
			l_argument: TYPE_DEC_AS
		do
			context.add_string ("(")

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
				nb := a_list.arguments.count
			until
				i > nb
			loop
				l_argument := a_list.arguments.i_th (i)
				from
					j := 1
					nbj := l_argument.id_list.count
				until
					j > nbj
				loop
					context.add_string (l_argument.item_name (j))
					if i < nb or (i = nb and j < l_argument.id_list.count) then
						context.add_string (", ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_with_a_caller  (a_list: FORMAL_ARGU_DEC_LIST_AS) is
			-- Process `a_list'.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument.
		local
			i, j, nb, nbj: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			l_argument: TYPE_DEC_AS
		do
			create l_scoop_type_visitor

			context.add_string ("(")
			context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")

			from
				i := 1
				nb := a_list.arguments.count
			until
				i > nb
			loop
				l_argument := a_list.arguments.i_th (i)
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_argument.type, class_c)

				from
					j := 1
					nbj := l_argument.id_list.count
				until
					j > nbj
				loop
					context.add_string (l_argument.item_name (j) + ": ")
					l_type_signature.process_type (l_argument.type)

					if i < nb or (i = nb and j < l_argument.id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
			last_index := a_list.end_position
		end

feature {NONE} -- SCOOP Implementation

	process_lock_passing_before is
			-- Generate code for lock passing.
		do
			context.add_string ("%N%T%T%Tif scoop_passing_locks then")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.increment_lock_passing_counter")
			context.add_string ("%N%T%T%T%Tscoop_locked_processors_stack_size := processor_.locked_processors_count")
			context.add_string ("%N%T%T%T%Tscoop_synchronous_processors_stack_size := processor_.synchronous_processors_count")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_push_whole_stack (a_caller_.processor_.locked_processors)")
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_push_whole_stack (a_caller_.processor_.synchronous_processors)")
		end

	process_lock_passing_after is
			-- Generate code for cleanup after lock passing.
		do
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_trim (scoop_synchronous_processors_stack_size)")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_trim (scoop_locked_processors_stack_size)")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.decrement_lock_passing_counter")			
			context.add_string ("%N%T%T%Telse")
		end

feature{NONE} -- Implementation

	l_type_signature: SCOOP_PROXY_TYPE_SIGNATURE_PRINTER
			-- prints 'TYPE_AS' to the context

	l_type_locals: SCOOP_PROXY_TYPE_LOCALS_PRINTER
			-- prints 'TYPE_AS' to the context

end

note
	description: "Summary description for {AUT_LINEAR_CONSTRAIN_SOLVABLE_VISITOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AUT_PRECONDITION_ANALYZER

inherit
	AST_ITERATOR
		redefine
			process_id_as,
			process_access_feat_as,
			process_nested_as,
			process_keyword_as,
			process_symbol_as,
			process_bool_as,
			process_char_as,
			process_typed_char_as,
			process_void_as,
			process_string_as,
			process_verbatim_string_as,
			process_current_as,
			process_integer_as,
			process_real_as,
			process_unary_as,
			process_binary_as,
			process_bracket_as,
			process_object_test_as,
			process_class_type_as,
			process_static_access_as,
			process_symbol_stub_as,
			process_like_id_as,
			process_like_cur_as,
			process_keyword_stub_as
		end

	AUT_OBJECT_STATE_REQUEST_UTILITY

	SHARED_WORKBENCH

	SHARED_SERVER

	ERL_G_TYPE_ROUTINES

	AUT_SHARED_TYPE_FORMATTER

	SHARED_ERROR_HANDLER

create
	make

feature{NONE} -- Initialization

	make is
			-- Initialize.
		do
			create {DS_HASH_TABLE [STRING, INTEGER]} constrained_variables.make (2)
			create integer_arguments.make (2)
			create arguments.make (2)
			create constraining_queries.make (2)
			create accessed_variables.make (2)
			create last_predicates.make
			create last_feature_access_pattern.make
			create type_checker

			integer_arguments.set_key_equality_tester (string_equal_tester)
			arguments.set_key_equality_tester (string_equal_tester)
			constraining_queries.set_equality_tester (string_equal_tester)
		end

feature -- Access

	last_predicates: DS_LINKED_LIST [AUT_PREDICATE]
			-- Predicates generated by the last call to
			-- `generate_precondition_predicates'.

	last_feature_access_pattern: DS_LINKED_LIST [AUT_PREDICATE_OF_FEATURE]
			-- Last predicate access patterns generated by
			-- the last call to `generate_precondition_predicates'.

feature -- Basic operation

	generate_precondition_predicates (a_feature: AUT_FEATURE_OF_TYPE) is
			-- Generate predicates from preconditions of `a_feature'.
			-- Store result in `last_predicates' and
			-- `last_feature_access_pattern'.
		local
			l_precondition_extractor: AUT_PRECONDITION_EXTRACTOR
			l_asserts: DS_LIST [AUT_ASSERTION]
			l_assertion: AUT_ASSERTION
			l_solvables: DS_LINKED_LIST [AUT_PREDICATE]
			l_unsolvables: DS_LINKED_LIST [AUT_PREDICATE]
		do
			last_predicates.wipe_out
			last_feature_access_pattern.wipe_out
			current_feature := a_feature

				-- Get preconditions of `a_feature'.
			create l_precondition_extractor.make
			l_precondition_extractor.extract_precondition (a_feature)
			l_asserts := l_precondition_extractor.preconditions.item (a_feature)

				-- Generate predicates for each of the precondition assertions.
			create l_solvables.make
			create l_unsolvables.make
			from
				l_asserts.start
			until
				l_asserts.after
			loop
				l_assertion := l_asserts.item_for_iteration
				check_assertion (l_assertion, a_feature)
				l_asserts.forth
			end
		end

feature{NONE} -- Process

	process_id_as (l_as: ID_AS)
		do
			check_access_name (l_as.name.as_lower)
		end

	process_access_feat_as (l_as: ACCESS_FEAT_AS)
		local
			l_name: STRING
			l_parameters: EIFFEL_LIST [EXPR_AS]
		do
			if l_as.internal_parameters /= Void then
					-- If there is a feature call with arguments, then
					-- we consider the current assertion to be non linearly solvable.
				is_linear_solvable := False
			end

			check_access_name (l_as.access_name.as_lower)

			if l_as.internal_parameters /= Void then
				text.append (" (")
				from
					l_parameters := l_as.internal_parameters.parameters.twin
					l_parameters.start
				until
					l_parameters.after
				loop
					nested_list.force_last (create {DS_LINKED_STACK [BOOLEAN]}.make)
					safe_process (l_parameters.item_for_iteration)
					l_parameters.forth
					nested_list.remove_last
				end
				text.append_character (')')
			end
		end

	process_nested_as (l_as: NESTED_AS)
		local
			l_stack: DS_LINKED_STACK [BOOLEAN]
		do
			is_linear_solvable := False

			l_stack := nested_list.last
			l_stack.force (True)
			safe_process (l_as.target)
			l_stack.replace (False)
			text.append_character ('.')
			safe_process (l_as.message)
			l_stack.remove
		end

	process_keyword_as (l_as: KEYWORD_AS)
			-- Process `l_as'.
		do
			text.append_character (' ')
			text.append_string (text_of_ast (l_as))
			text.append_character (' ')
		end

	process_keyword_stub_as (l_as: KEYWORD_STUB_AS)
			-- Process `l_as'.
		do
			text.append_string (text_of_ast (l_as))
		end

	process_symbol_as (l_as: SYMBOL_AS)
			-- Process `l_as'.
		do
			text.append_string (text_of_ast (l_as))
		end

	process_symbol_stub_as (l_as: SYMBOL_STUB_AS)
			-- Process `l_as'.
		do
			text.append_string (l_as.text (current_match_list))
		end

	process_bool_as (l_as: BOOL_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_char_as (l_as: CHAR_AS)
		do
			fixme ("Have problem of output precondition for HIGH_BUILDER.build_dollar_p. The index in LEAF_AS is not correct.")
--			text.append_string (text_of_ast (l_as))
			text.append_character ('%'')
			text.append (l_as.value.to_character_8.out)
			text.append_character ('%'')
		end

	process_typed_char_as (l_as: TYPED_CHAR_AS)
			-- Process `l_as'.
		do
			text.append_string (text_of_ast (l_as))
		end

	process_void_as (l_as: VOID_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_string_as (l_as: STRING_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_verbatim_string_as (l_as: VERBATIM_STRING_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_current_as (l_as: CURRENT_AS)
		local
			l_text: STRING
		do
			l_text := place_holder (0)
			text.append_string (l_text)
			accessed_variables.force_last (current_feature.type, 0)
		end

	process_integer_as (l_as: INTEGER_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_real_as (l_as: REAL_AS)
		do
			text.append_string (text_of_ast (l_as))
		end

	process_unary_as (l_as: UNARY_AS)
		do
			text.append (l_as.operator_name.as_lower)
			text.append_character (' ')
			l_as.expr.process (Current)
		end

	process_binary_as (l_as: BINARY_AS)
		do
			l_as.left.process (Current)
			text.append_character (' ')
			text.append (l_as.op_name.name)
			text.append_character (' ')
			l_as.right.process (Current)
		end

	process_bracket_as (l_as: BRACKET_AS)
		do
			l_as.target.process (Current)
			text.append_character ('[')
			l_as.operands.process (Current)
			text.append_character (']')
		end

	process_object_test_as (l_as: OBJECT_TEST_AS)
		do
			if l_as.is_attached_keyword then
				safe_process (l_as.attached_keyword (current_match_list))
				text.append_character (' ')
				if l_as.type /= Void then
					safe_process (l_as.type)
					text.append_character (' ')
				end
				l_as.expression.process (Current)
				text.append_character (' ')
				safe_process (l_as.as_keyword (current_match_list))
				text.append_character (' ')
				safe_process (l_as.name)
			else
				l_as.name.process (Current)
				l_as.type.process (Current)
				l_as.expression.process (Current)
			end
		end

	process_class_type_as (l_as: CLASS_TYPE_AS)
		do
			safe_process (l_as.lcurly_symbol (current_match_list))
			text.append (full_type_name (l_as.class_name.text (current_match_list), current_assertion.written_class))
			safe_process (l_as.rcurly_symbol (current_match_list))
		end

	process_static_access_as (l_as: STATIC_ACCESS_AS)
		local
			l_stack: DS_LINKED_STACK [BOOLEAN]
		do
			l_as.class_type.process (Current)
			l_stack := nested_list.last
			l_stack.force (False)
			safe_process (l_as.dot_symbol (current_match_list))
			process_access_feat_as (l_as)
			l_stack.remove
		end

	process_like_id_as (l_as: LIKE_ID_AS)
		do
			process_anchored_type (l_as)
		end

	process_anchored_type (l_as: TYPE_AS) is
			-- Process `l_as'.
		local
			l_type: TYPE_A
			l_type2: TYPE_A
			l_like_feat: LIKE_FEATURE
			l_type_checker: TYPE_A_CHECKER
		do
				-- Resolve type in `l_as'.
			l_type := type_a_generator.evaluate_type_if_possible (l_as, current_assertion.written_class)
			l_type_checker := type_checker
			l_type_checker.init_for_checking (current_feature.feature_, current_written_class, Void, error_handler)
			l_type2 := l_type_checker.check_and_solved (l_type, l_as).actual_type.deep_actual_type

			safe_process (l_as.lcurly_symbol (current_match_list))
			text.append (type_name_with_context (l_type2, current_assertion.written_class, current_feature.feature_))
			safe_process (l_as.rcurly_symbol (current_match_list))
		end

	process_like_cur_as (l_as: LIKE_CUR_AS)
		do
			process_anchored_type (l_as)
		end

	text_of_ast (a_ast: AST_EIFFEL): STRING is
			-- Text of `a_ast' in lower case
		do
			Result := a_ast.text (current_match_list)
		end

	nested_list: DS_LINKED_LIST [DS_LINKED_STACK [BOOLEAN]]
			-- List for nested structures

	check_access_name (a_name: STRING) is
			-- Check if access identifier is of type integer.
			-- `a_name' is assumed to be in lower case.
		local
			l_feat: FEATURE_I
			l_text: STRING
			l_arg_index: INTEGER
			i: INTEGER
		do
				-- Check if current assertion is linearly constraint solvable.
			if is_linear_solvable then
				if integer_arguments.has (a_name) then
					is_integer_argument_mentioned := True
					constrained_variables.force_last (a_name, integer_arguments.item (a_name))
				elseif arguments.has (a_name) then
					is_linear_solvable := False
				else
					l_feat := final_feature (a_name, current_assertion.written_class, current_feature.type.associated_class)
					is_linear_solvable := l_feat.argument_count = 0 and then l_feat.type.is_integer
					if is_linear_solvable then
						constraining_queries.force_last (l_feat.feature_name.as_lower)
					end
				end
			end

				-- Check which variable is accessed, either the target object, or an argument.
			if nested_list.last.is_empty or else (nested_list.last.count = 1 and then nested_list.last.item) then
				l_arg_index := 0
				if arguments.has (a_name) then
					l_arg_index := arguments.item (a_name)
				else
					l_arg_index := final_argument_index (a_name, current_assertion, current_feature.feature_)
				end

				if l_arg_index > 0 then
					accessed_variables.force_last (current_feature.feature_.arguments.i_th (l_arg_index), l_arg_index)
					text.append (place_holder (l_arg_index))
				else
					l_feat := final_feature (a_name, current_assertion.written_class, current_feature.type.associated_class)
					if l_feat /= Void then
						accessed_variables.force_last (current_feature.type, 0)
						text.append (place_holder (0))
						text.append_character ('.')
						text.append (l_feat.feature_name)
					else
						text.append (a_name)
					end
				end
			else
				text.append (a_name)
			end
		end

	final_argument_index (a_name: STRING; a_assertion: AUT_ASSERTION; a_feature: FEATURE_I): INTEGER is
			--
		local
			l_feature: FEATURE_I
			i: INTEGER
			l_arg_count: INTEGER
		do
			l_feature := a_assertion.written_class.feature_of_rout_id_set (a_feature.rout_id_set)
			from
				l_arg_count := l_feature.argument_count
				i := 1
			until
				i > l_arg_count or Result > 0
			loop
				if l_feature.arguments.item_name (i).is_case_insensitive_equal (a_name) then
					Result := i
				end
				i := i + 1
			end
		end

feature{NONE} -- Implementation

	current_assertion: detachable AUT_ASSERTION
			-- Assertion that is currently processed

	current_feature: detachable AUT_FEATURE_OF_TYPE
			-- Feature where `current_assertion' is written

	current_context_class: CLASS_C is
			-- Context class where `current_feature' is viewed
		do
			Result := current_feature.associated_class
		end

	current_written_class: CLASS_C is
			-- Class where `current_feature' is written
		do
			Result := current_feature.feature_.written_class
		end

	current_match_list: LEAF_AS_LIST is
			-- Match list of the class where `current_assertion' is written
		do
			Result := match_list_server.item (current_assertion.written_class.class_id)
		end

	integer_arguments: DS_HASH_TABLE [INTEGER, STRING];
			-- Table of the arguments in the feature
			-- where currently processed assertion is
			-- written.
			-- [argument index, argument name]
			-- argument index is 1-based.

	arguments: DS_HASH_TABLE [INTEGER, STRING]
			-- Set of argument names for `current_feature'

	is_integer_argument_mentioned: BOOLEAN
			-- Is some argument of integer type mentioned in
			-- `current_assertion? An assertion needs
			-- linearly constraint solving only when its integer arguments
			-- are mentioned in the assertion.

	find_integer_arguments is
			-- Find arguments of integer type in the feature where `current_assertion'
			-- is written and put them into `integer_arguments'.
		require
			current_assertion_attached: current_assertion /= Void
			current_feature_attached: current_feature /= Void
		local
			l_feature: FEATURE_I
			l_arg_count: INTEGER
			i: INTEGER
			l_arg_name: STRING
		do
			l_feature := current_feature.feature_
			l_arg_count := l_feature.argument_count
			if l_arg_count > 0 then
				from
					i := 1
				until
					i > l_arg_count
				loop
					l_arg_name := l_feature.arguments.item_name (i).as_lower
					arguments.force_last (i, l_arg_name)
					if l_feature.arguments.i_th (i).is_integer then
						integer_arguments.force_last (i, l_arg_name)
					end
					i := i + 1
				end
			end
		end

--	is_top_level_nested_as (a_nested_as: NESTED_AS): BOOLEAN is
--			-- Is `a_nested_as' is top level structure?
--			-- Top level means that `a_nested_as' is not a message (see NESTED_AS)
--			-- of another nested structure.
--		do
--			if last_processed_nested_as /= Void then
--				Result := last_processed_nested_as.message /= a_nested_as
--			else
--				Result := True
--			end
--		end

--	last_processed_nested_as: detachable NESTED_AS
--			-- Last process nested structure

	place_holder (a_index: INTEGER): STRING is
			-- Place holder for `a_index'-th variable accessed in
			-- currently processed assertion
		do
			create Result.make (3)
			Result.append_character ('$')
			Result.append_integer(a_index)
			Result.append_character ('$')
		end

	replace_text (a_call_index: INTEGER; a_predicate_index: INTEGER) is
			--
		local
			l_call_str: STRING
			l_pred_str: STRING
		do
			create l_call_str.make (3)
			l_call_str.append_character ('$')
			l_call_str.append (a_call_index.out)
			l_call_str.append_character ('$')

			create l_pred_str.make (3)
			l_pred_str.append_character ('{')
			l_pred_str.append (a_predicate_index.out)
			l_pred_str.append_character ('}')

			text.replace_substring_all (l_call_str, l_pred_str)
		end

	analyze_predicate is
			-- Analyze the last processed assertion
			-- and generate a predicate out of it.
			-- Store result in `last_predicates' and
			-- `last_feature_access_pattern'.
		local
			l_sorted_args: DS_LIST [INTEGER]
			l_normal_pred: AUT_NORMAL_PREDICATE
			l_linear_pred: AUT_NORMAL_LINEAR_SOLVABLE_PREDICATE
			l_pred_types: DS_LINKED_LIST [TYPE_A]
			l_access_pattern: DS_HASH_TABLE [INTEGER, INTEGER]
			l_predicate_of_feat: AUT_PREDICATE_OF_FEATURE
			l_predicate: AUT_PREDICATE
			l_constrained_args: DS_HASH_TABLE [STRING, INTEGER]
			i: INTEGER
		do
			l_sorted_args := sorted_keys (accessed_variables)

				-- Decide argument types for the predicate.
			create l_pred_types.make
			from
				l_sorted_args.start
			until
				l_sorted_args.after
			loop
				l_pred_types.force_last (accessed_variables.item (l_sorted_args.item_for_iteration))
				l_sorted_args.forth
			end

				-- Update `text' with correct argument position for the predicate
				-- and generate access pattern.
			create l_access_pattern.make (l_sorted_args.count)
			from
				l_sorted_args.start
				i := 1
			until
				l_sorted_args.after
			loop
				replace_text (l_sorted_args.item_for_iteration, i)
				l_access_pattern.put (i, l_sorted_args.item_for_iteration)
				i := i + 1
				l_sorted_args.forth
			end

				-- Generate predicate.
			if is_linear_solvable then
				create l_constrained_args.make (3)
				from
					i := 1
					l_sorted_args.start
				until
					l_sorted_args.after
				loop
					if constrained_variables.has (l_sorted_args.item_for_iteration) then
						l_constrained_args.put (constrained_variables.item (l_sorted_args.item_for_iteration), i)
					end
					i := i + 1
					l_sorted_args.forth
				end

				create l_linear_pred.make (
					l_pred_types,
					text,
					current_feature.associated_class,
					current_assertion,
					l_constrained_args,
					constraining_queries)

				l_predicate := l_linear_pred
			else
				create l_normal_pred.make (
					l_pred_types,
					text,
					current_feature.associated_class,
					current_assertion)

				l_predicate := l_normal_pred
			end
			create l_predicate_of_feat.make (current_feature, l_predicate, l_access_pattern)
			l_predicate_of_feat.set_index (current_assertion.index)
			last_predicates.force_last (l_predicate)
			last_feature_access_pattern.force_last (l_predicate_of_feat)
		end

	check_assertion (a_assertion: AUT_ASSERTION; a_context_feature: AUT_FEATURE_OF_TYPE) is
			-- Analyze `a_assertion' from `a_context_feature'.
			-- If the constaints in `a_assertion' which is written in `a_context_feature'
			-- is linear solvable, set `is_linear_solvable' to True and put integer arguments
			-- which are linearly constrained into `constrained_variables', and put queries that
			-- contrains `constrained_variables' into `constraining_queries'.
			-- Also, put every accessed variables into `accessed_variables'.
		do
			is_linear_solvable := False
			is_integer_argument_mentioned := False
			constrained_variables.wipe_out
			arguments.wipe_out
			integer_arguments.wipe_out
			accessed_variables.wipe_out
			create nested_list.make
			nested_list.force_last (create {DS_LINKED_STACK [BOOLEAN]}.make)
			create text.make (64)

				-- Find integer argument in `a_context_feature'.
			current_assertion := a_assertion
			current_feature := a_context_feature
			find_integer_arguments
			current_assertion.tag.expr.process (Current)
			is_linear_solvable := is_linear_solvable and then is_integer_argument_mentioned

				-- Analyze just created predicate.
			analyze_predicate
		end

feature{NONE} -- Equality tester

	is_string_equal (a_str, b_str: STRING): BOOLEAN is
			-- Is `a_str' equal to `b_str'?
		do
			Result := a_str ~ b_str
		ensure
			good_result: Result = a_str ~ b_str
		end

feature{NONE} -- Implmentation

	is_linear_solvable: BOOLEAN
			-- Is linear constraint in the last process
			-- assertion solvable?

	string_equal_tester: AGENT_BASED_EQUALITY_TESTER [STRING] is
			-- Tester to decide if two strings are equal
		do
			create Result.make (agent is_string_equal)
		end

	constrained_variables: DS_HASH_TABLE [STRING, INTEGER]
			-- Name of the arguments in the last processed assertion
			-- that are constrained by assertions
			-- [Name, argument index], key is the name of the argument
			-- value is the 1-based index of the argument.
			-- The first argument has index 1.
			-- Note: Result has effect only if `is_linear_solvable' is True

	constraining_queries: DS_HASH_SET [STRING]
			-- Set of name of queries which constains `constrained_variables'
			-- Note: Result has effect only if `is_linear_solvable' is True

	accessed_variables: DS_HASH_TABLE [TYPE_A, INTEGER]
			-- Accessed variables in the last processed assertion
			-- variables is either the target object or an argument.
			-- The value is the type of the varaible,
			-- the key is its index. The index is 0-based,
			-- the 0-th variable is the target, the 1-th variable is
			-- the first argument, and so on.

	text: STRING
			-- Text of the last process assertion.

	type_checker: TYPE_A_CHECKER
			-- Type checker			

	sorted_keys (a_table: DS_HASH_TABLE [ANY, INTEGER]): DS_LIST [INTEGER] is
			-- ascendingly sorted list of keys in `a_table'
		local
			l_sorter: DS_QUICK_SORTER [INTEGER]
			l_tester: AGENT_BASED_EQUALITY_TESTER [INTEGER]
			l_keys: DS_ARRAYED_LIST [INTEGER]
		do
			create l_keys.make (a_table.keys.count)
			a_table.keys.do_all (agent l_keys.force_last)
			create l_sorter.make (create {AGENT_BASED_EQUALITY_TESTER [INTEGER]}.make (agent (a,b: INTEGER): BOOLEAN do Result := a < b end))
			l_sorter.sort (l_keys)
			Result := l_keys
		end

note
	copyright: "Copyright (c) 1984-2009, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

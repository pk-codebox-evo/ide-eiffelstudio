note
	description: "Summary description for {AUT_PREDICATE_POOL}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AUT_PREDICATE_POOL

inherit
	AUT_SHARED_PREDICATE_CONTEXT
	REFACTORING_HELPER

create
	make

feature{NONE} -- Initialization

	make is
			-- Initialize current
		do
				-- Uses `equal' for key comparison
			create valuation_table.make_default
			create valuation_cursor_factory
			set_is_partial_satisfaction_enabled (True)
		end

feature -- Access

	last_candidates: detachable DS_LINKED_LIST [ARRAY [detachable ITP_VARIABLE]]
			-- Candidates generated by last `generate_candidates'

	last_partial_candidate: detachable ARRAY [detachable ITP_VARIABLE]
			-- Partial candidate generated by last `generate_candidates'.

	valuation_table: DS_HASH_TABLE [AUT_PREDICATE_VALUATION, AUT_PREDICATE]
			-- Table holding the valuation for each predicate
			-- Note: This table should be read only from client side.

feature -- Status report

	is_candidate_satisfied (a_constraint: AUT_PREDICATE_CONSTRAINT; a_arguments: ARRAY [detachable ITP_VARIABLE]; a_predicate_veto_function: detachable PREDICATE [ANY, TUPLE [AUT_PREDICATE]]): BOOLEAN is
			-- Is `a_arguments' satisfy `a_constraint'?
			-- If `a_predicate_veto_function' is attached, only predicates that makes `a_preciate_veto_function' return True is evaluated.
		require
			a_constraint_attached: a_constraint /= Void
			a_arguments_attached: a_arguments /= Void
			a_arguments_valid: a_constraint.operand_count = a_arguments.count and then a_arguments.lower = 0
		local
			l_cursor: DS_LINKED_LIST_CURSOR [AUT_PREDICATE_ACCESS_PATTERN]
			l_valuation_tbl: like valuation_table
			l_pred_args: ARRAY [ITP_VARIABLE]
			l_pattern: AUT_PREDICATE_ACCESS_PATTERN
			l_mapping: DS_HASH_TABLE_CURSOR [INTEGER, INTEGER]
			l_variable: detachable ITP_VARIABLE
		do
			l_valuation_tbl := valuation_table
			Result := True
			from
				l_cursor := a_constraint.access_patterns.new_cursor
				l_cursor.start
			until
				l_cursor.after or not Result
			loop
				l_pattern := l_cursor.item
				create l_pred_args.make (1, l_pattern.predicate.arity)
				from
					l_mapping := a_constraint.argument_operand_mapping.item (l_pattern).new_cursor
					l_mapping.start
				until
					l_mapping.after or not Result
				loop
					l_variable := a_arguments.item (l_mapping.item)
					if l_variable = Void then
						Result := False
					else
						l_pred_args.put (l_variable, l_mapping.key)
					end
					l_mapping.forth
				end

				if Result and then (a_predicate_veto_function = Void or else a_predicate_veto_function.item ([l_pattern.predicate])) then
					Result := l_valuation_tbl.item (l_pattern.predicate).item (l_pred_args)
				end
				l_cursor.forth
			end
		end

--	is_predicate_satisfied (a_predicate: AUT_PREDICATE; a_arguments: ARRAY [ITP_VARIABLE]): BOOLEAN is
--			-- Is `a_arguments' satisfy `a_predicate'?
--		require
--			a_predicate_attached: a_predicate /= Void
--			a_predicate_exist: predicates.has (a_predicate)
--			a_arguments_attached: a_arguments /= Void
--			a_arguments_valid: a_predicate.arity = a_arguments.count and then a_arguments.lower = 1
--			a_arguments_items_attached: not a_arguments.has (Void)
--		do
--			if not valuation_table.has (a_predicate) then
--				Result := false
--			else
--				Result := valuation_table.item (a_predicate).item (a_arguments)
--			end
--		end

	is_partial_satisfaction_enabled: BOOLEAN
			-- In case when it is not possible to satisfy all required predicate,
			-- is a candidate which only satisfies part of the required predicate to be returned?			
			-- Default: True

feature -- Setting

	set_is_partial_satisfaction_enabled (b: BOOLEAN) is
			-- Set `is_partial_satisfaction_enabled' with `b'.
		do
			is_partial_satisfaction_enabled := b
		ensure
			is_partial_satisfaction_enabled_set: is_partial_satisfaction_enabled = b
		end

--feature -- Access

--	candidates (a_constraint: AUT_PREDICATE_CONSTRAINT; a_max_solution_count: INTEGER): DS_LINKED_LIST [ARRAY [detachable ITP_VARIABLE]] is
--			-- Candidate object combinations satisfy `a_constraint'.
--			-- Return at most `a_max_solution_count' candidates.
--			-- The returned candidates are randomly selected from the candidate space.
--			-- If `a_max_solution_count' is 0, all satisfying candidates are returned.
--		require
--			a_constraint_attached: a_constraint /= Void
--			a_max_solution_count_non_negative: a_max_solution_count >= 0
--		local
--			l_candidate: ARRAY [detachable ITP_VARIABLE]
--			l_quick_sorter: DS_ARRAY_QUICK_SORTER [AUT_PREDICATE]
--			l_less_than_tester: AGENT_BASED_EQUALITY_TESTER [AUT_PREDICATE]
--			l_sorted_predicates: ARRAY [AUT_PREDICATE]
--			i: INTEGER
--				-- working structure:
--				--  the inner ARRAY [ITP_VARIABLE] is a satisfying combination of the predicate valuation
--				--  the middle ARRAY is the list of satisfying combinations
--				--  the outer ARRAY is one item per predicate
--				-- so: each predicate has a list of satisfying combinations for its valuation
--			l_working_structure: ARRAY [ARRAY [ARRAY [ITP_VARIABLE]]]
--			l_iteration_combinations: ARRAY [ARRAY [ITP_VARIABLE]]
--			l_combination: ARRAY [ITP_VARIABLE]
--		do
--				-- Use `=' as comparison criterion
--			create Result.make_default

--				-- Construct array of predicates
--			from
--				create l_sorted_predicates.make (1, a_constraint.argument_mapping.keys.count)
--				i := 1
--				a_constraint.argument_mapping.keys.start
--			until
--				a_constraint.argument_mapping.keys.after
--			loop
--				l_sorted_predicates.force (a_constraint.argument_mapping.keys.item_for_iteration, i)
--				i := i + 1
--				a_constraint.argument_mapping.keys.forth
--			end

--				-- Sort the list according to their number of satisfying combinations
--			create l_less_than_tester.make (agent (a, b: AUT_PREDICATE): BOOLEAN
--					do
--						Result := predicate_valuation_table.item (a).satisfying_combinations_count < predicate_valuation_table.item (b).satisfying_combinations_count
--					end)
--			create l_quick_sorter.make (l_less_than_tester)
--			l_quick_sorter.sort (l_sorted_predicates)

--				-- Create the sorted working structure (shares index with l_sorted_predicates)
--			create l_working_structure.make (1, l_sorted_predicates.count)
--			from
--				i := l_sorted_predicates.lower
--			until
--				i = l_sorted_predicates.upper
--			loop
--				l_iteration_combinations := predicate_valuation_table.item (l_sorted_predicates.item (i)).satisfying_object_combinations_as_array
--				l_working_structure.force (l_iteration_combinations, i)
--				i := i + 1
--			end

--				fixme ("TO IMPLEMENT")
--				-- Sketch of algorithm:
--				--
--				-- repeat
--				--   create an empty l_candidate
--				--   loop over l_sorted_predicates
--				--     randomly select a satisfying combination for the predicate valuation, taking the fixed variables in l_candidate into account
--				--     add the variables of the satisfying combination into l_candidate at the correct index
--				--     continue with the next predicate or backtrack if no satisfying combination found
--				--   add l_candidate into Result
--				-- until Result has `a_max_solution_count' candidates (or until all candidates are found if `a_max_solution_count' = 0)
--				fixme ("TO IMPLEMENT")
--		ensure
--			result_attached: Result /= Void
--		end

--feature -- Status report

--	is_candidate_satisfied (a_constraint: AUT_PREDICATE_CONSTRAINT; a_arguments: ARRAY [ITP_VARIABLE]): BOOLEAN is
--			-- Is `a_arguments' satisfy `a_constraint'?
--		require
--			a_constraint_attached: a_constraint /= Void
--			a_arguments_attached: a_arguments /= Void
--			a_arguments_valid: a_constraint.distinct_argument_count = a_arguments.count and then a_arguments.lower = 0
--			a_arguments_items_attached: not a_arguments.has (Void)
--		local
--			l_argument_mapping: DS_HASH_TABLE [DS_HASH_TABLE [INTEGER, INTEGER], AUT_PREDICATE]
--			l_iteration_predicate: AUT_PREDICATE
--			l_break: BOOLEAN
--			l_iteration_predicate_valuation: AUT_PREDICATE_VALUATION
--			l_valuation_satisfied: BOOLEAN
--			l_mapped_arguments_array: ARRAY [ITP_VARIABLE]
--			i: INTEGER
--		do
--			l_argument_mapping := a_constraint.argument_mapping
--			Result := true

--			from
--				l_break := false
--				l_argument_mapping.start
--			until
--				l_argument_mapping.after or else l_break
--			loop
--				l_iteration_predicate := l_argument_mapping.key_for_iteration

--				if not predicate_valuation_table.has (l_iteration_predicate) then
--					l_break := true
--				else
--					l_iteration_predicate_valuation := predicate_valuation_table.item (l_iteration_predicate)

--					if l_iteration_predicate_valuation.arity = 0 then
----						l_valuation_satisfied := l_iteration_predicate_valuation.is_satisfying_combination (create {ARRAY [ITP_VARIABLE]}.make (0, 0))
--						fixme ("to implement: nullary predicate valuations")
--					else
--							-- Create a new arguments array, mapped to predicate argument index
--						from
--							create l_mapped_arguments_array.make (1, l_iteration_predicate_valuation.arity)
--							i := 1
--						until
--							i = l_iteration_predicate_valuation.arity
--						loop
--							l_mapped_arguments_array.force (a_arguments.item (l_argument_mapping.item_for_iteration.item (i)), i)
--						end

--						l_valuation_satisfied := l_iteration_predicate_valuation.is_satisfying_combination (l_mapped_arguments_array)
--					end

--					if not l_valuation_satisfied then
--						l_break := true
--					end
--				end

--				l_argument_mapping.forth
--			end

--			if l_break then
--				Result := false
--			end
--		end

feature -- Basic operations

	setup_predicates (a_predicates: DS_HASH_SET [AUT_PREDICATE]) is
			-- Setup `valuation_table' for `a_predicates'.
		local
			l_cursor: DS_HASH_SET_CURSOR [AUT_PREDICATE]
		do
			from
				l_cursor := a_predicates.new_cursor
				l_cursor.start
			until
				l_cursor.after
			loop
				valuation_table.force_last (new_predicate_valuation (l_cursor.item), l_cursor.item)
				l_cursor.forth
			end
		ensure
			valuation_table_set:
				valuation_table.count = a_predicates.count and then
				valuation_table.for_all_with_key (
					agent (a_valuation: AUT_PREDICATE_VALUATION; a_pred: AUT_PREDICATE; a_preds: DS_HASH_SET [AUT_PREDICATE]): BOOLEAN
						do
							Result := a_preds.has (a_pred) and then a_valuation.predicate = a_pred
						end (?, ?, a_predicates))
		end

	update_predicate_valuation (a_predicate: AUT_PREDICATE; a_arguments: ARRAY [ITP_VARIABLE]; a_valuation: BOOLEAN) is
			-- Update the valuation of `a_predicate' with `a_arguments' to `a_valuation'.
		require
			a_predicate_attached: a_predicate /= Void
			a_predicate_exist: predicates.has (a_predicate)
			a_arguments_attached: a_arguments /= Void
			a_arguments_valid: a_predicate.arity = a_arguments.count and then a_arguments.lower = 1
			a_arguments_items_attached: not a_arguments.has (Void)
		local
			l_predicate_valuation: AUT_PREDICATE_VALUATION
		do
			valuation_table.item (a_predicate).put (a_arguments, a_valuation)
		ensure
			valuation_set: valuation_table.item (a_predicate).item (a_arguments) = a_valuation
		end

	generate_candidates (a_constraint: AUT_PREDICATE_CONSTRAINT; a_max_solution_count: INTEGER; a_initial_candidate: ARRAY [detachable ITP_VARIABLE]) is
			-- Generate candidate object combinations satisfy `a_constraint', and store result
			-- in `last_candidates'.
			-- If `a_max_solution_count' > 0, store at most `a_max_solution_count' candidates.		
			-- If `a_max_solution_count' is 0, all satisfying candidates are stored.
			-- If no candidate is found, but some partial candidate is found, store that
			-- partial candidate in `last_partial_candidate'.
			-- `a_initial_candidate' is used to provide candidate operands that are not bounded after candidate generation.
		require
			a_constraint_attached: a_constraint /= Void
			a_max_solution_count_non_negative: a_max_solution_count >= 0
		local
			l_count: INTEGER
			l_cursors: DS_ARRAYED_LIST [AUT_PREDICATE_VALUATION_CURSOR]
			l_candidate: ARRAY [detachable ITP_VARIABLE]
			l_done: BOOLEAN
			l_cursor: AUT_PREDICATE_VALUATION_CURSOR
			l_partial_candidate: ARRAY [detachable ITP_VARIABLE]
			l_nb_bounded_var: INTEGER
			l_is_partial_satisfaction_enabled: BOOLEAN
			l_last_candidates: like last_candidates
			l_last_candidate: ARRAY [detachable ITP_VARIABLE]
		do
			create last_candidates.make
			l_last_candidates := last_candidates
				-- Get sorted cursors for predicates valuations.						
			create l_candidate.make (0, a_constraint.operand_count - 1)
			l_cursors := sorted_valuation_cursors (a_constraint, l_candidate)
			if l_cursors.is_empty then
				last_partial_candidate := Void
			else
				l_is_partial_satisfaction_enabled := is_partial_satisfaction_enabled
				if l_is_partial_satisfaction_enabled or else l_cursors.first.container.count > 0 then
					if l_is_partial_satisfaction_enabled then
						from
							l_cursors.start
						until
							l_cursors.after
						loop
							if l_cursors.item_for_iteration.container.is_empty then
								l_cursors.remove_at
							else
								l_cursors.forth
							end
						end
					end

						-- Search for candidates.
					if not l_cursors.is_empty then
						from
							l_cursors.start
							l_cursor := l_cursors.item_for_iteration
							l_cursor.start
						until
							l_done
						loop
							if l_cursor.after then
									-- Valuations for current predicate have been exhausted,
									-- backtrack.
								l_cursors.back
								if l_cursors.before then
										-- All valuations have been exhausted, terminate searching.
									l_done := True
								else
										-- Backtrack.
									l_cursor := l_cursors.item_for_iteration
									l_cursor.update_candidate_with_free_variables
									l_cursor.forth
								end
							else
									-- We successfully satisfied a new precondition assertion,
									-- update free variables.
								l_cursor.update_candidate_with_item

									-- If a partial candidate with the most number of bounded arguments seen
									-- so fare is found, we store it as the partial candidate.
								if
									l_is_partial_satisfaction_enabled and then
									l_count = 0 and then
									l_cursors.index > l_nb_bounded_var
								then
									l_partial_candidate := l_candidate.twin
									l_nb_bounded_var := l_cursors.index
								end

								if l_cursors.is_last then
										-- We found one candidate.
									l_last_candidate := l_candidate.twin
									fix_free_variables (l_last_candidate, a_initial_candidate)
									l_last_candidates.force_last (l_last_candidate)

									l_count := l_count + 1
									l_done := a_max_solution_count > 0 and then l_count > a_max_solution_count
									l_cursor.update_candidate_with_free_variables
									l_cursor.forth
								else
										-- There are some predicates that are not checked,
										-- move forward.
									l_cursors.forth
									l_cursor := l_cursors.item_for_iteration
									l_cursor.calculate_free_variables
									l_cursor.start
								end
							end
						end
					end
				end

				if l_count = 0 and then l_is_partial_satisfaction_enabled then
					last_partial_candidate := l_partial_candidate
				else
					last_partial_candidate := Void
				end
			end
		end

	wipe_out is
			-- Wipe out current prediate pool.
		do
			valuation_table.do_all (agent {AUT_PREDICATE_VALUATION}.wipe_out)
		end

feature{NONE} -- Implementation

	valuation_cursor_factory: AUT_PREDICATE_VALUATION_CURSOR_FACTORY
			-- Factory to create cursors for predicate valuation

	sorted_valuation_cursors (a_constraint: AUT_PREDICATE_CONSTRAINT; a_candidate: ARRAY [detachable ITP_VARIABLE]): DS_ARRAYED_LIST [AUT_PREDICATE_VALUATION_CURSOR] is
			-- List of sorted predicate valuation cursors for predicates in `a_constraint'.
			-- The cursor with the least candicates will appear first in the sorted list.
		require
			a_constraint_attached: a_constraint /= Void
			a_candidate_attached: a_candidate /= Void
			a_candidate_valid: a_candidate.lower = 0
			a_constraint_valid: a_constraint.operand_count = a_candidate.count
		local
			l_cursors: DS_ARRAYED_LIST [AUT_PREDICATE_VALUATION_CURSOR]
			l_sorter: DS_QUICK_SORTER [AUT_PREDICATE_VALUATION_CURSOR]
			l_pred_cursor: DS_LINKED_LIST_CURSOR [AUT_PREDICATE_ACCESS_PATTERN]
			l_cursor_factory: like valuation_cursor_factory
			l_valuation_tbl: like valuation_table
		do
				-- Get cursors for all predicate valuations.
			create l_cursors.make (a_constraint.argument_operand_mapping.count)
			from
				l_valuation_tbl := valuation_table
				l_cursor_factory := valuation_cursor_factory
				l_pred_cursor := a_constraint.access_patterns.new_cursor
				l_pred_cursor.start
			until
				l_pred_cursor.after
			loop
				l_cursor_factory.generate_cursor (l_valuation_tbl.item (l_pred_cursor.item.predicate), l_pred_cursor.item, a_constraint, a_candidate)
				l_cursors.force_last (l_cursor_factory.last_cursor)
				l_pred_cursor.forth
			end

				-- Sort `l_cursors' according to the number of possible candidates.
				-- The cursor with the least candicates will appear first in the sorted list.
			create l_sorter.make (create {AGENT_BASED_EQUALITY_TESTER [AUT_PREDICATE_VALUATION_CURSOR]}.make (
				agent (a_cursor, b_cursor: AUT_PREDICATE_VALUATION_CURSOR): BOOLEAN
					do
						if a_cursor.predicate_access_pattern.predicate.is_linear_solvable /= a_cursor.predicate_access_pattern.predicate.is_linear_solvable then
								-- Make sure that linearly solvable predicates are at the end of the sorted list.
							Result := not a_cursor.predicate_access_pattern.predicate.is_linear_solvable
						else
							Result := a_cursor.container.count < b_cursor.container.count
						end
					end
			))
			l_sorter.sort (l_cursors)
			Result := l_cursors
		ensure
			result_attached: Result /= Void
			result_not_has_void: not Result.has (Void)
		end

	new_predicate_valuation (a_predicate: AUT_PREDICATE): AUT_PREDICATE_VALUATION is
			-- New valuation for `a_predicate'
		require
			a_predicate_attached: a_predicate /= Void
		do
			inspect
				a_predicate.arity
			when 0 then
				create {AUT_NULLARY_PREDICATE_VALUATION} Result.make (a_predicate)
			when 1 then
				create {AUT_UNARY_PREDICATE_VALUATION} Result.make (a_predicate)
			when 2 then
				create {AUT_BINARY_PREDICATE_VALUATION} Result.make (a_predicate)
			else
				create {AUT_NNARY_PREDICATE_VALUATION} Result.make (a_predicate)
			end
		ensure
			result_attached: Result /= Void
			result_valid: Result.predicate = a_predicate
		end

	fix_free_variables (a_dest_candidate: ARRAY [detachable ITP_VARIABLE]; a_source_candidate: ARRAY [detachable ITP_VARIABLE]) is
			-- Set corresponding variables in `a_source_candidate' into `a_dest_candidate' in case if that variable in `a_dest_candidate'
			-- is free.
		require
			a_dest_candidate_attached: a_dest_candidate /= Void
			a_source_candidate_attached: a_source_candidate /= Void
		do
			a_dest_candidate.do_if_with_index (
				agent (a_var: ITP_VARIABLE; a_index: INTEGER; a_dest, a_source: ARRAY [detachable ITP_VARIABLE])
					do
						a_dest.put (a_source.item (a_index), a_index)
					end (?, ?, a_dest_candidate, a_source_candidate),

				agent (a_var: ITP_VARIABLE; a_index: INTEGER): BOOLEAN
					do
						Result := a_var = Void
					end)
		end

invariant
	predicate_valuation_table_attached: valuation_table /= Void
	predicate_valuation_table_valid: not valuation_table.has (Void) and not valuation_table.has_item (Void)
	cursor_factory_attached: valuation_cursor_factory /= Void

note
	copyright: "Copyright (c) 1984-2009, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

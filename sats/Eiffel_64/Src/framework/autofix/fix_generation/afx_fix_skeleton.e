note
	description: "Summary description for {AFX_FIX_SKELETON}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

deferred class
	AFX_FIX_SKELETON

inherit
	SHARED_SERVER

	AFX_SHARED_STATE_SERVER

	AFX_STATE_PARTITIONER

	REFACTORING_HELPER

	SHARED_EIFFEL_PARSER

feature -- Access

	exception_spot: AFX_EXCEPTION_SPOT
			-- Exception related information

	precondition: AFX_STATE
			-- Fix precondition

	postcondition: AFX_STATE
			-- Fix postcondition

	guard_condition: detachable AFX_EXPRESSION
			-- Expression used as guard in the generated fix.
			-- If attached, generate fix like: (p is this guard):
			--	 if p then
			--		snippet
			--   end
			--
			-- If False, generate fix like:
			--     snippet

	relevant_ast: LINKED_LIST [AFX_AST_STRUCTURE_NODE]
			-- Relevant AST nodes, that may be modified by current fix.
			-- The order of the nodes in the list is important.
			-- If the list is empty, the fix is to be generated at the end of the recipient.			
			-- Note: all the nodes in the list should also exist in `exception_spot'.`recipient_ast_structure'.

	fixes: LINKED_LIST [AFX_FIX]
			-- List of possible fixes all of which conforms to current skeleton
			-- Generated by the last `generate'.

	relevant_break_points: TUPLE [passing_bpslot: INTEGER; failing_bpslot: INTEGER]
			-- Relevant break points, one for passing runs, one for failing runs.
			-- Those break points will be used to infer state invariants.
		deferred
		end

feature -- Access

	ranking: AFX_FIX_RANKING
			-- Ranking for Current fix skeleton

feature -- Status report

	is_relevant_ast_valid: BOOLEAN
			-- Is `relevant_ast' valid?
		do
			Result := True
		end

	is_afore: BOOLEAN
			-- Is Current an afore fix skeleton?
		do
		end

	is_wrap: BOOLEAN
			-- Is Current a wrap fix skeleton?
		do
		end

feature -- Setting

	set_guard_condition (a_condition: like guard_condition)
			-- Set `guard_condition' with `a_condition'.
		do
			guard_condition := a_condition
		ensure
			guard_condition_set: guard_condition = a_condition
		end

	set_precondition (a_precondition: like precondition)
			-- Set `precondition' with `a_precondition'.
		do
			precondition := a_precondition
		ensure
			precondition_set: precondition = a_precondition
		end

	set_postcondition (a_postcondition: like postcondition)
			-- Set `postcondition' with `a_postcondition'.
		do
			postcondition := a_postcondition
		ensure
			postcondition_set: postcondition = a_postcondition
		end

	set_relevant_ast (a_asts: like relevant_ast)
			-- Set `relevant_ast' with `a_asts'.
		do
			relevant_ast.wipe_out
			relevant_ast.append (a_asts)
		end

	set_ranking (a_ranking: like ranking)
			-- Set `ranking' with `a_ranking'.
		do
			ranking := a_ranking
		ensure
			ranking_set: ranking = a_ranking
		end

feature -- Basic operations

	generate
			-- Generate fixes and store result in `fixes'.
		local
			l_passing_bpslot: INTEGER
			l_failing_bpslot: INTEGER
			l_contracts: TUPLE [precondition: AFX_STATE; postcondition: AFX_STATE]
			l_precondition: AFX_STATE
			l_postcondition: AFX_STATE
--			l_fixes: LINKED_LIST [TUPLE [fix: STRING; ranking: INTEGER]]
			l_pre_hie: like state_hierarchy
			l_post_hie: like state_hierarchy
			l_premises: ARRAY [AFX_EXPRESSION]
			l_premise_skeleton: AFX_STATE_SKELETON
			l_premise_combi: LINKED_LIST [AFX_STATE_SKELETON]
			i, k: INTEGER
			l_snippets: like fix_snippets
			l_fix: AFX_FIX
		do
				-- Decide precondition and postcondition for the fix.
			l_contracts := actual_fix_contracts
			l_precondition := l_contracts.precondition
			l_postcondition := l_contracts.postcondition

			create fixes.make
			if l_postcondition.is_empty then
				create l_fix
				l_fix.set_text ("")
				l_fix.set_ranking (ranking.twin)
				fixes.extend (l_fix)
			else
					-- Get all combinations of premises that we want to include in a fix.
				l_pre_hie := state_hierarchy (l_precondition)
				l_post_hie:= state_hierarchy (l_postcondition)
				l_snippets := fix_snippets (l_pre_hie, l_post_hie)
				generate_fixes_from_snippet (l_snippets)
			end

			debug
				from
					fixes.start
				until
					fixes.after
				loop
					print_fix (fixes.item_for_iteration.text)
					fixes.forth
				end
			end
		end

feature{NONE} -- Implementation

	actual_fix_contracts: TUPLE [precondition: AFX_STATE; postcondition: AFX_STATE]
			-- Actual pre-/postconditions for current fix
			-- `precondition' or `postcondition' may be empty.
		local
			l_precondition: AFX_STATE
			l_postcondition: AFX_STATE
			l_bpslots: TUPLE [passing_bpslot: INTEGER; failing_bpslot: INTEGER]
		do
				-- Calculate actual precondition for current fix:
				-- 1. If the precondition is given, use the given one;
				-- 2. otherwise, use an empty precondition
			if attached {AFX_STATE} precondition as l_pre then
				l_precondition := l_pre
			else
				create l_precondition.make (10, exception_spot.recipient_class_, exception_spot.recipient_)
			end

				-- Calculate actual postcondition for current fix:
				-- 1. If the postcondition is given, use the given one;
				-- 2. otherwise, calculate the postcodition from two break points.
			if attached {AFX_STATE} postcondition as l_post then
				l_postcondition := l_post
			else
				l_bpslots := relevant_break_points
				if attached {AFX_STATE} state_invariant_difference (l_bpslots.passing_bpslot, l_bpslots.failing_bpslot) as l_diff then
					l_postcondition := l_diff
				else
					create l_postcondition.make (10, exception_spot.recipient_class_, exception_spot.recipient_)
				end
			end

			Result := [l_precondition, l_postcondition]
		end

	feature_body_compound_ast: EIFFEL_LIST [INSTRUCTION_AS]
			-- AST node for body of `exception_spot'.`recipient_'
			-- It is the compound part of a DO_AS.
		do
			if attached {BODY_AS} exception_spot.recipient_.body.body as l_body then
				if attached {ROUTINE_AS} l_body.content as l_routine then
					if attached {DO_AS} l_routine.routine_body as l_do then
						Result := l_do.compound
					end
				end
			end
		end

	generate_fixes_from_snippet (a_snippets: LINKED_LIST [TUPLE [snippet: STRING_8; ranking: INTEGER_32]])
			-- Generate fixes from `a_snippets' and store result in `fixes'.
		deferred
		end

	state_hierarchy (a_state: AFX_STATE): HASH_TABLE [HASH_TABLE [AFX_STATE, STRING], AFX_EXPRESSION]
			-- hierarchically partitioned states from `a_state'
		local
			l_imp_parts: HASH_TABLE [AFX_STATE, AFX_EXPRESSION]
			l_prefix_parts: HASH_TABLE [AFX_STATE, STRING]
		do
			create Result.make (20)
			Result.compare_objects

			from
				l_imp_parts := partitions_by_premise (a_state)
				l_imp_parts.start
			until
				l_imp_parts.after
			loop
				l_prefix_parts := partitions_by_expression_prefix (l_imp_parts.item_for_iteration)
				Result.put (l_prefix_parts, l_imp_parts.key_for_iteration)
				l_imp_parts.forth
			end

			debug
				io.put_string ("== Original State =============================%N")
				io.put_string (a_state.debug_output + "%N")
				io.put_string ("== Hierarchy =============================%N")
				from
					Result.start
				until
					Result.after
				loop
					io.put_string ("Premise: " + Result.key_for_iteration.text + "%N")
					from
						Result.item_for_iteration.start
					until
						Result.item_for_iteration.after
					loop
						io.put_string ("%T" + Result.item_for_iteration.key_for_iteration + "%N")
						io.put_string (Result.item_for_iteration.item_for_iteration.debug_output + "%N")
						Result.item_for_iteration.forth
					end
					Result.forth
				end
			end
		end

	state_invariant_difference (a_passing_bpslot: INTEGER; a_failing_bpslot: INTEGER): detachable AFX_STATE
			-- State invariant difference between break point `a_passing_bpslot' in passing runs and
			-- break point `a_failing_bpslot' in failing runs.
			-- If no data is associated with either break point, return Void.
		local
			l_snippets: LINKED_LIST [ETR_TRANSFORMABLE]
			l_tran: ETR_TRANSFORMABLE
			l_passing_state: AFX_STATE
			l_failing_state: AFX_STATE
			l_state: TUPLE [passing: AFX_DAIKON_RESULT; failing: AFX_DAIKON_RESULT]
			l_state_diff: AFX_STATE
		do
			l_state := state_server.state_for_fault (exception_spot.test_case_info)
			l_passing_state := l_state.passing.daikon_table.item (a_passing_bpslot)
			l_failing_state := l_state.failing.daikon_table.item (a_failing_bpslot)
			if l_passing_state /= Void and then l_failing_state /= Void then
				l_passing_state := l_passing_state.only_predicates
				l_failing_state := l_failing_state.only_predicates
				Result := l_passing_state.subtraction (l_failing_state)
			end
		end

	string_equality_tester: AGENT_BASED_EQUALITY_TESTER [STRING] is
			-- Equality tester for string
		do
			create Result.make (agent (a, b: STRING): BOOLEAN do Result := a.is_equal (b) end)
		end


	state_transitions (a_source_state: HASH_TABLE [AFX_STATE, STRING]; a_target_state: HASH_TABLE [AFX_STATE, STRING]): LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]]
			-- List of transitions to direct state from `a_source_state' to `a_target_state'
		local
			l_source_state: DS_HASH_TABLE [AFX_STATE, STRING]
			l_target_state: DS_HASH_TABLE [AFX_STATE, STRING]
			l_class: CLASS_C
			l_feature: detachable FEATURE_I
			l_empty: LINKED_LIST [STRING]
		do
			l_source_state := hash_table_to_ds_hash_table (a_source_state)
			l_target_state := hash_table_to_ds_hash_table (a_target_state)

			create l_empty.make
			l_target_state.do_all_with_key (agent (
				item: AFX_STATE; key: STRING; a_list: LINKED_LIST [STRING])
					do
						if item.is_empty then
							a_list.extend (key)
						end
					end (?, ?, l_empty))
			l_empty.do_all (agent l_target_state.remove)

				-- Duplicate object path expression prefixes from target state to source state.
			fixme ("This may not be necessary in the future. 18.12.2009 Jasonw")
			l_target_state.do_all_with_key (
				agent (item: AFX_STATE; key: STRING; data: DS_HASH_TABLE [AFX_STATE, STRING])
					local
						l_dummy_state: AFX_STATE
					do
						if not data.has (key) then
							create l_dummy_state.make (0, item.class_, item.feature_)
							data.force (l_dummy_state, key)
						end
					end (?, ?, l_source_state))
			create Result.make
			Result.extend ([create {DS_LINKED_LIST [STRING]}.make_from_array (<<"do_nothing">>), 0])
		ensure
			result_attached: Result /= Void
		end

	hash_table_to_ds_hash_table (a_hash_table: HASH_TABLE [AFX_STATE, STRING]): DS_HASH_TABLE [AFX_STATE, STRING]
			-- DS_HASH_TABLE from HASH_TABLE
		local
			l_cursor: CURSOR
		do
			fixme ("To be removed. 18.12.2009 Jasonw")
			create Result.make (a_hash_table.count)
			Result.set_key_equality_tester (string_equality_tester)
			l_cursor := a_hash_table.cursor
			from
				a_hash_table.start
			until
				a_hash_table.after
			loop
				Result.force (a_hash_table.item_for_iteration, a_hash_table.key_for_iteration)
				a_hash_table.forth
			end
			a_hash_table.go_to (l_cursor)
		end


	call_sequences (a_source_state: like state_hierarchy; a_target_state: like state_hierarchy): HASH_TABLE [LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]], AFX_EXPRESSION]
			-- Possible call sequences to change the system from `a_source_state' to `a_target_state'.
		local
			l_source: HASH_TABLE [AFX_STATE, STRING]
		do
			fixme ("We ingore `a_source_state' for the moment. 18.12.2009 Jasonw")
			create l_source.make (0)
			l_source.compare_objects
			create Result.make (10)
			from
				a_target_state.start
			until
				a_target_state.after
			loop
				check a_target_state.key_for_iteration /= Void end
				Result.force (state_transitions (l_source, a_target_state.item_for_iteration), a_target_state.key_for_iteration)
				a_target_state.forth
			end
		end

	text_of_fix (a_premise: AFX_EXPRESSION; a_sequences: DS_LIST [STRING]): STRING
			--
		local
			l_tab: STRING
		do
			create Result.make (512)
			if not a_premise.is_true_expression then
				Result.append ("if ")
				Result.append (a_premise.text)
				Result.append (" then%N")
				l_tab := "%T"
			else
				l_tab := ""
			end
			from
				a_sequences.start
			until
				a_sequences.after
			loop
				Result.append (l_tab)
				Result.append (a_sequences.item_for_iteration)
				Result.append ("%N")
				a_sequences.forth
			end
			if not a_premise.is_true_expression then
				Result.append ("end%N")
			end
		end

	text_of_fixes (a_candidates: HASH_TABLE [LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]], AFX_EXPRESSION]): LINKED_LIST [TUPLE [snippet: STRING; ranking: INTEGER]]
		local
			l_array: ARRAY [TUPLE [seq: LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]]; premise: AFX_EXPRESSION]]
			i, j, c: INTEGER
			l_done: BOOLEAN
			l_ranking: INTEGER
			l_fix: STRING
			l_data: TUPLE [seq: LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]]; premise: AFX_EXPRESSION]
			l_premise: AFX_EXPRESSION
		do
			create Result.make
			c := a_candidates.count
			create l_array.make (1, c)
			from
				i := 1
				a_candidates.start
			until
				a_candidates.after
			loop
				check a_candidates.key_for_iteration /= Void end
				a_candidates.item_for_iteration.start
				a_candidates.item_for_iteration.back
				l_array.put ([a_candidates.item_for_iteration, a_candidates.key_for_iteration], i)
				i := i + 1
				a_candidates.forth
			end

			from
				i := 1
			until
				l_done
			loop
				l_array.item (i).seq.forth
				if l_array.item (i).seq.after then
					l_array.item (i).seq.start
					l_array.item (i).seq.back
					i := i - 1
					if i = 0 then
						l_done := True
					end
				else
					if i = c then
						create l_fix.make (1024)
						l_ranking := 0
						from
							j := 1
						until
							j > c
						loop
							l_data := l_array.item (j)
							l_premise := l_data.premise
							l_fix.append (text_of_fix (l_premise, l_data.seq.item_for_iteration.transitions))
							l_ranking := l_ranking + l_data.seq.item_for_iteration.ranking
							j := j + 1
						end
						Result.extend ([l_fix, l_ranking])
						l_array.item (i).seq.forth
					else
						i := i + 1
					end
				end
			end
		end

	fix_snippets (a_source_state: like state_hierarchy; a_target_state: like state_hierarchy): LINKED_LIST [TUPLE [snippet: STRING; ranking: INTEGER]]
			-- Fix snippets to change the system from `a_source_state' to `a_target_state'
		local
			l_sequences: like call_sequences
			l_premise_skeleton: AFX_STATE_SKELETON
			i, k: INTEGER
			l_combinations: LINKED_LIST [AFX_STATE_SKELETON]
			l_temp: HASH_TABLE [LINKED_LIST [TUPLE [transitions: DS_LIST [STRING]; ranking: INTEGER]], AFX_EXPRESSION]
			l_comb: AFX_STATE_SKELETON
		do
			create Result.make
			l_sequences := call_sequences (a_source_state, a_target_state)
			create l_premise_skeleton.make_basic (exception_spot.recipient_class_, exception_spot.recipient_, 0)
			l_sequences.current_keys.do_all (agent l_premise_skeleton.force_last)

			from
				i := 1
				k := 2
			until
				i > k
			loop
					-- Get a combination of premises.
				l_combinations := l_premise_skeleton.combinations (i)
				from
					l_combinations.start
				until
					l_combinations.after
				loop
					l_comb := l_combinations.item_for_iteration
					create l_temp.make (l_comb.count)
					l_temp.compare_objects
					from
						l_comb.start
					until
						l_comb.after
					loop
						l_temp.force (l_sequences.item (l_comb.item_for_iteration), l_comb.item_for_iteration)
						l_comb.forth
					end
					Result.append (text_of_fixes (l_temp))
					l_combinations.forth
				end

				i := i + 1
			end
		end

	print_fix (a_fix: STRING)
			-- Print `a_fix'.
		local
			l_printer: ETR_AST_STRUCTURE_PRINTER
			l_output: ETR_AST_STRING_OUTPUT
			l_feature_text: STRING
		do
			l_feature_text := "feature bar do " + a_fix + " end"
			entity_feature_parser.parse_from_string (l_feature_text, Void)
			create l_output.make_with_indentation_string ("%T")
			create l_printer.make_with_output (l_output)
			l_printer.print_ast_to_output (entity_feature_parser.feature_node)
			io.put_string ("------------------------------------------------%N")
			io.put_string (l_output.string_representation)
			io.put_string ("")
		end

end

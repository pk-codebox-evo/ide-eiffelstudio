note
	description: "Summary description for {AFX_SMTLIB_FILE_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_SMTLIB_FILE_GENERATOR

feature -- Access

	last_smtlib: detachable STRING
			-- Last string generated by `generate'

feature -- Basic operations

	generate (a_formula: AFX_SMTLIB_EXPR; a_theory: AFX_THEORY)
			-- Generate SMTLIB file to check `a_formula' in `a_theory'.
			-- Store result in `last_smtlib'.
		do
			create last_smtlib.make (2048)
			generate_header
			generate_theory (a_theory)
			generate_formula (a_formula)
		end

	generate_for_tautology_checking (a_expr: AFX_EXPRESSION; a_state: AFX_STATE_SKELETON)
			-- Generate SMTLIB to check if `a_expr' is a tautology in the context of `a_state'.
			-- Store result in `last_smtlib'.
		do
			generate (a_expr.as_smtlib_expression, a_state.theory)
		end

	generate_for_implied_checking (a_exprs1: LINEAR [AFX_EXPRESSION]; a_exprs2: LINEAR [AFX_EXPRESSION]; a_theory: AFX_THEORY)
			-- Generate SMTLIB to check if `a_expr2' can be implied from `a_exprs1' in the context of `a_theory'.
			-- Store result in `last_smtlib'.
		local
			l_exprs1: LINKED_LIST [AFX_SMTLIB_EXPR]
			l_exprs2: LINKED_LIST [AFX_SMTLIB_EXPR]
		do
			l_exprs1 := expressions_to_smtlib_expressions (a_exprs1)
			l_exprs2 := expressions_to_smtlib_expressions (a_exprs2)

			generate (smt_implied_expression (smt_connected_expression (l_exprs1, "and"), smt_connected_expression (l_exprs2, "and")), a_theory)
		end

feature -- Access

	smt_implied_expression (a_left: AFX_SMTLIB_EXPR; a_right: AFX_SMTLIB_EXPR): AFX_SMTLIB_EXPR
			-- SMTLIB expression for the implication: `a_left' implies `a_right'
		local
			l_content: STRING
		do
			create l_content.make (512)
			l_content.append (once "(implies (")
			l_content.append (a_left.expression)
			l_content.append (once ") (")
			l_content.append (a_right.expression)
			l_content.append (once "))")
			create Result.make (l_content)
		end

	smt_connected_expression (a_exprs: LIST [AFX_SMTLIB_EXPR]; a_operator: STRING): AFX_SMTLIB_EXPR
			-- SMTLIB expressions from `a_exprs', connected by `a_operator'
		local
			l_content: STRING
			l_cursor: CURSOR
		do
			create l_content.make (512)
			l_content.append (once "(")
			l_content.append (a_operator)
			l_content.append_character (' ')

			from
				a_exprs.start
			until
				a_exprs.after
			loop
				l_content.append (once "%N(")
				l_content.append (a_exprs.item_for_iteration.expression)
				l_content.append (once ")")
				a_exprs.forth
			end
			l_content.append (once ")%N")
			create Result.make (l_content)
		end

	expressions_to_smtlib_expressions (a_exprs: LINEAR [AFX_EXPRESSION]): LINKED_LIST [AFX_SMTLIB_EXPR]
			-- Expressions to SMTLIB expressions.
		do
			create {LINKED_LIST [AFX_SMTLIB_EXPR]} Result.make
			a_exprs.do_all (
				agent (a_exp: AFX_EXPRESSION; a_list: LINKED_LIST [AFX_SMTLIB_EXPR])
					do
						a_list.extend (a_exp.as_smtlib_expression)
					end (?, Result))
		end

feature{NONE} -- Implementation

	generate_header
			-- Generate header in `last_smtlib'.
		do
			last_smtlib.append ("[
				(benchmark example
				:status unsat
				:logic QF_UFLIA%N
			]")
		end

	generate_theory (a_theory: AFX_THEORY)
			-- Generate `a_theory' into `last_smtlib'.
		do
			a_theory.functions.do_all (agent append_line)
			a_theory.axioms.do_all (agent append_line)
		end

	generate_formula (a_formula: AFX_SMTLIB_EXPR)
			-- Generate `a_formula' into `last_smtlib'.
		do
			last_smtlib.append (":formula (not (%N")
			last_smtlib.append (a_formula.expression)
			last_smtlib.append ("%N)))")
		end

	append_line (a_content: AFX_SMTLIB_EXPR)
			-- Append `a_content' into `last_smtlib' in its own line.
		do
			last_smtlib.append (a_content.expression)
			last_smtlib.append_character ('%N')
		end

end

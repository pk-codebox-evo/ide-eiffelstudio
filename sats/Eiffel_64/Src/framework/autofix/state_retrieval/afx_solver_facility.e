note
	description: "Summary description for {AFX_SOLVER_LAUNCHER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

deferred class
	AFX_SOLVER_FACILITY

inherit
	AFX_SOLVER_FACTORY

	REFACTORING_HELPER

	AFX_SOLVER_CONSTANTS

feature -- Basic operations

	has_implication (a_list1: LINEAR [AFX_EXPRESSION]; a_list2: LINEAR [AFX_EXPRESSION]; a_theory: AFX_THEORY): BOOLEAN
			-- Does the conjunction of `a_list1' imply the conjunction of `a_list2'
			-- in the context of `a_theory'?
		require
			a_list1_not_empty: not a_list1.is_empty
			a_list2_not_empty: not a_list2.is_empty
		local
			l_expr: AFX_EXPRESSION
			l_result: like solver_output_for_expressions
			l_list: LINKED_LIST [AFX_EXPRESSION]
		do
				-- Create a dummy expression.
			a_list1.start
			l_expr := a_list1.item_for_iteration
			create {AFX_AST_EXPRESSION} l_expr.make_with_text (l_expr.class_, l_expr.feature_, "Current", l_expr.written_class)
			create l_list.make
			l_list.extend (l_expr)
			solver_file_generator.generate_for_implied_checking (a_list1, a_list2, a_theory)
			l_result := solver_output_for_expressions (l_list, solver_file_generator.last_content)

			if not l_result.is_empty then
				l_result.start
				Result := l_result.item_for_iteration ~ boogie_verified_tag
			end
		end

feature -- Access

	simplified_skeleton (a_skeleton: AFX_STATE_SKELETON): AFX_STATE_SKELETON
			-- Simplified version of `a_skeleton'
			-- Result is simplified from `a_skeleton' by doing the following:
			-- Remove all tautologies from `a_skeleton'.
		local
			l_expr_list: LINKED_LIST [AFX_EXPRESSION]
			l_tautologies: AFX_STATE_SKELETON
		do
			l_tautologies := tautologies (a_skeleton)
			create l_expr_list.make

			a_skeleton.do_if (
				agent l_expr_list.extend,
				agent (a_expr: AFX_EXPRESSION; a_tau: AFX_STATE_SKELETON): BOOLEAN
						do
							Result := not a_tau.has (a_expr)
						end (?, l_tautologies))

			create Result.make_with_expressions (a_skeleton.class_, a_skeleton.feature_, l_expr_list)
		end

	tautologies (a_skeleton: AFX_STATE_SKELETON): AFX_STATE_SKELETON
			-- Tautology expressions from `a_skeleton'
		do
			create Result.make_with_expressions (
				a_skeleton.class_,
				a_skeleton.feature_,
				valid_expressions (a_skeleton.linear_representation, a_skeleton.theory))
		end

	valid_expressions (a_expressions: LINEAR [AFX_EXPRESSION]; a_theory: AFX_THEORY): LIST [AFX_EXPRESSION]
			-- List of valid formulae from `a_expressions' in the context of `a_theory'
		local
			l_generator: like solver_file_generator
			l_list: LINKED_LIST [AFX_SOLVER_EXPR]
			l_expr_list: LINKED_LIST [AFX_EXPRESSION]
			l_expr: AFX_EXPRESSION
			l_output: HASH_TABLE [STRING, AFX_EXPRESSION]
		do
				-- Build solver input.
			create l_list.make
			create l_expr_list.make
			from
				a_expressions.start
			until
				a_expressions.after
			loop
				l_expr := a_expressions.item_for_iteration
				if l_expr.is_predicate then
					l_expr_list.extend (l_expr)
					l_list.extend (l_expr.as_solver_expression)
				end
				a_expressions.forth
			end

				-- Generate solver input file and start the solver.
			l_generator := solver_file_generator
			l_generator.generate_formulae (l_list, a_theory)
			l_output := solver_output_for_expressions (l_expr_list, l_generator.last_content)

				-- Build final result.
			create {LINKED_LIST [AFX_EXPRESSION]} Result.make
			from
				l_output.start
			until
				l_output.after
			loop
				if l_output.item_for_iteration.is_equal (boogie_verified_tag) then
					Result.extend (l_output.key_for_iteration)
				end
				l_output.forth
			end
		end

	minimized_premises (a_skeleton: AFX_STATE_SKELETON; a_predicate: AFX_EXPRESSION; a_context: AFX_STATE_SKELETON): detachable AFX_STATE_SKELETON
			-- Smallest state S (containing possibly fewer predicates than `a_skeleton') that, when accompanied
			-- with `a_context', implies `a_predicate': a_context ^ S -> a_predicate
			-- in `last_skeleton'. If no such state is found, set `last_skeleton' to Void.
		require
			a_predicate_valid: a_predicate.type.is_boolean
		do
			if a_skeleton implies a_predicate.as_skeleton then
				Result := minimal_premises_ddmin (a_skeleton, 2, a_predicate, a_context)
			end
		ensure
			result_correct: Result /= Void implies Result.count <= a_skeleton.count
		end

	minimal_premises_ddmin (a_skeleton: AFX_STATE_SKELETON; a_granularity: INTEGER; a_predicate: AFX_EXPRESSION; a_context: detachable AFX_STATE_SKELETON): detachable AFX_STATE_SKELETON
			-- Minimal subset of `a_skeleton' which, when accompanied with `a_context', implies `a_predicate', generated by delta deubbing.
			-- `a_granularity' is the granularity for delta debugging.
			-- Return Void if no such subset is found.
		local
			l_slices: LINKED_LIST [detachable AFX_STATE_SKELETON]
			l_done: BOOLEAN
			l_subset: detachable AFX_STATE_SKELETON
			l_premises: detachable AFX_STATE_SKELETON
		do
			if a_skeleton.count = 1 then
				Result := a_skeleton
			else
				l_slices := a_skeleton.slices (a_granularity)
				from
					l_slices.start
				until
					l_slices.after or l_done
				loop
					l_subset := a_skeleton.subtraction (l_slices.item_for_iteration)

					if a_context /= Void then
						l_premises := l_subset.union (a_context)
					else
						l_premises := l_subset
					end
					if l_premises implies a_predicate.as_skeleton then
						l_done := True
						Result := minimal_premises_ddmin (l_subset, (2).max (a_granularity - 1), a_predicate, a_context)
					end
					l_slices.forth
				end

					-- Increase granularity.
				if not l_done then
					if a_granularity < a_skeleton.count then
						Result := minimal_premises_ddmin (a_skeleton, a_skeleton.count.min (2 * a_granularity), a_predicate, a_context)
					end
				end
			end
		end

feature{NONE} -- Implementation

	generate_file (a_content: STRING)
			-- Generate solver file containing `a_content'.
		deferred
		end

	solved_path (a_path: STRING): STRING
			-- Solved path of `a_path'
			-- If in Windows, Result will be equal to `a_path',
			-- otherwise, Result will be the path as seen by Wine.
		local
			l_prc_factory: PROCESS_FACTORY
			l_prc: PROCESS
		do
			if {PLATFORM}.is_windows then
				Result := a_path.twin
			else
				Result := output_from_program ("/bin/sh -c %"winepath -w " + a_path + "%"", Void)
				Result.replace_substring_all ("%N", "")
			end
		end

	output_from_program (a_command: STRING; a_working_directory: detachable STRING): STRING
			-- Output from the execution of `a_command' in (possibly) `a_working_directory'.
			-- Note: You may need to prune the final new line character.
		local
			l_prc_factory: PROCESS_FACTORY
			l_prc: PROCESS
			l_buffer: STRING
		do
			create l_prc_factory
			l_prc := l_prc_factory.process_launcher_with_command_line (a_command, a_working_directory)
			create Result.make (1024)
			l_prc.redirect_output_to_agent (agent Result.append ({STRING}?))
			l_prc.launch
			if l_prc.launched then
				l_prc.wait_for_exit
			end
		end

	solver_output (a_content: STRING): STRING
			-- Output from the solver for input `a_content'
		deferred
		end

	solver_output_for_expressions (a_expressions: LINEAR [AFX_EXPRESSION]; a_solver_input: STRING): HASH_TABLE [STRING, AFX_EXPRESSION]
			-- Output from the solver for checking `a_expressions' in the context of `a_solver_input'.
			-- `a_solver_input' is the input fed to the underlying theorem prover.
			-- Result is a table, key is the expression, value is the solver output for that expression':
			-- output can be either "verified" or "error".
		deferred
		end

end

note
	description: "Summary description for {AFX_STATE_SIMPLIFIER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_STATE_SKELETON_SIMPLIFIER

inherit
	AFX_SHARED_SMTLIB_GENERATOR

feature -- Access

	last_skeleton: detachable AFX_STATE_SKELETON
			-- Last state simplified by `simplify'

feature -- Basic operations

	simplify (a_skeleton: like last_skeleton)
			-- Simplify `a_skeleton', store result in `last_skeleton'.
			-- `last_skeleton' is simplified from `a_skeleton' by doing the following:
			-- Remove all tautologies from `a_skeleton'.
		local
			l_kept_exprs: DS_HASH_SET [AFX_EXPRESSION]
			l_done: BOOLEAN
			l_implied_expr: detachable AFX_EXPRESSION
			l_expr_list: LINKED_LIST [AFX_EXPRESSION]
		do
			create l_kept_exprs.make (a_skeleton.count)
			l_kept_exprs.set_equality_tester (create {AFX_EXPRESSION_EQUALITY_TESTER})

				-- Remove all tautology expressions.
			a_skeleton.do_if (agent l_kept_exprs.force_last, agent is_expression_non_tautology (?, a_skeleton))

				-- Construct `last_skeleton'.
			create l_expr_list.make
			l_kept_exprs.do_all (agent l_expr_list.extend)
			create last_skeleton.make_with_expressions (a_skeleton.class_, a_skeleton.feature_, l_expr_list)
		end

	minimize_premises (a_skeleton: like last_skeleton; a_predicate: AFX_EXPRESSION; a_context: like last_skeleton)
			-- Store the smallest state (containing possibly fewer predicates than `a_skeleton') that, when accompanied
			-- with `a_context', implies `a_predicate': a_context ^ a_skeleton -> a_predicate
			-- in `last_skeleton'. If no such state is found, set `last_skeleton' to Void.
		require
			a_predicate_valid: a_predicate.type.is_boolean
		do
			if a_skeleton implies a_predicate.as_skeleton then
				last_skeleton := minimal_premises_ddmin (a_skeleton, 2, a_predicate, a_context)
			else
				last_skeleton := Void
			end
		ensure
			last_skeleton_correct: last_skeleton /= Void implies last_skeleton.count <= a_skeleton.count
		end

feature{NONE} -- Implementation

	is_expression_tautology (a_expr: AFX_EXPRESSION; a_skeleton: like last_skeleton): BOOLEAN
			-- Is `a_expr' a tautology in the context of `a_skeleton'?
		require
			a_expr_in_a_state: a_skeleton.has (a_expr)
		do
			smtlib_generator.generate_for_tautology_checking (a_expr, a_skeleton)
			Result := z3_launcher.is_unsat (smtlib_generator.last_smtlib)
		end

	is_expression_non_tautology (a_expr: AFX_EXPRESSION; a_skeleton: like last_skeleton): BOOLEAN
			-- Is `a_expr' not a tautology in the context of `a_skeleton'?
		require
			a_expr_in_a_state: a_skeleton.has (a_expr)
		do
			Result := not is_expression_tautology (a_expr, a_skeleton)
		end

	implied_expression (a_expressions: DS_HASH_SET [AFX_EXPRESSION]; a_skeleton: like last_skeleton): detachable AFX_EXPRESSION
			-- A random expression from `a_expressions' which can be implied by the other expressions
			-- in `a_expressions'. Void if no such expression is found.
		local
			l_cursor: DS_HASH_SET_CURSOR [AFX_EXPRESSION]
			l_exprs: like a_expressions
			l_expr: AFX_EXPRESSION
			l_list: LINKED_LIST [AFX_EXPRESSION]
			l_single_list: LINKED_LIST [AFX_EXPRESSION]
		do
			from
				l_exprs := a_expressions.twin
				l_cursor := a_expressions.new_cursor
				l_cursor.start
			until
				l_cursor.after or else l_cursor.after
			loop
				l_expr := l_cursor.item
				l_exprs.remove (l_expr)
				create l_list.make
				l_exprs.do_all (agent l_list.extend)
				create l_single_list.make
				l_single_list.extend (l_expr)
				smtlib_generator.generate_for_implied_checking (l_list, l_single_list, a_skeleton.theory)
				if z3_launcher.is_unsat (smtlib_generator.last_smtlib) then
					Result := l_expr
				else
					l_exprs.force_last (l_expr)
				end
				l_cursor.forth
			end
		ensure
			good_result: Result /= Void implies a_expressions.has (Result)
		end

	minimal_premises_ddmin (a_skeleton: attached like last_skeleton; a_granularity: INTEGER; a_predicate: AFX_EXPRESSION; a_context: like last_skeleton): like last_skeleton
			-- Minimal subset of `a_skeleton' which, when accompanied with `a_context', implies `a_predicate', generated by delta deubbing.
			-- `a_granularity' is the granularity for delta debugging.
			-- Return Void if no such subset is found.
		local
			l_slices: LINKED_LIST [like last_skeleton]
			l_done: BOOLEAN
			l_subset: like last_skeleton
			l_premises: like last_skeleton
		do
			if a_skeleton.count = 1 then
				Result := a_skeleton
			else
				l_slices := a_skeleton.slices (a_granularity)
				from
					l_slices.start
				until
					l_slices.after or l_done
				loop
					l_subset := a_skeleton.subtraction (l_slices.item_for_iteration)

					if a_context /= Void then
						l_premises := l_subset.union (a_context)
					else
						l_premises := l_subset
					end
					if l_premises implies a_predicate.as_skeleton then
						l_done := True
						Result := minimal_premises_ddmin (l_subset, (2).max (a_granularity - 1), a_predicate, a_context)
					end
					l_slices.forth
				end

					-- Increase granularity.
				if not l_done then
					if a_granularity < a_skeleton.count then
						Result := minimal_premises_ddmin (a_skeleton, a_skeleton.count.min (2 * a_granularity), a_predicate, a_context)
					end
				end
			end
		end

end


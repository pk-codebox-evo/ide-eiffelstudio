note
	description: "Summary description for {AFX_EQUATION_TO_EXPRESSION_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_EQUATION_TO_EXPRESSION_GENERATOR

inherit
	AFX_EXPRESSION_VALUE_VISITOR

feature -- Access

	last_expression: detachable AFX_EXPRESSION
			-- Last expression generated by `generate'

feature -- Basic operations

	generate (a_equation: AFX_EQUATION)
			-- Generator expression from `a_equation'
		do
			expression_text := a_equation.expression.text
			class_ := a_equation.class_
			feature_ := a_equation.feature_
			written_class := a_equation.expression.written_class
			a_equation.value.process (Current)
		end

feature{NONE} -- Implementation

	expression_text: detachable STRING
			-- Text for expression part of an equation

	template: detachable STRING
			-- Template for the final expression

	place_holder (a_tag: STRING): STRING
			-- Place holder with `a_tag'.
		do
			create Result.make (a_tag.count + 4)
			Result.append (once "{{")
			Result.append (a_tag)
			Result.append (once "}}")
		end

	expression_place_holder: STRING is "{{e}}"

	value_place_holder: STRING is "{{v}}"

	class_: CLASS_C
			-- Context class

	feature_: detachable FEATURE_I
			-- Context feature

	written_class: CLASS_C
			-- Written class

feature -- Process

	process_deterministic_value (a_value: AFX_EXPRESSION_VALUE)
				-- Process `a_value'
		require
			a_value_is_deterministic: a_value.is_deterministic
		local
			l_text: STRING
		do
			l_text := expression_text + " = " + a_value.item.out
			create {AFX_AST_EXPRESSION} last_expression.make_with_text (class_, feature_, l_text, written_class)
		end

	process_boolean_value (a_value: AFX_BOOLEAN_VALUE)
			-- Process `a_value'.
		do
			process_deterministic_value (a_value)
		end

	process_random_boolean_value (a_value: AFX_RANDOM_BOOLEAN_VALUE)
			-- Process `a_value'.
		local
			l_text: STRING
		do
			l_text := "(" + expression_text + ") or not (" + expression_text + ")"
			create {AFX_AST_EXPRESSION} last_expression.make_with_text (class_, feature_, l_text, written_class)
		end

	process_integer_value (a_value: AFX_INTEGER_VALUE)
			-- Process `a_value'.
		do
			process_deterministic_value (a_value)
		end


	process_random_integer_value (a_value: AFX_RANDOM_INTEGER_VALUE)
			-- Process `a_value'.
		local
			l_text: STRING
		do
			l_text := "(" + expression_text + " >= " + min_integer_value.out + ") and (" + expression_text + " <= " + max_integer_value.out + ")"
			create {AFX_AST_EXPRESSION} last_expression.make_with_text (class_, feature_, l_text, written_class)
		end

	process_nonsensical_value (a_value: AFX_NONSENSICAL_VALUE)
			-- Process `a_value'.
		do
			check should_not_happen: False end
		end

	process_void_value (a_value: AFX_VOID_VALUE)
			-- Process `a_value'.
		do
			check should_not_happen: False end
		end

feature{NONE} -- Implementation

	max_integer_value: INTEGER
			-- Max integer value
		do
			Result := {INTEGER_32}.max_value
		end

	min_integer_value: INTEGER
			-- Min integer value
		do
			Result := {INTEGER_32}.min_value
		end

end

note
	description: "Summary description for {AFX_TEST_CASE_RUNNER_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_TEST_CASE_RUNNER_GENERATOR

inherit
	AFX_UTILITY
		rename
			system as old_system
		end

create
	make

feature{NONE} -- Implementation

	make (a_system: like system; a_config: like config; a_failing_test_cases: like failing_test_cases; a_passing_test_cases: like passing_test_cases)
			-- Initialize.
		do
			system := a_system
			config := a_config
			failing_test_cases := a_failing_test_cases
			passing_test_cases := a_passing_test_cases
		end

feature -- Access

	system: SYSTEM_I
			-- System under which test cases are analyzed

	config: AFX_CONFIG
			-- Config for AutoFix

	failing_test_cases: HASH_TABLE [ARRAYED_LIST [STRING], AFX_TEST_CASE_INFO]
			-- Table of failing test cases in `test_case_folder'
			-- Key is the test case id, value is the list of test cases revealing the same fault.

	passing_test_cases: HASH_TABLE [ARRAYED_LIST [STRING], AFX_TEST_CASE_INFO]
			-- Table of passing test cases in `test_case_folder'
			-- for each failing test cases.
			-- Key is the failing test cases, Value is the list of passing test cases for the same feature.

	last_class_text: detachable STRING
			-- Class test generated by last `generate'

	test_cases: LINKED_LIST [TUPLE [agent_name: STRING; uuid: STRING]]
			-- List of test cases. `agent_name' is the name of an agent to invoke a test case,
			-- `uuid' is the universal identifier for that test case.

feature -- Generation

	generate
			-- Generate the class body for the root class in `system',
			-- store result in `last_class_text'.
		local
			l_root_class_name: STRING
			l_tests: ARRAYED_LIST [STRING]
			i: INTEGER
			l_test_case: STRING
			l_test_executors: STRING
		do
			test_case_number := 1
			l_root_class_name := system.root_type.associated_class.name.twin
			create l_test_executors.make (4096 * 4)
			create test_cases.make
			from
				failing_test_cases.start
			until
				failing_test_cases.after
			loop
					-- Append failing test cases for a fault.
				l_tests := failing_test_cases.item_for_iteration
				check not l_tests.is_empty end
				append_test_case_executor (l_test_executors, l_tests.first, failing_test_cases.key_for_iteration, False, True)
				l_tests.do_all (agent append_test_case_executor (l_test_executors, ?, failing_test_cases.key_for_iteration, False, False))

					-- Append passing test cases for the same fault.
				l_tests := passing_test_cases.item (failing_test_cases.key_for_iteration)
				l_tests.do_all (agent append_test_case_executor (l_test_executors, ?, failing_test_cases.key_for_iteration, True, False))
				failing_test_cases.forth
			end

			last_class_text := root_class_body.twin
			last_class_text.replace_substring_all ("${CLASS_NAME}", l_root_class_name)
			last_class_text.replace_substring_all ("${CREATOR}", system.root_creation_name)
			last_class_text.replace_substring_all ("${INITIALIZE_TEST_CASES}", feature_for_initialize_test_cases (test_cases))
			last_class_text.replace_substring_all ("${EXECUTE_TEST_CASES}", feature_for_execute_test_cases)
			last_class_text.replace_substring_all ("${TEST_CASES}", l_test_executors)
		end

	append_test_case_executor (a_string: STRING; a_test_case_name: STRING; a_test_info: AFX_TEST_CASE_INFO; a_passing: BOOLEAN; a_dry_run: BOOLEAN)
			-- Append test case named `a_test_case_name' as the `test_case_number'-th test case
			-- into `a_string'.
			-- `a_dry_run' indicates whether the states of the system should be retrieved when the test case is executed:
			-- True means should; False means should not.
		local
			l_test_case: STRING
			l_slices: LIST [STRING]
		do
			l_slices := string_slices (a_test_case_name, "__")
			l_test_case := execute_test_case_body.twin
			l_test_case.prepend ("%T")
			l_test_case.replace_substring_all ("${TEST_CASE_NUMBER}", test_case_number.out)
			l_test_case.replace_substring_all ("${TEST_CASE_CLASS_NAME}", a_test_case_name)
			l_test_case.replace_substring_all ("${RECIPIENT_CLASS}", a_test_info.recipient_class)
			l_test_case.replace_substring_all ("${RECIPIENT}", a_test_info.recipient)
			l_test_case.replace_substring_all ("${EXCEPTION_CODE}", a_test_info.exception_code.out)
			l_test_case.replace_substring_all ("${BPSLOT}", a_test_info.breakpoint_slot.out)
			l_test_case.replace_substring_all ("${TAG}", a_test_info.tag)
			l_test_case.replace_substring_all ("${PASSING}", a_passing.out)
			l_test_case.replace_substring_all ("${DRY_RUN}", a_dry_run.out)
			l_test_case.replace_substring_all ("${UUID}", l_slices.last)

			a_string.append (l_test_case)
			a_string.append_character ('%N')
			a_string.append_character ('%N')

			if not a_dry_run then
				test_cases.extend (["execute_test_case_" + test_case_number.out, l_slices.last])
			end

			test_case_number := test_case_number + 1
		end

feature{NONE} -- Implementation

	feature_for_initialize_test_cases (a_test_cases: like test_cases): STRING
			-- Feature text for `initialize_test_cases' to setup `a_test_cases'.
		do
			create Result.make (2048)
			Result.append ("%Tinitialize_test_cases%N")
			Result.append ("%T%T%T-- Initialize `test_cases'.%N")
			Result.append ("%T%Tdo%N")
			Result.append ("%T%T%Tcreate test_cases.make (" + a_test_cases.count.out + ")%N")
			Result.append ("%T%T%Ttest_cases.compare_objects%N")
			from
				a_test_cases.start
			until
				a_test_cases.after
			loop
				Result.append ("%T%T%Ttest_cases.extend (agent ")
				Result.append (a_test_cases.item_for_iteration.agent_name)
				Result.append (", %"")
				Result.append (a_test_cases.item_for_iteration.uuid)
				Result.append ("%")%N")
				a_test_cases.forth
			end

			Result.append ("%T%Tend%N")
		end

	feature_for_execute_test_cases: STRING
			-- Feature text for `execute_test_cases'.
		do
			create Result.make (1024)
			Result.append ("%Texecute_test_cases%N")
			Result.append ("%T%T%T--Execute test cases.%N")
			Result.append ("%T%Tdo%N")
			Result.append ("%T%T%Texecute_test_case_1%N")
			from
				test_cases.start
			until
				test_cases.after
			loop
				Result.append ("%T%T%T")
				Result.append (test_cases.item_for_iteration.agent_name)
				Result.append ("%N")
				test_cases.forth
			end
			Result.append ("%T%Tend%N")
		end

feature{NONE} -- Implementation

	test_case_number: INTEGER
		-- The number for the next generated test case executor.

	root_class_body: STRING =
	"[
class
	${CLASS_NAME}
	
inherit
	AFX_INTERPRETER
	
create
	make
		
		
feature{NONE} -- Implementation

	mark_test_case (a_recipient_class: STRING; a_recipient: STRING; a_exception_code: INTEGER; a_bpslot: INTEGER; a_tag: STRING; a_passing: BOOLEAN; a_test_case_number: INTEGER; a_dry_run: BOOLEAN; a_uuid: STRING)
			-- If `a_dry_run' is True, states of the current system should not be retrieved.
		do
			do_nothing
		end

${INITIALIZE_TEST_CASES}

${EXECUTE_TEST_CASES}

feature{NONE} -- Implementation

${TEST_CASES}

end

	]"

	execute_test_case_body: STRING =
	"[
		execute_test_case_${TEST_CASE_NUMBER}
			local
				l_tc: ${TEST_CASE_CLASS_NAME}
				l_retried: BOOLEAN
			do
				if not l_retried then
					mark_test_case ("${RECIPIENT_CLASS}", "${RECIPIENT}", ${EXCEPTION_CODE}, ${BPSLOT}, "${TAG}", ${PASSING}, ${TEST_CASE_NUMBER}, ${DRY_RUN}, "${UUID}")
					create l_tc
					l_tc.generated_test_1
				end
			rescue
				exception_count := exception_count + 1
				l_retried := True
				retry
			end
	]"

invariant

note
	copyright: "Copyright (c) 1984-2009, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

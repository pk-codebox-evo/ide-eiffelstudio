note
	description: "Summary description for {AFX_TEST_CASE_RUNNER_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_TEST_CASE_RUNNER_GENERATOR

inherit
	AFX_UTILITY
		undefine
			system
		end

	AUT_OBJECT_STATE_REQUEST_UTILITY

create
	make

feature{NONE} -- Implementation

	make (a_system: like system; a_config: like config; a_failing_test_cases: like failing_test_cases; a_passing_test_cases: like passing_test_cases)
			-- Initialize.
		do
			system := a_system
			config := a_config
			failing_test_cases := a_failing_test_cases
			passing_test_cases := a_passing_test_cases
		end

feature -- Access

	system: SYSTEM_I
			-- System under which test cases are analyzed

	config: AFX_CONFIG
			-- Config for AutoFix

	failing_test_cases: HASH_TABLE [ARRAYED_LIST [STRING], AFX_TEST_CASE_INFO]
			-- Table of failing test cases in `test_case_folder'
			-- Key is the test case id, value is the list of test cases revealing the same fault.

	passing_test_cases: HASH_TABLE [ARRAYED_LIST [STRING], AFX_TEST_CASE_INFO]
			-- Table of passing test cases in `test_case_folder'
			-- for each failing test cases.
			-- Key is the failing test cases, Value is the list of passing test cases for the same feature.

	last_class_text: detachable STRING
			-- Class test generated by last `generate'

	test_cases: LINKED_LIST [TUPLE [agent_name: STRING; uuid: STRING]]
			-- List of test cases. `agent_name' is the name of an agent to invoke a test case,
			-- `uuid' is the universal identifier for that test case.

feature -- Generation

	generate
			-- Generate the class body for the root class in `system',
			-- store result in `last_class_text'.
		local
			l_root_class_name: STRING
			l_tests: ARRAYED_LIST [STRING]
			i: INTEGER
			l_test_case: STRING
			l_test_executors: STRING
			l_tc_info: AFX_TEST_CASE_INFO
		do
			test_case_number := 1
			l_root_class_name := system.root_type.associated_class.name.twin
			create l_test_executors.make (4096 * 4)
			create test_cases.make
			from
				failing_test_cases.start
				l_tc_info := failing_test_cases.key_for_iteration
			until
				failing_test_cases.after
			loop
					-- Append failing test cases for a fault.
				l_tests := failing_test_cases.item_for_iteration
				check not l_tests.is_empty end
				append_test_case_executor (l_test_executors, l_tests.first, failing_test_cases.key_for_iteration, False, True)
				l_tests.do_all (agent append_test_case_executor (l_test_executors, ?, failing_test_cases.key_for_iteration, False, False))

					-- Append passing test cases for the same fault.
				l_tests := passing_test_cases.item (failing_test_cases.key_for_iteration)
				l_tests.do_all (agent append_test_case_executor (l_test_executors, ?, failing_test_cases.key_for_iteration, True, False))
				failing_test_cases.forth
			end

			last_class_text := root_class_body.twin
			last_class_text.replace_substring_all ("${CLASS_NAME}", l_root_class_name)
			last_class_text.replace_substring_all ("${CREATOR}", system.root_creation_name)
			last_class_text.replace_substring_all ("${INITIALIZE_TEST_CASES}", feature_for_initialize_test_cases (test_cases))
			last_class_text.replace_substring_all ("${EXECUTE_TEST_CASES}", feature_for_execute_test_cases)
			last_class_text.replace_substring_all ("${RETRIEVE_OPERAND_STATES}", feature_for_operand_states (l_tc_info.recipient_, l_tc_info.recipient_class_))
			last_class_text.replace_substring_all ("${TEST_CASES}", l_test_executors)
		end

	append_test_case_executor (a_string: STRING; a_test_case_name: STRING; a_test_info: AFX_TEST_CASE_INFO; a_passing: BOOLEAN; a_dry_run: BOOLEAN)
			-- Append test case named `a_test_case_name' as the `test_case_number'-th test case
			-- into `a_string'.
			-- `a_dry_run' indicates whether the states of the system should be retrieved when the test case is executed:
			-- True means should; False means should not.
		local
			l_test_case: STRING
			l_slices: LIST [STRING]
		do
			l_slices := string_slices (a_test_case_name, "__")
			l_test_case := execute_test_case_body.twin
			l_test_case.prepend ("%T")
			l_test_case.replace_substring_all ("${TEST_CASE_NUMBER}", test_case_number.out)
			l_test_case.replace_substring_all ("${TEST_CASE_CLASS_NAME}", a_test_case_name)
			l_test_case.replace_substring_all ("${RECIPIENT_CLASS}", a_test_info.recipient_class)
			l_test_case.replace_substring_all ("${RECIPIENT}", a_test_info.recipient)
			l_test_case.replace_substring_all ("${EXCEPTION_CODE}", a_test_info.exception_code.out)
			l_test_case.replace_substring_all ("${BPSLOT}", a_test_info.breakpoint_slot.out)
			l_test_case.replace_substring_all ("${TAG}", a_test_info.tag)
			l_test_case.replace_substring_all ("${PASSING}", a_passing.out)
			l_test_case.replace_substring_all ("${DRY_RUN}", a_dry_run.out)
			l_test_case.replace_substring_all ("${UUID}", l_slices.last)

			a_string.append (l_test_case)
			a_string.append_character ('%N')
			a_string.append_character ('%N')

			if not a_dry_run then
				test_cases.extend (["execute_test_case_" + test_case_number.out, l_slices.last])
			end

			test_case_number := test_case_number + 1
		end

feature{NONE} -- Implementation

	feature_for_initialize_test_cases (a_test_cases: like test_cases): STRING
			-- Feature text for `initialize_test_cases' to setup `a_test_cases'.
		do
			create Result.make (2048)
			Result.append ("%Tinitialize_test_cases%N")
			Result.append ("%T%T%T-- Initialize `test_cases'.%N")
			Result.append ("%T%Tdo%N")
			Result.append ("%T%T%Tcreate test_cases.make (" + a_test_cases.count.out + ")%N")
			Result.append ("%T%T%Ttest_cases.compare_objects%N")
			from
				a_test_cases.start
			until
				a_test_cases.after
			loop
				Result.append ("%T%T%Ttest_cases.extend (agent ")
				Result.append (a_test_cases.item_for_iteration.agent_name)
				Result.append (", %"")
				Result.append (a_test_cases.item_for_iteration.uuid)
				Result.append ("%")%N")
				a_test_cases.forth
			end

			Result.append ("%T%Tend%N")
		end

	feature_for_execute_test_cases: STRING
			-- Feature text for `execute_test_cases'.
		do
			create Result.make (1024)
			Result.append ("%Texecute_test_cases%N")
			Result.append ("%T%T%T--Execute test cases.%N")
			Result.append ("%T%Tdo%N")
			Result.append ("%T%T%Texecute_test_case_1%N")
			from
				test_cases.start
			until
				test_cases.after
			loop
				Result.append ("%T%T%T")
				Result.append (test_cases.item_for_iteration.agent_name)
				Result.append ("%N")
				test_cases.forth
			end
			Result.append ("%T%Tend%N")
		end

feature{NONE} -- Stats retrieval

	feature_for_operand_states (a_feature: FEATURE_I; a_context_class: CLASS_C): STRING
			-- Text for feature `operand_states'
		local
			l_types: like operand_types_of_feature
		do
			l_types := operand_types_of_feature (a_feature, a_context_class)
			create Result.make (512)
			Result.append ("%Toperand_states (a_operands: SPECIAL [detachable ANY]):  like state_type%N")
			Result.append ("%T%Tlocal%N")
			Result.append ("%T%T%Tl_queries: HASH_TABLE [HASH_TABLE [FUNCTION [ANY, TUPLE, ANY], STRING], INTEGER]%N")
			Result.append ("%T%T%Tl_tbl: HASH_TABLE [FUNCTION [ANY, TUPLE, ANY], STRING]%N")
			Result.append ("%T%Tdo%N")
			Result.append ("%T%T%Tcreate l_queries.make (a_operands.count)%N")
			from
				l_types.start
			until
				l_types.after
			loop
				Result.append (code_to_setup_queries_for_type (l_types.item_for_iteration, l_types.index - 1))
				l_types.forth
			end
			Result.append ("%T%T%TResult := object_states (l_queries)%N")
			Result.append ("%T%Tend%N")
		end

	code_to_setup_queries_for_type (a_type: TYPE_A; a_operand_id: INTEGER): STRING
			-- Code piece to setup queries for operand at `a_operand_id' position and of type `a_type'
		require
			a_type_has_class: a_type.has_associated_class
		local
			l_3tabs: STRING
			l_4tabs: STRING
			l_queries: LIST [FEATURE_I]
			l_opt_name: STRING
			l_feat_name: STRING
		do
			l_queries := queries_of_type (a_type)
			l_3tabs := "%T%T%T"
			l_4tabs := "%T%T%T%T"
			l_opt_name := "l_operand_" + a_operand_id.out

			create Result.make (256)
			Result.append (l_3tabs)
			Result.append ("if attached {")
			Result.append (a_type.actual_type.name)
			Result.append ("} a_operands.item (")
			Result.append (a_operand_id.out)
			Result.append (") as ")
			Result.append (l_opt_name)
			Result.append (" then%N")
			Result.append (l_4tabs)
			Result.append ("create l_tbl.make (")
			Result.append (l_queries.count.out)
			Result.append (")%N")
			Result.append (l_4tabs)
			Result.append ("l_tbl.compare_objects%N")
			Result.append (l_4tabs)
			Result.append ("l_queries.put (l_tbl, ")
			Result.append (a_operand_id.out)
			Result.append (")%N")
			from
				l_queries.start
			until
				l_queries.after
			loop
				l_feat_name := l_queries.item_for_iteration.feature_name.as_lower
				Result.append (l_4tabs)
				Result.append ("l_tbl.put (agent ")
				if a_type.is_basic then
					Result.append ("(l_value: ")
					Result.append (a_type.name)
					Result.append ("): ")
					Result.append (a_type.name)
					Result.append (" do Result := l_value end (")
					Result.append (l_opt_name)
					Result.append (")")
				else

					Result.append (l_opt_name)
					Result.append_character ('.')
					Result.append (l_feat_name)
				end
				Result.append (", %"")
				Result.append (l_feat_name)
				Result.append ("%")%N")
				l_queries.forth
			end

			Result.append (l_3tabs)
			Result.append ("else%N")
			Result.append (l_4tabs)
			Result.append ("create l_tbl.make (0)%N")
			Result.append (l_4tabs)
			Result.append ("l_tbl.compare_objects%N")
			Result.append (l_4tabs)
			Result.append ("l_queries.put (l_tbl, ")
			Result.append (a_operand_id.out)
			Result.append (")%N")
			Result.append (l_3tabs)
			Result.append ("end%N")
		end

	operand_types_of_feature (a_feature: FEATURE_I; a_context_class: CLASS_C): LINKED_LIST [TYPE_A]
			-- Types of operands of `a_feature', starting from the target,
			-- followed by arguments
		local
			l_args: FEAT_ARG
			l_type: TYPE_A
		do
			create Result.make
			Result.extend (a_context_class.actual_type)
			a_feature.arguments.do_all (agent Result.extend)

			from
				Result.start
			until
				Result.after
			loop
				l_type := Result.item_for_iteration
				l_type := l_type.actual_type.instantiation_in (a_context_class.actual_type, a_context_class.class_id)
				l_type := actual_type_from_formal_type (l_type, a_context_class)
				Result.replace (l_type)
				Result.forth
			end
		end

	queries_of_type (a_type: TYPE_A): LIST [FEATURE_I]
			-- List of query names from `a_type' used in state modeling
		require
			a_type_has_class: a_type.has_associated_class
		do
			Result := supported_queries_of_type (a_type)
		end

feature{NONE} -- Implementation

	test_case_number: INTEGER
		-- The number for the next generated test case executor.

	root_class_body: STRING =
	"[
class
	${CLASS_NAME}
	
inherit
	AFX_INTERPRETER
	
create
	make
		
		
feature{NONE} -- Implementation

	mark_test_case (a_recipient_class: STRING; a_recipient: STRING; a_exception_code: INTEGER; a_bpslot: INTEGER; a_tag: STRING; a_passing: BOOLEAN; a_test_case_number: INTEGER; a_dry_run: BOOLEAN; a_uuid: STRING)
			-- If `a_dry_run' is True, states of the current system should not be retrieved.
		do
			do_nothing
		end

${INITIALIZE_TEST_CASES}

${RETRIEVE_OPERAND_STATES}

${EXECUTE_TEST_CASES}

feature{NONE} -- Implementation

${TEST_CASES}

end

	]"

	execute_test_case_body: STRING =
	"[
		execute_test_case_${TEST_CASE_NUMBER}
			local
				l_tc: ${TEST_CASE_CLASS_NAME}
				l_retried: BOOLEAN
			do
				if not l_retried then
					mark_test_case ("${RECIPIENT_CLASS}", "${RECIPIENT}", ${EXCEPTION_CODE}, ${BPSLOT}, "${TAG}", ${PASSING}, ${TEST_CASE_NUMBER}, ${DRY_RUN}, "${UUID}")
					create l_tc
					l_tc.setup
					retrieve_pre_state (l_tc.operands)
					l_tc.generated_test_1
					retrieve_post_state (l_tc.operands)
				end
			rescue
				exception_count := exception_count + 1
				l_retried := True
				retry
			end
	]"

invariant

note
	copyright: "Copyright (c) 1984-2009, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end

note
	description: "Summary description for {AFX_NESTED_EXPRESSION_GENERATOR}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	AFX_NESTED_EXPRESSION_GENERATOR

inherit
	AFX_EXPRESSION_GENERATOR

	AFX_ACCESS_AGENT_UTILITY

	SHARED_WORKBENCH

	SHARED_TYPES

create
	make

feature{NONE} -- Initialization

	make is
			-- Initialize Current.
		do
			level := 2
			create accesses.make (initial_capacity)

			create expression_veto_agents.make (10)
			initialize_expression_veto_agents
		end

	initialize_expression_veto_agents is
			-- Initialize `expression_veto_agents'.
		do
			expression_veto_agents.put (
				ored_agents (
					<<result_expression_veto_agent,
					  current_expression_veto_agent
					 	>>), 1)

			expression_veto_agents.put (
				ored_agents (
					<<feature_expression_veto_agent>>), 2)
		end

feature -- Access

	level: INTEGER
			-- Level to which expression are built
			-- A level means a level of nested expression.
			-- Level 1 means a single level of expression, for example, is_empty, has (v), Result, local variables. (Current is omitted).
			-- Default: 2.

	expression_veto_agents: HASH_TABLE [FUNCTION [ANY, TUPLE [AFX_ACCESS], BOOLEAN], INTEGER]
			-- Agent to decide at each level, which expression should be included.
			-- Key is the level number, value is the decider agent at that level.
			-- If the agent returns True, the expression in its argument is included,
			-- otherwise, the expression is not included.

	accesses: ARRAYED_LIST [AFX_ACCESS]
			-- List of accesses that are generated by last `generate'

feature -- Basic operations

	generate (a_class: CLASS_C; a_feature: FEATURE_I)
			-- Generate accesses for `a_feature' in `a_class' and
			-- store results in `accesses'.
		local
			l_new: ARRAYED_LIST [AFX_ACCESS]
			l_access: AFX_ACCESS
			l_level: INTEGER
			l_veto: FUNCTION [ANY, TUPLE [AFX_ACCESS], BOOLEAN]
		do
			context_class := a_class
			context_feature := a_feature

			create accesses.make (initial_capacity)
			l_new := initial_accesses (a_class, a_feature)
			accesses.append (l_new)
			from
				l_level := 2
			until
				l_level > level
			loop
				accesses.append (accesses_at_level (accesses, l_level))
				l_level := l_level + 1
			end
		end

feature{NONE} -- Implementation

	accesses_at_level (a_accesses: like accesses; a_level: INTEGER): like accesses
			-- New accesses at level `a_level', built from existing `a_accesses'
		require
			a_level_valid: a_level > 1
		local
			l_class: CLASS_C
			l_accesses: like accesses
		do
			create Result.make (initial_capacity)
			l_accesses := a_accesses.twin
			from
				l_accesses.start
			until
				l_accesses.after
			loop
				l_class := l_accesses.item_for_iteration.type.associated_class
				check l_class /= Void end
				Result.append (feature_accesses_of_class (l_class, a_accesses, expression_veto_agents.item (a_level)))
				l_accesses.forth
			end
		end

	initial_capacity: INTEGER is 20
			-- Initial capacity for `accesses'

	feature_accesses_of_class (a_class: CLASS_C; a_args: like accesses; a_veto_agent: FUNCTION [ANY, TUPLE [AFX_ACCESS], BOOLEAN]): like accesses
			-- Feature accesses for features in `a_class' which is filtered by `a_veto_agent'.
			-- Arguments to those feature accesses are from `a_args'.
		local
			l_feats: FEATURE_TABLE
			l_cursor: CURSOR
			l_feat: FEATURE_I
		do
			create Result.make (initial_capacity)
			l_feats := a_class.feature_table
			l_cursor := l_feats.cursor
			from
				l_feats.start
			until
				l_feats.after
			loop
				l_feat := l_feats.item_for_iteration
				if not l_feat.type.is_void then
					Result.append (accesses_of_feature (a_class, l_feat, a_args, a_veto_agent))
				end
				l_feats.forth
			end
			l_feats.go_to (l_cursor)
		end

	accesses_of_feature (a_class: CLASS_C; a_feature: FEATURE_I; a_args: like accesses; a_veto_agent: FUNCTION [ANY, TUPLE [AFX_ACCESS], BOOLEAN]): like accesses
			-- Feature accesses for `a_feature' in `a_class', which is filtered by `a_veto_agent'.
			-- Arguments to those feature accesses are from `a_args'.
		require
			a_feature_is_query: not a_feature.type.is_void
		local
			i, j: INTEGER
			l_arg_count: INTEGER
			l_feat_acc: AFX_ACCESS_FEATURE
			l_args: LINKED_LIST [AFX_ACCESS]
			l_arg: AFX_ACCESS
			l_arg_type: TYPE_A
			l_arg_found: BOOLEAN

			l_arg_index: INTEGER
			l_checked: ARRAY [INTEGER]
		do
			create Result.make (initial_capacity)
			create l_args.make
			if a_feature.argument_count = 0 then
				create l_feat_acc.make (context_class, context_feature, a_feature, l_args)
				if a_veto_agent.item ([l_feat_acc]) then
					Result.extend (l_feat_acc)
				end
			else
				create l_checked.make (1, a_feature.argument_count)
				from
					j := 1
					l_arg_index := 1
					l_checked.put (1, l_arg_index)
					create l_args.make
				until
					l_arg_index = 0
				loop
					if j <= a_args.count then
						l_arg := a_args.i_th (j)
						l_arg_type := a_feature.arguments.i_th (l_arg_index).instantiation_in (a_class.actual_type, a_class.class_id).actual_type
						if l_arg.type.conform_to (context_class, l_arg_type) then
							l_args.extend (l_arg)
							if l_arg_index = a_feature.argument_count then
								create l_feat_acc.make (context_class, context_feature, a_feature, l_args.twin)
								if a_veto_agent.item ([l_feat_acc]) then
									Result.extend (l_feat_acc)
								end
								l_args.finish
								l_args.remove
								j := j + 1
							else
								l_arg_index := l_arg_index + 1
								l_checked.put (j, l_arg_index)
								j := 1
							end
						else
							j := j + 1
						end
					else
						l_args.finish
						l_args.remove
						l_arg_index := l_arg_index - 1
						if l_arg_index > 0 then
							j := l_checked.item (l_arg_index) + 1
						end
					end
				end
			end
		end

	initial_accesses (a_class: CLASS_C; a_feature: FEATURE_I): like accesses
			-- Initial accesses including possibly Current, Result, locals, arguments.
		local
			l_new: ARRAYED_LIST [AFX_ACCESS]
			l_access: AFX_ACCESS
			l_level: INTEGER
			l_veto: FUNCTION [ANY, TUPLE [AFX_ACCESS], BOOLEAN]
		do
				-- Setup the initial accesses.
			create l_new.make (initial_capacity)
			l_new.extend (create {AFX_ACCESS_CURRENT}.make (a_class, a_feature))
			if not a_feature.type.is_void then
				l_new.extend (create {AFX_ACCESS_RESULT}.make (a_class, a_feature))
			end
			l_level := 1
			l_veto := expression_veto_agents.item (l_level)
			from
				l_new.start
			until
				l_new.after
			loop
				if l_veto.item ([l_new.item_for_iteration]) then
					l_new.forth
				else
					l_new.remove
				end
			end
			Result := l_new
		end

feature{NONE} -- Implementation

	context_class: CLASS_C
			-- Context class

	context_feature: FEATURE_I
			-- Context feature

end

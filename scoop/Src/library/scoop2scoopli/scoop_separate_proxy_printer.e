indexing
	description: "Summary description for {SCOOP_SEPARATE_PROXY_PRINTER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SCOOP_SEPARATE_PROXY_PRINTER

inherit
	SCOOP_CONTEXT_AST_PRINTER
		redefine
			process_class_as,
			process_feature_clause_as,
			process_feature_as,
			process_class_type_as,
			process_generic_class_type_as,
			process_named_tuple_type_as,
			process_type_dec_as,
			process_class_list_as,
			process_create_as,
			process_like_cur_as,
			process_keyword_as,
			process_invariant_as
		end
	SCOOP_WORKBENCH
	SCOOP_CLASS_NAME

create
	make,
	make_with_default_context

feature {NONE} -- Initialization

	make (a_ctxt: ROUNDTRIP_CONTEXT)  is
			-- Initialize and set `context' with `a_ctxt'.
		require
			a_ctxt_not_void: a_ctxt /= Void
		do
			context := a_ctxt
		end

	make_with_default_context is
			-- Initialize and create context of type `ROUNDTRIP_STRING_LIST_CONTEXT'.
		do
			make (create {ROUNDTRIP_STRING_LIST_CONTEXT}.make)
		end

feature -- Access

	process is
			-- Process 'a_class_c'.
		do
			-- init
			create l_type_attribute_wrapper.make_with_context (context)
			l_type_attribute_wrapper.setup (parsed_class, match_list, true, true)
			create l_type_locals.make_with_context (context)
			l_type_locals.setup (parsed_class, match_list, true, true)
			create l_type_signature.make_with_context (context)
			l_type_signature.setup (parsed_class, match_list, true, true)

			process_class_as (class_as)
		end

feature {NONE} -- Roundtrip: process nodes

	process_class_as (l_as: CLASS_AS) is
			-- Process `l_as'.
		local
			s: STRING_AS
			l_parent_visitor: SCOOP_PROXY_PARENT_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			context.add_string ("-- This class has been generated by SCOOP2SCOOPLI")
			context.add_string ("%N-- It implements separate proxies for objects based on class " + class_as.class_name.name + "%N%N")

			-- since we produce only override classes we skip the indexing part
			-- safe_process (l_as.internal_top_indexes)
			if l_as.internal_top_indexes /= Void then
				last_index := l_as.internal_top_indexes.end_position
			end

			safe_process (l_as.frozen_keyword (match_list))
			safe_process (l_as.deferred_keyword (match_list))

				-- if class is expanded -> deferred.
			if l_as.is_expanded then
				process_leading_leaves (l_as.expanded_keyword_index)
				context.add_string ("deferred ")
			end

			safe_process (l_as.external_keyword (match_list))
			safe_process (l_as.class_keyword (match_list))
			process_leading_leaves (l_as.class_name.index)
			process_class_name (l_as.class_name, true, context, match_list)
			if l_as.class_name /= Void then
				last_index := l_as.class_name.end_position
			end

				-- process internal generics
			if l_as.internal_generics /= Void then
				process_leading_leaves (l_as.internal_generics.index)
				create l_generics_visitor.make_with_context (context)
				l_generics_visitor.setup (l_as, match_list, true, true)
				l_generics_visitor.process_class_internal_generics (l_as.internal_generics, true, false)
				last_index := l_generics_visitor.get_last_index
			end

			if class_c.name_in_upper.is_equal ("COMPARABLE") then
				io.put_string ("juppi")
			end

			safe_process (l_as.alias_keyword (match_list))
			s ?= l_as.external_class_name
			safe_process (s)
			safe_process (l_as.obsolete_keyword (match_list))
			safe_process (l_as.obsolete_message)

				-- process parents.
			create l_parent_visitor.make_with_context (context)
			l_parent_visitor.setup (class_as, match_list, true, true)
			l_parent_visitor.process_internal_conforming_parents (l_as.internal_conforming_parents)
			l_parent_visitor.process_internal_non_conforming_parents (l_as.internal_non_conforming_parents)
			if l_as.conforming_parents /= Void or l_as.non_conforming_parents /= Void then
				last_index := l_parent_visitor.get_last_index
			end

			process_creators_and_conversions

				-- process features.
			safe_process (l_as.features)

				-- add SCOOP feature.
			context.add_string ("%N%Nfeature -- Separateness")

				-- add attribute of actual object
			context.add_string ("%N%N%Timplementation_: " + l_as.class_name.name.as_upper)
				-- formal paramters
			if l_as.internal_generics /= Void then
				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, true, true)
			end
			context.add_string ("%N%T%T-- reference to actual object")

				-- process invariants (skip it - see `process_invariant_as')
--			if l_as.internal_invariant /= Void then
--				last_index := l_as.internal_invariant.invariant_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_invariant)
--			end

				-- process indexes
			-- since we produce only override classes we skip the indexing part
--			if l_as.internal_bottom_indexes /= Void then
--				last_index := l_as.internal_bottom_indexes.indexing_keyword_index - 1
--				context.add_string ("%N%N")
--				safe_process (l_as.internal_bottom_indexes)
--			end

				-- add end keyword.
			context.add_string ("%N%Nend%N")
		end

	process_feature_clause_as (l_as: FEATURE_CLAUSE_AS) is
		do
			last_index := l_as.start_position
			context.add_string ("%N%N")
			safe_process (l_as.feature_keyword)
			safe_process (l_as.clients)
			safe_process (l_as.features)
		end

	process_feature_as (l_as: FEATURE_AS) is
		local
			i, nb: INTEGER
			l_feature_name, l_feature_declaration_name, l_original_feature_name: STRING
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_assign_finder: SCOOP_PROXY_ASSIGN_FINDER
			l_string_context: ROUNDTRIP_STRING_LIST_CONTEXT
--			l_parent_object: SCOOP_PROXY_PARENT_OBJECT
		do
			set_current_feature_as (l_as)

			if l_as.is_attribute then
				process_attribute (l_as)
			elseif l_as.is_constant then
				process_constant (l_as)
			else -- routine
				create l_feature_name_visitor.make
				l_feature_name_visitor.setup (class_as, match_list, true, true)

				-- create for each feature name a new body.
				from
					i := 1
					nb := l_as.feature_names.count
				until
					i > nb
				loop
					context.add_string ("%N%N%T")
					-- process frozen key word
					last_index := l_as.feature_names.i_th (i).start_position
					safe_process (l_as.feature_names.i_th (i).frozen_keyword (match_list))

					-- process name
					l_feature_name_visitor.process_feature_name (l_as.feature_names.i_th (i), false)
					l_feature_name := l_feature_name_visitor.get_feature_name
					l_feature_name_visitor.process_feature_name (l_as.feature_names.i_th (i), true)
					l_feature_declaration_name := l_feature_name_visitor.get_feature_name
					context.add_string (l_feature_declaration_name + " ")

					-- reset assign name flag
					is_having_assign_id_name := false

					-- body (function and procedure)
					process_body (l_as.body, l_as, l_feature_name, l_feature_declaration_name)

					-- create mediator feature for assign id name
					if is_having_assign_id_name then
						create l_assign_finder
						-- create wrapper feature for assigner call
						create_assign_wrapper_feature (l_feature_name, l_as)

						-- get string context
						l_string_context ?= context

						-- get original feature name
						l_feature_name_visitor.process_original_feature_name (l_as.feature_names.i_th (i), false)
						l_original_feature_name := l_feature_name_visitor.get_feature_name

						-- if there is already a feature f with assigner in an ancestor class
						-- then create a redefine statement for the wrapper feature
						l_assign_finder.insert_redefine_for_feature_with_assigner (l_original_feature_name, l_feature_name, class_c, l_string_context)

--						
--						if l_assign_finder.has_current_or_parents_feature_with_assigner (l_original_feature_name, class_c) then
--							-- there is already a feature f with assigner in an ancestor class
--							-- create a redefine statement for the wrapper feature

--							create l_str.make_from_string (l_feature_name + "_scoop_separate_assigner_")
--							l_parent_object := scoop_workbench_objects.get_proxy_parent_object (class_c.)


--							--l_parent_object := scoop_workbench_objects.get_proxy_parent_object (l_class_c.name_in_upper)
--						end
					end

					i := i + 1
				end
			end
			set_current_feature_as_void
		end

	process_class_type_as (l_as: CLASS_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_generic_class_type_as (l_as: GENERIC_CLASS_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_named_tuple_type_as (l_as: NAMED_TUPLE_TYPE_AS) is
		do
			context.add_string ("?????????")
		end

	process_create_as (l_as: CREATE_AS) is
		local
			i, nb: INTEGER
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_feature_name: STRING
		do
			create l_feature_name_visitor.make
			l_feature_name_visitor.setup (parsed_class, match_list, true, true)
			nb := l_as.feature_list.count

			from
				i := 1
			until
				i > nb
			loop
				l_feature_name_visitor.process_feature_name (l_as.feature_list.i_th (i), false)
				l_feature_name := l_feature_name_visitor.get_feature_name

				if l_feature_name.is_equal ("default_create") then
					process_default_create_wrappers
				else
					process_creation_procedure_wrappers (l_feature_name)
				end
				i := i + 1
			end
		end

	process_like_cur_as (l_as: LIKE_CUR_AS) is
			-- process 'l_as'
		do
			context.add_string ("?????????")
		end

	process_type_dec_as (l_as: TYPE_DEC_AS) is
			-- process 'l_as' - internal argument list
		do
			process_identifier_list (l_as.id_list)
			safe_process (l_as.colon_symbol (match_list))
			-- process type
			l_type_signature.process_type (l_as.type)
		end

	process_class_list_as (l_as: CLASS_LIST_AS) is
			-- Process `l_as'.
			-- If a class name (other than ANY or NONE) appears in the list, add its separate proxy as well.
		do
			safe_process (l_as.lcurly_symbol (match_list))

			-- add class names with prefix
			if l_as /= Void then
				process_class_name_list_with_prefix (l_as, true, context, match_list)
			end
			last_index := l_as.rcurly_symbol_index - 1
			safe_process (l_as.rcurly_symbol (match_list))
		end

	process_keyword_as (l_as: KEYWORD_AS) is
			-- Process `l_as'.
		do
			if l_as.is_separate_keyword then
				-- skip	
				last_index := l_as.index
			elseif l_as.is_frozen_keyword then
				Precursor (l_as)
				-- add a space
				context.add_string (" ")
			elseif l_as.is_prefix_keyword or l_as.is_infix_keyword then
				-- skip	
				Precursor (l_as)
				context.add_string ("_")
			else
				Precursor (l_as)
			end
		end

	process_invariant_as (l_as: INVARIANT_AS) is
		do
			-- skip it
			if l_as.full_assertion_list /= Void then
				last_index := l_as.end_position
			end
		end

feature {NONE} -- Roundtrip: implementation

	process_creators_and_conversions is
			-- Process creators and convertors
		local
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- creator & convertor
			if not class_as.is_deferred then
					-- creator
				context.add_string ("%N%Ncreate%N%Tmake_from_local, set_processor_")

					-- convertor
				context.add_string ("%N%Nconvert%N%Tmake_from_local ({" + class_as.class_name.name.as_upper)

					-- formal paramters
				create l_generics_visitor.make_with_context (context)
				l_generics_visitor.setup (parsed_class, match_list, true, true)
				l_generics_visitor.process_class_internal_generics (class_as.internal_generics, true, true)

					-- convertor end
				context.add_string ("})")
			end

				-- skip original creators and convertors
			if class_as.creators /= Void or class_as.convertors /= Void then
				if class_as.features /= Void then
					last_index := class_as.features.index - 1
				elseif class_as.internal_invariant /= Void then
					last_index := class_as.internal_invariant.start_position - 1
				elseif class_as.internal_bottom_indexes /= Void then
					last_index := class_as.internal_bottom_indexes.index -1
				else
					last_index := class_as.end_keyword.index - 1
				end
			end

			-- wrapping creation instruciton
			if not class_as.is_deferred and then class_as.is_expanded then
				if class_as.creators /= Void then
					safe_process (class_as.creators)
				else
					process_default_create_wrappers
				end
			end
		end

	process_default_create_wrappers is
			-- Generate two additional procedures
			-- 'default_create_scoop_separate_class_name' and 'effective_default_create_scoop_separate_class_name'
			-- for wrapping creation instructions.
		do
			-- 'default_create_scoop_separate_class_name'
			context.add_string ("%N%Nfeature -- default creation instruction wrapper")
			context.add_string ("%N%N%Tdefault_create_scoop_separate_")
			context.add_string (class_as.class_name.name.as_lower)
			context.add_string (" (a_caller_: SCOOP_SEPARATE_CLIENT)")
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for creation procedure `default_create'.%N%T%T")
			context.add_string ("%N%T%Tdo")

			context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_default_create_scoop_separate_" + class_as.class_name.name.as_lower)
			context.add_string (")%N%T%Tend")

			-- 'effective_default_create_scoop_separate_class_name'
			context.add_string ("%N%N%Teffective_default_create_scoop_separate_" + class_as.class_name.name.as_lower + " is")
			context.add_string ("%N%T%T%T-- Wrapper for creation procedure `default_create'.")
			context.add_string ("%N%T%Tdo")
			if not class_as.class_name.name.as_upper.is_equal ("METHOD_BAS") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_STRING") or else
				class_as.class_name.name.as_upper.is_equal ("STRING_BUILDER") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_ARRAY") or else
				class_as.class_name.name.as_upper.is_equal ("SYSTEM_OBJECT")
			then
				context.add_string ("%N%T%T%Tcreate implementation_")
			end
			context.add_string ("%N%T%Tend%N")
		end

	process_creation_procedure_wrappers (a_feature_name: STRING) is
			-- Generate two additional procedures
			-- 'feature_name_scoop_separate_class_name' and 'effective_feature_name_scoop_separate_class_name'
			-- for wrapping creation instructions.
		local
			l_feature_i: FEATURE_I
			l_feature_as: FEATURE_AS
			lock_passing_possible: BOOLEAN
		do
				-- get feature
			if class_as.feature_table.has (a_feature_name) then
				l_feature_i := class_as.feature_table.item (a_feature_name)
			end

				-- only handle if not inherited.
			if l_feature_i.written_class.name_in_upper.is_equal (class_as.class_name.name.as_upper) then

				context.add_string ("%N%Nfeature -- creation instruction wrapper")

				l_feature_as := l_feature_i.body

				if l_feature_as /= Void and l_feature_as.body /= Void then

					context.add_string ("%N%N%T" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
					if l_feature_as.body.internal_arguments /= Void then
						-- print type with prefix
						safe_process (l_feature_as.body.internal_arguments)
					else
						context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE) ") --CLIENT) ")
					end

					context.add_string (" is%N%T%T%T")
					context.add_string ("-- Wrapper for creation procedure `" + a_feature_name + "'.%N%T%T")

					if l_feature_as.body.internal_arguments /= Void then
						lock_passing_possible := process_auxiliary_local_variables (l_feature_as, a_feature_name)
					else
						context.add_string ("%N%T%Tdo")
					end

					if lock_passing_possible then
						process_lock_passing_before
						context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
						process_lock_passing_after
						context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
						context.add_string ("%N%T%T%Tend")
					else
						context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false, true)
						end
						context.add_string (")")
					end
					context.add_string ("%N%T%Tend")
				end

					-- 'effective_feature_name_scoop_separate_class_name'
				context.add_string ("%N%N%Teffective_" + a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
				if l_feature_as.body.internal_arguments /= Void then
					process_flattened_formal_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string (" is")
				context.add_string ("%N%T%T%T-- Wrapper for creation procedure `" + a_feature_name + "'.")
				context.add_string ("%N%T%Tdo%N%T%T%Tcreate implementation_." + a_feature_name)
				if l_feature_as.body.internal_arguments /= Void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string ("%N%T%Tend")
			end
		end

	process_auxiliary_local_variables (a_feature: FEATURE_AS; a_feature_name: STRING): BOOLEAN is
		-- Generate auxiliary local variables for formal arguments.
		-- Generate conversion code for auxiliary variables.
		-- Return `true' if lock passing might occur (original feature takes separate formal arguments).
		local
			l_arguments: FORMAL_ARGU_DEC_LIST_AS
			l_argument_name: STRING
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			i, j, nb: INTEGER
		do
			l_arguments := a_feature.body.internal_arguments
			create l_scoop_type_visitor

			-- Does original feature take any separate arguments?
			if l_arguments /= Void then
				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, class_c)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						if l_scoop_type_visitor.is_separate then
							Result := True
						end
					end

					i := i + 1
				end
			end

			context.add_string ("%N%T%Tlocal")
			if a_feature.is_function then
				context.add_string ("%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
				process_result_type (a_feature.body.type, false, l_type_locals)
				context.add_string ("]")
			end

			if l_arguments /= Void then
				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, class_c)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						context.add_string ("%N%T%T%Taux_scoop_" + a_feature_name + ": ")
						l_type_locals.process_type (l_arguments.arguments.i_th (i).type)
					end

					i := i + 1
				end

				if Result then
					context.add_string ("%N%T%T%Tscoop_passing_locks: BOOLEAN%N%T%T%Tscoop_locked_processors_stack_size, scoop_synchronous_processors_stack_size: INTEGER_32")
				end

					-- Conversion code.
				context.add_string ("%N%T%Tdo")

				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, class_c)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						if l_scoop_type_visitor.is_class_type then
							if l_scoop_type_visitor.is_separate then

								from
									j := 1
								until
									j > l_arguments.arguments.i_th (i).id_list.count
								loop
									l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name)
									context.add_string (" /= void and then (" + l_argument_name)
									context.add_string (".processor_ /= void) then%N%T%T%T%T")
									context.add_string ("aux_scoop_" + l_argument_name + " := " + l_argument_name)
									context.add_string ("%N%T%T%T%Tif aux_scoop_" + l_argument_name + ".processor_ = void then ")
									context.add_string ("aux_scoop_" + l_argument_name + ".set_processor_ (a_caller_.processor_) end")
									context.add_string ("%N%T%T%T%Tif a_caller_.processor_.locked_processors_has (aux_scoop_" + l_argument_name + ".processor_) then ")
									context.add_string ("scoop_passing_locks := true end%N%T%T%Tend")
									j := j + 1
								end
							else
									-- Non-separate type in the original feature.
								from
									j := 1
								until
									j > l_arguments.arguments.i_th (i).id_list.count
								loop
									l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name + " /= void then ")
									context.add_string ("%N%T%T%T%Taux_scoop_" + l_argument_name + " := ")
									context.add_string (l_argument_name + ".implementation_%N%T%T%Tend")
									j := j + 1
								end
							end
						elseif l_scoop_type_visitor.is_a_like_type or l_scoop_type_visitor.is_tuple_type then
								-- Tuple type or a like type.
							from
								j := 1
							until
								j > l_arguments.arguments.i_th (i).id_list.count
							loop
								l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

								context.add_string ("%N%T%T%Taux_scoop_" + l_argument_name + " := ")
								context.add_string (l_argument_name + ".implementation_")
								j := j + 1
							end
						end
					end

					i := i + 1
				end
			else
				context.add_string ("%N%T%Tdo")
			end

			Result := Result -- and not is_lock_passing_ignored
		end

	process_formal_argument_list_with_auxiliary_variables (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller, with_brackets: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments. Substitute original arguments with auxiliary variables where necessary.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
			-- Addes brackets before and after the list if desired.
		local
			i, j, nb: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			a_prefix: STRING
		do
			if with_brackets then
				context.add_string ("(")
			end
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, class_c)

				if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
					and then not l_scoop_type_visitor.is_tuple_type then

					create a_prefix.make_from_string ("aux_scoop_")
				else
					create a_prefix.make_empty
				end

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_prefix + a_list.arguments.i_th (i).item_name (j))
					j := j + 1
				end

				if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
					context.add_string (", ")
				end

				i := i + 1
			end
			if with_brackets then
				context.add_string (")")
			end
		end

	process_flattened_formal_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list'. Substitute anchored types with flattened types.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
		do
			context.add_string ("(")
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")
			end

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, class_c)

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j) + ": ")
					l_type_signature.process_type (a_list.arguments.i_th (i).type)

					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_as_actual_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j: INTEGER
		do
			context.add_string ("(")
			nb := a_list.arguments.count

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
			until
				i > nb
			loop
				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j))
					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string (", ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_with_a_caller  (a_list: FORMAL_ARGU_DEC_LIST_AS) is
			-- Process `a_list'.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument.
		local
			i, j, nb: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
		do
			context.add_string ("(")
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, class_c)

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j) + ": ")
					l_type_signature.process_type (a_list.arguments.i_th (i).type)

					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
			last_index := a_list.end_position
		end

	process_body (l_as: BODY_AS; a_feature: FEATURE_AS; a_feature_name, a_feature_declaration_name: STRING) is
		local
			r_as: ROUTINE_AS
			ex_as: EXTERNAL_AS
			once_as: ONCE_AS
		do
			last_index := l_as.start_position - 1

			-- create internal arguments
			if l_as.internal_arguments /= Void then
				process_formal_argument_list_with_a_caller (l_as.internal_arguments)
			else
				context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE)")
			end
			safe_process (l_as.colon_symbol (match_list))

			-- process type of feature
			l_type_signature.process_type (l_as.type)
			if l_as.type /= Void then
				last_index := l_as.type.end_position
				context.add_string (" ")
			end

			safe_process (l_as.assign_keyword (match_list))

			if l_as.assigner /= Void then
				process_leading_leaves (l_as.assigner.index)

				-- remember processing assigner
				is_having_assign_id_name := true

				-- create a call to a mediator feature
				context.add_string (a_feature_name)
				context.add_string ("_scoop_separate_assigner_")

				-- set index
				last_index := l_as.assigner.index
			end

			safe_process (l_as.is_keyword (match_list))
			safe_process (l_as.indexing_clause)

			r_as ?= l_as.content
			if r_as /= Void then
				-- process function and procedure
				if l_as.type /= Void then
					if a_feature.is_deferred then
						context.add_string ("%N%T%Tdeferred%N%T%Tend")
					else
						process_function_content(r_as, a_feature, a_feature_name, a_feature_declaration_name)
					end
				else
					if a_feature.is_deferred then
						context.add_string ("%N%T%Tdeferred%N%T%Tend")
					else
						process_procedure_content(r_as, a_feature, a_feature_name, a_feature_declaration_name)
					end
				end
			end
			ex_as ?= l_as.content
			if ex_as /= Void then
				-- external_as or built_in_as
				if l_as.type /= Void then
					process_external_function_content(ex_as, a_feature, a_feature_name)
				else
					process_external_procedure_content(ex_as, a_feature, a_feature_name)
				end
			end
			once_as ?= l_as.content
			if once_as /= Void then
				if l_as.type /= Void then
					process_once_function_content(once_as, a_feature, a_feature_name)
				else
					process_once_procedure_content(once_as, a_feature, a_feature_name)
				end
			end
		end

	process_function_content (l_as: ROUTINE_AS; a_feature: FEATURE_AS; a_feature_name, a_feature_declaration_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent implementation_.")

			-- infix name?
--			if a_feature.featu then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end

			if a_feature.body.internal_arguments /= Void then
				process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false, true)
			end
			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, class_c)

			if l_class_c /= Void and then
				(l_class_c.name_in_upper.is_equal ("LINKABLE") or else l_class_c.is_deferred) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")
		end

	process_procedure_content (l_as: ROUTINE_AS; a_feature: FEATURE_AS; a_feature_name, a_feature_declaration_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent implementation_.")
				context.add_string (a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false, true)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent implementation_." + a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false, true)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent implementation_." + a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false, true)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend")
		end

	process_external_function_content (l_as: EXTERNAL_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent ")

			-- infix name?
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)

			if a_feature.body.internal_arguments /= Void then
				context.add_string (" ")
				process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false, true)
			end
			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, class_c)

			if l_class_c.name_in_upper.is_equal ("LINKABLE")
				or else (l_class_c.is_deferred and then not l_scoop_type_visitor.is_formal) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")

				-- Create wrapper for external feature. Necessary for agent creation.
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end

			-- process type
			process_result_type (a_feature.body.type, true, l_type_signature)

			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%TResult := implementation_.")
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_external_procedure_content (l_as: EXTERNAL_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend%N")

			context.add_string ("%N%T%Tend")

				-- Create wrapper for external feature. Necessary for agent creation.
			context.add_string (a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%Timplementation_." + a_feature_name)
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_once_function_content (l_as: ONCE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent ")
			-- infix name?
--			if a_feature.featu then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)

			if a_feature.body.internal_arguments /= Void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, class_c)

			if (l_class_c.is_deferred and then not l_scoop_type_visitor.is_formal) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")

			-- Create wrapper for once feature. Necessary for agent creation.
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			process_result_type (a_feature.body.type, true, l_type_signature)
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for once feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%TResult := implementation_.")
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_once_procedure_content (l_as: ONCE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend%N")

			-- Create wrapper for external feature. Necessary for agent creation.
			context.add_string (a_feature_name + "_scoop_separate_" + class_as.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%Timplementation_." + a_feature_name)
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_attribute (l_as: FEATURE_AS) is
			-- Process `l_as'.
		local
			i: INTEGER
			a_class_type: CLASS_TYPE_AS
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			a_class_type ?= l_as.body.type
			if not (a_class_type /= Void and then a_class_type.class_name.name.as_upper.is_equal ("PROCESSOR")) then

				--context.add_string ("%N%Nfeature -- non-constant attribute wrapper")

					-- add feature wrapper for every feature_name
				from
					i := 1
				until
					i > l_as.feature_names.count
				loop
					last_index := l_as.feature_names.i_th (i).start_position - 1
					context.add_string ("%N%N%T")

						-- set frozen keyword
					if l_as.feature_names.i_th (i).is_frozen then
						context.add_string ("frozen ")
					end

						-- set feature name
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))

						-- set formal argument
					context.add_string (" (a_caller_: SCOOP_SEPARATE_TYPE): ")

						-- set type
					last_index := l_as.body.type.start_position
					l_type_attribute_wrapper.process_type (l_as.body.type)

						-- keyword is and local declaration
					context.add_string (" is%N%T%Tlocal%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
					l_type_locals.process_type (l_as.body.type)
					context.add_string ("]")

						-- body and agent declarateion
					context.add_string ("%N%T%Tdo%N%T%T%Ta_function_to_evaluate := agent ")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)

						-- execution
					context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")

						-- feature result
					context.add_string ("%N%T%T%TResult ")
					create l_scoop_type_visitor
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as.body.type, class_c)
					if l_scoop_type_visitor.is_formal then
						context.add_string (":= ")
					elseif a_class_c /= Void then
						if a_class_c.is_deferred and then not l_scoop_type_visitor.is_formal  then
							context.add_string ("?= ")
						else
							context.add_string (":= ")
						end
					else
						context.add_string ("?= ")
					end
					context.add_string ("a_function_to_evaluate.last_result")

						-- create result conversion code
					process_result_conversion_code (l_as.body.type)

						-- end keyword
					context.add_string ("%N%T%Tend%N%N%T")

					-- Create wrapper for attribute. Necessary for agent creation.
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string  ("_scoop_separate_" + class_as.class_name.name.as_lower)

						-- result type
					last_index := l_as.body.type.start_position - 1
					process_result_type (l_as.body.type, true, l_type_signature)

						-- body
					context.add_string ("%N%T%T%T-- Wrapper for attribute `")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ( "'.")
					context.add_string ("%N%T%Tis do%N%T%T%TResult := implementation_.")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("%N%T%Tend")

						-- no is_keyword, no body, skip indexing clause
					i := i + 1
				end
			end
		end

	process_constant (l_as: FEATURE_AS) is
		local
			i: INTEGER
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			--context.add_string ("%N%Nfeature -- constant attribute wrapper")

				-- add feature wrapper for every feature_name
			from
				i := 1
			until
				i > l_as.feature_names.count
			loop
				last_index := l_as.feature_names.i_th (i).start_position - 1
				context.add_string ("%N%N%T")

					-- set frozen keyword
				if l_as.feature_names.i_th (i).is_frozen then
					context.add_string ("frozen ")
				end

					-- set feature name
				last_index := l_as.feature_names.i_th (i).start_position - 1
				safe_process (l_as.feature_names.i_th (i))

					-- set formal argument
				context.add_string (" (a_caller_: SCOOP_SEPARATE_TYPE): ")

					-- set type
				last_index := l_as.body.type.start_position
				l_type_attribute_wrapper.process_type (l_as.body.type)

					-- keyword is and local declaration
				context.add_string (" is%N%T%Tlocal%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
				l_type_locals.process_type (l_as.body.type)
				context.add_string ("]")

					-- body and agent declarateion
				context.add_string ("%N%T%Tdo%N%T%T%Ta_function_to_evaluate := agent ")
				last_index := l_as.feature_names.i_th (i).start_position - 1
				safe_process (l_as.feature_names.i_th (i))
				context.add_string ("_scoop_separate_" + class_as.class_name.name.as_lower)

					-- execution
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")

					-- feature result
				context.add_string ("%N%T%T%TResult ")
				create l_scoop_type_visitor
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as.body.type, class_c)
				if l_scoop_type_visitor.is_formal then
					context.add_string (":= ")
				elseif a_class_c /= Void then
					if a_class_c.name_in_upper.is_equal ("LINKABLE")
						or a_class_c.is_deferred and then not l_scoop_type_visitor.is_formal  then
						context.add_string ("?= ")
					else
						context.add_string (":= ")
					end
				else
					context.add_string ("?= ")
				end

					context.add_string ("a_function_to_evaluate.last_result")

						-- create result conversion code
					process_result_conversion_code (l_as.body.type)

						-- end keyword
					context.add_string ("%N%T%Tend%N%N%T")

					-- Create wrapper for attribute. Necessary for agent creation.
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string  ("_scoop_separate_" + class_as.class_name.name.as_lower)

						-- result type
					last_index := l_as.body.type.start_position - 1
					process_result_type (l_as.body.type, true, l_type_signature)

						-- body
					context.add_string ("%N%T%T%T-- Wrapper for attribute `")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ( "'.")
					context.add_string ("%N%T%Tis do%N%T%T%TResult := implementation_.")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("%N%T%Tend")

						-- no is_keyword, no body, skip indexing clause
					i := i + 1
			end
		end

	process_result_conversion_code (l_as: TYPE_AS) is
		-- Generate code that sets Result's processor_ to supplier's processor if necessary.
		local
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			create l_scoop_type_visitor
			a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as, class_c)
			if a_class_c /= Void then
				if not a_class_c.is_expanded
					and not l_scoop_type_visitor.is_formal
					and not l_scoop_type_visitor.is_tuple_type
				then
					context.add_string ("%N%T%T%Tif Result /= void and then (Result.implementation_ /= void or else Result.processor_ /= void) then")
					context.add_string ("%N%T%T%T%Tif Result.processor_ = void then Result.set_processor_ (processor_) end")
					context.add_string ("%N%T%T%Telse%N%T%T%T%TResult := void%N%T%T%Tend%N%T%T")
				end
			end
		end

	process_result_type (a_type: TYPE_AS; is_declared_type: BOOLEAN; l_proxy_type_visitor: SCOOP_PROXY_TYPE_VISITOR) is
			-- Process `a_type'. Precede with `:' if `is_declared_type' is true.
		local
			a_class_c: CLASS_C
			is_separate: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_like_type: LIKE_ID_AS
			l_type_a: TYPE_A
			l_formal_a: FORMAL_A
			l_feature_i: FEATURE_I
			l_name: STRING
		do
			-- process colon symbol
			if is_declared_type then
				context.add_string (": ")
			end

			-- get TYPE_C of given TYPE_AS
			create l_scoop_type_visitor
			a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_type, class_c)

			-- check if type is like type
			a_like_type ?= a_type
			if a_like_type /= Void and then a_like_type.anchor /= Void then
				if class_as.feature_table.has (a_like_type.anchor.name) then
					l_feature_i := class_as.feature_table.item (a_like_type.anchor.name)
					l_type_a := l_feature_i.type

					-- get class type for a like type and process it
					if l_type_a.is_attached then
						context.add_string (" !")
					else
						context.add_string (" ")
					end

					-- print class name
					if l_type_a.is_formal then
						l_formal_a ?= l_type_a
						create l_name.make_from_string (class_c.generics.i_th (l_formal_a.position).name.name.as_upper)
						process_class_name_str (l_name, false, context, match_list)
					else
						is_separate := l_type_a.is_separate

						-- get class name of actual type
						if l_type_a.associated_class /= Void then
							create l_name.make_from_string (l_type_a.associated_class.name_in_upper)
						else
							-- may be the case when a like type refers to a like type of generic type
							-- todo: check other implementation
							create l_name.make_from_string (l_type_a.actual_type.name.as_upper)
						end
						process_class_name_str (l_name, is_separate, context, match_list)

						-- process_class_name_str (l_type_a.associated_class.name_in_upper, is_separate, context, match_list)

						-- process generics
						if l_feature_i.access_class.is_generic then
							l_proxy_type_visitor.process_type_ast (l_feature_i.access_class.ast.internal_generics)
						end
					end
				end
			else
				-- process type
				l_proxy_type_visitor.process_type (a_type)
			end
		end

	create_assign_wrapper_feature (l_feature_name: STRING; l_as: FEATURE_AS) is
			-- create a new feature for the assign id of the current processed feature
		require
			assigner_not_void: l_as /= Void and then l_as.body /= Void and then l_as.body.assigner /= Void
		local
			assign_id_name: STRING
			l_last_index: INTEGER
		do
			l_last_index := last_index

			-- get assign id name
			assign_id_name := l_as.body.assigner.name

			-- create a call to a wrapper feature
			context.add_string ("%N%N%T")
			context.add_string (l_feature_name)
			context.add_string ("_scoop_separate_assigner_")

			-- process type
			-- first argument is the processed type of the feature
			context.add_string ("(" + assign_id_name + "_arg_1_: ")
			l_type_signature.process_type (l_as.body.type)
			-- second argument `a_caller_: SCOOP_SEPARATE_TYPE'.
			context.add_string ("; a_caller_: SCOOP_SEPARATE_TYPE; ")
			-- now append the arguments of the current feature
			if l_as.body.internal_arguments /= Void and then
				l_as.body.internal_arguments.arguments /= Void then
				last_index := l_as.body.internal_arguments.start_position
				safe_process (l_as.body.internal_arguments.arguments)
			end
			context.add_string (")")

			-- create is keyword and comment
			context.add_string (" is")
			context.add_string ("%N%T%T%T-- Wrapper for assign call")

			-- create do keyword
			context.add_string ("%N%T%Tdo")

			-- create call to the assigner feature
			context.add_string ("%N%T%T%T")
			context.add_string (assign_id_name)

			-- print argument list
			context.add_string (" (a_caller_, " + assign_id_name + "_arg_1_, ")
			process_formal_argument_list_with_auxiliary_variables (l_as.body.internal_arguments, false, false)
			context.add_string (")")

			-- end keyword
			context.add_string ("%N%T%Tend")

			-- set index back
			last_index := l_last_index
		end

feature {NONE} -- SCOOP Implementation

	process_lock_passing_before is
			-- Generate code for lock passing.
		do
			context.add_string ("%N%T%T%Tif scoop_passing_locks then")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.increment_lock_passing_counter")
			context.add_string ("%N%T%T%T%Tscoop_locked_processors_stack_size := processor_.locked_processors_count")
			context.add_string ("%N%T%T%T%Tscoop_synchronous_processors_stack_size := processor_.synchronous_processors_count")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_push_whole_stack (a_caller_.processor_.locked_processors)")
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_push_whole_stack (a_caller_.processor_.synchronous_processors)")
		end

	process_lock_passing_after is
			-- Generate code for cleanup after lock passing.
		do
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_trim (scoop_synchronous_processors_stack_size)")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_trim (scoop_locked_processors_stack_size)")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.decrement_lock_passing_counter")			
			context.add_string ("%N%T%T%Telse")
		end


feature{NONE} -- Implementation

	is_having_assign_id_name: BOOLEAN
			-- is the current processed body containing an assign id name.

	l_type_attribute_wrapper: SCOOP_PROXY_TYPE_ATTRIBUTE_WRAPPER_PRINTER
			-- prints 'TYPE_AS' to the context

	l_type_locals: SCOOP_PROXY_TYPE_LOCALS_PRINTER
			-- prints 'TYPE_AS' to the context

	l_type_signature: SCOOP_PROXY_TYPE_SIGNATURE_PRINTER
			-- prints 'TYPE_AS' to the context

end

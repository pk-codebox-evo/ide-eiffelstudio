indexing
	description: "Summary description for {SCOOP_SEPARATE_PROXY_PRINTER}."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	SCOOP_SEPARATE_PROXY_PRINTER

inherit
	AST_ROUNDTRIP_ITERATOR
		redefine
			process_class_as,
			process_feature_clause_as,
			process_feature_as,
			process_class_type_as,
			process_generic_class_type_as,
			process_named_tuple_type_as,
			process_class_list_as,
			process_create_as,
			process_keyword_as,
			process_symbol_as,
			process_bool_as,
			process_char_as,
			process_typed_char_as,
			process_result_as,
			process_retry_as,
			process_unique_as,
			process_deferred_as,
			process_void_as,
			process_string_as,
			process_verbatim_string_as,
			process_current_as,
			process_integer_as,
			process_real_as,
			process_id_as,
			process_break_as,
			process_symbol_stub_as,
			process_like_cur_as,
			reset
		end

create
	make,
	make_with_default_context

feature {NONE} -- Initialization

	make (a_ctxt: ROUNDTRIP_CONTEXT; a_class_list: SCOOP_SEPARATE_CLASS_LIST; a_system: SYSTEM_I)  is
			-- Initialize and set `context' with `a_ctxt'.
		require
			a_ctxt_not_void: a_ctxt /= Void
			a_class_list_not_void: a_class_list /= Void
			a_system_not_void: a_system /= Void
		do
			context := a_ctxt
			scoop_classes := a_class_list
			system := a_system

			-- init
			is_filter_detachable := false
			is_set_prefix := false
			is_attribute_wrapper := false
			is_processing_locals := false
			is_processing_signature := false
		end

	make_with_default_context(a_system: SYSTEM_I; a_class_list: SCOOP_SEPARATE_CLASS_LIST) is
			-- Initialize and create context of type `ROUNDTRIP_STRING_LIST_CONTEXT'.
		require
			a_class_list_not_void: a_class_list /= Void
		do
			make (create {ROUNDTRIP_STRING_LIST_CONTEXT}.make, a_class_list, a_system)
		end

feature -- Access

	process (a_class_c: CLASS_C) is
			-- Process 'a_class_c'.
		require
			a_class_c_not_void: a_class_c /= Void
		do
			current_class_c := a_class_c
			process_class_as (current_class_c.ast)
		end

feature -- Context setting

	set_context (a_ctxt: ROUNDTRIP_CONTEXT) is
			-- Set `context' with `a_ctxt'.
		require
			a_ctxt_not_void: a_ctxt /= Void
		do
			context := a_ctxt
		ensure
			context_set: context = a_ctxt
		end

	get_context: STRING is
			-- Get `context'.
		do
			Result := context.string_representation
		end

	reset is
			-- Reset visitor for a next visit.
		do
			Precursor
			context.clear
		end

feature -- Roundtrip: process nodes

	process_class_as (l_as: CLASS_AS) is
			-- Process `l_as'.
		local
			s: STRING_AS
			l_parent_visitor: SCOOP_PROXY_PARENT_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			-- save class.
			current_class := l_as

			context.add_string ("-- This class has been generated by SCOOP2SCOOPLI%N")
			context.add_string ("-- It implements separate proxies for objects based on class " + current_class.class_name.name + "%N%N")

			safe_process (l_as.internal_top_indexes)
			safe_process (l_as.frozen_keyword (match_list))
			safe_process (l_as.deferred_keyword (match_list))

				-- if class is expanded -> deferred.
			if l_as.is_expanded then
				process_leading_leaves (l_as.expanded_keyword_index)
				context.add_string ("deferred ")
			end

			safe_process (l_as.external_keyword (match_list))
			safe_process (l_as.class_keyword (match_list))
			process_class_name

			create l_generics_visitor.make_with_system (context, scoop_classes, system)
			l_generics_visitor.setup (l_as, match_list, true, true)
			l_generics_visitor.process_class_internal_generics (l_as.internal_generics)

			safe_process (l_as.alias_keyword (match_list))
			s ?= l_as.external_class_name
			safe_process (s)
			safe_process (l_as.obsolete_keyword (match_list))
			safe_process (l_as.obsolete_message)

				-- process parents.
			create l_parent_visitor.make_with_system (context, scoop_classes, system)
			l_parent_visitor.setup (current_class, match_list, true, true)
			l_parent_visitor.process_internal_conforming_parents (l_as.internal_conforming_parents)
			l_parent_visitor.process_internal_non_conforming_parents (l_as.internal_non_conforming_parents)

			process_creators_and_conversions

			safe_process (l_as.features)

				-- add SCOOP feature
			context.add_string ("%N%Nfeature -- Separateness")

				-- add attribute of actual object
			context.add_string ("%N%N%Timplementation_: " + l_as.class_name.name.as_upper)
				-- formal paramters
			safe_process (current_class.internal_generics)
			context.add_string ("%N%T%T-- reference to actual object")

--			safe_process (l_as.internal_invariant)
			safe_process (l_as.internal_bottom_indexes)

			last_index := l_as.end_keyword.index - 1

			context.add_string ("%N%N")
			safe_process (l_as.end_keyword)
		end

	process_feature_clause_as (l_as: FEATURE_CLAUSE_AS) is
		do
			last_index := l_as.start_position
			context.add_string ("%N%N")
			safe_process (l_as.feature_keyword)
			safe_process (l_as.clients)
			safe_process (l_as.features)
		end

	process_feature_as (l_as: FEATURE_AS) is
		local
			i, nb: INTEGER
			l_feature_name: STRING
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
		do
			if l_as.is_attribute then
				process_attribute (l_as)
			elseif l_as.is_constant then
				process_constant (l_as)
			else -- routine
				create l_feature_name_visitor
				l_feature_name_visitor.setup (current_class, match_list, true, true)

				-- create for each feature name a new body.
				from
					i := 1
					nb := l_as.feature_names.count
				until
					i > nb
				loop
					context.add_string ("%N%N%T")
					-- process frozen key word
					last_index := l_as.feature_names.i_th (i).start_position
					safe_process (l_as.feature_names.i_th (i).frozen_keyword (match_list))

					-- process name
					l_feature_name := l_feature_name_visitor.process_feature_name (l_as.feature_names.i_th (i))
					context.add_string (l_feature_name + " ")

					-- body (function and procedure)
					process_body (l_as.body, l_as, l_feature_name)
					
					i := i + 1
				end
			end
		end

	process_class_type_as (l_as: CLASS_TYPE_AS) is
		local
			l_is_set_prefix: like is_set_prefix
			l_is_filter_detachable: like is_filter_detachable
			l_class_name_visitor: SCOOP_CLASS_NAME_VISITOR
		do
			safe_process (l_as.lcurly_symbol (match_list))

				-- special handling
			if is_attribute_wrapper then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if l_as.is_expanded then
					is_set_prefix := false
					is_filter_detachable := true
				else
					is_set_prefix := true
					is_filter_detachable := true
				end
			elseif is_processing_signature then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if l_as.is_separate and l_as.is_expanded then
					is_set_prefix := true
					is_filter_detachable := true
				else
					is_set_prefix := false
					is_filter_detachable := false
				end
			end

				-- attached? detached?
			if is_filter_detachable then
				if l_as.has_detachable_mark then
					-- skip flag
					last_index := l_as.attachment_mark_index
				else
					safe_process (l_as.attachment_mark (match_list))
				end
			else
				safe_process (l_as.attachment_mark (match_list))
			end

			safe_process (l_as.expanded_keyword (match_list))

			create l_class_name_visitor.make_with_context (context, scoop_classes)
			l_class_name_visitor.setup (current_class, match_list, true, true)
			l_class_name_visitor.process_id (l_as.class_name, is_set_prefix)

			safe_process (l_as.rcurly_symbol (match_list))

				-- reset local settings
			if is_attribute_wrapper
				or is_processing_signature then
				is_set_prefix := l_is_set_prefix
				is_filter_detachable := l_is_filter_detachable
			end
		end

	process_generic_class_type_as (l_as: GENERIC_CLASS_TYPE_AS) is
		local
			l_is_set_prefix: like is_set_prefix
			l_is_filter_detachable: like is_filter_detachable
			l_class_name_visitor: SCOOP_CLASS_NAME_VISITOR
			l_generics_visitor: SCOOP_GENERICS_VISITOR
		do
			safe_process (l_as.lcurly_symbol (match_list))

				-- special handling
			if is_attribute_wrapper then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if l_as.is_expanded then
					is_set_prefix := false
					is_filter_detachable := true
				else
					is_set_prefix := true
					is_filter_detachable := true
				end
			elseif is_processing_locals then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if (l_as.is_separate and not l_as.is_expanded) then
					is_set_prefix := true
				else
					is_set_prefix := false
				end
				is_filter_detachable := true
			elseif is_processing_signature then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if l_as.is_separate and l_as.is_expanded then
					is_set_prefix := true
					is_filter_detachable := true
				else
					is_set_prefix := false
					is_filter_detachable := false
				end
			end

				-- attached? detached?
			if is_filter_detachable then
				if l_as.has_detachable_mark then
					-- skip flag
					last_index := l_as.attachment_mark_index
				else
					safe_process (l_as.attachment_mark (match_list))
				end
			else
				safe_process (l_as.attachment_mark (match_list))
			end

			safe_process (l_as.expanded_keyword (match_list))

			create l_class_name_visitor.make_with_context (context, scoop_classes)
			l_class_name_visitor.setup (current_class, match_list, true, true)
			l_class_name_visitor.process_id (l_as.class_name, is_set_prefix)

				-- reset local settings
			if is_attribute_wrapper
				or is_processing_locals or is_processing_signature then
				is_set_prefix := l_is_set_prefix
				is_filter_detachable := l_is_filter_detachable
			end

				-- no `SCOOP_SEPARATE__' prefix, not detachable.
			create l_generics_visitor.make_with_system (context, scoop_classes, system)
			l_generics_visitor.setup (current_class, match_list, true, true)
			l_generics_visitor.process_type_internal_generics (l_as.internal_generics)

			safe_process (l_as.rcurly_symbol (match_list))
		end

	process_named_tuple_type_as (l_as: NAMED_TUPLE_TYPE_AS) is
		local
			l_is_set_prefix: like is_set_prefix
			l_is_filter_detachable: like is_filter_detachable
			l_class_name_visitor: SCOOP_CLASS_NAME_VISITOR
		do
			safe_process (l_as.lcurly_symbol (match_list))

				-- special handling
			if is_attribute_wrapper then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				is_set_prefix := false
				is_filter_detachable := true
			elseif is_processing_signature then
				l_is_set_prefix := is_set_prefix
				l_is_filter_detachable := is_filter_detachable
				if l_as.is_separate then
					is_set_prefix := true
					is_filter_detachable := true
				else
					is_set_prefix := false
					is_filter_detachable := false
				end
			end

				-- attached? detached?
			if is_filter_detachable then
				if l_as.has_detachable_mark then
					-- skip flag
					last_index := l_as.attachment_mark_index
				else
					safe_process (l_as.attachment_mark (match_list))
				end
			else
				safe_process (l_as.attachment_mark (match_list))
			end

			create l_class_name_visitor.make_with_context (context, scoop_classes)
			l_class_name_visitor.setup (current_class, match_list, true, true)
			l_class_name_visitor.process_id (l_as.class_name, is_set_prefix)

			safe_process (l_as.parameters)
			safe_process (l_as.rcurly_symbol (match_list))

				-- reset local settings
			if is_attribute_wrapper
				or is_processing_signature then
				is_set_prefix := l_is_set_prefix
				is_filter_detachable := l_is_filter_detachable
			end
		end

	process_create_as (l_as: CREATE_AS) is
		local
			i, nb: INTEGER
			l_feature_name_visitor: SCOOP_FEATURE_NAME_VISITOR
			l_feature_name: STRING
		do
			create l_feature_name_visitor
			nb := l_as.feature_list.count

			from
				i := 1
			until
				i > nb
			loop
				l_feature_name := l_feature_name_visitor.process_feature_name (l_as.feature_list.i_th (i))

				if l_feature_name.is_equal ("default_create") then
					process_default_create_wrappers
				else
					process_creation_procedure_wrappers (l_feature_name)
				end
				i := i + 1
			end
		end

	process_like_cur_as (l_as: LIKE_CUR_AS) is
		do
			safe_process (l_as.lcurly_symbol (match_list))

				-- attached? detached?
			if is_filter_detachable then
				if l_as.has_detachable_mark then
					-- skip flag
					last_index := l_as.attachment_mark_index
				else
					safe_process (l_as.attachment_mark (match_list))
				end
			else
				safe_process (l_as.attachment_mark (match_list))
			end

			safe_process (l_as.like_keyword (match_list))

			if is_processing_locals then
				context.add_string ("implementation_")
			else
				safe_process (l_as.current_keyword)
			end

			safe_process (l_as.rcurly_symbol (match_list))
		end

	process_class_list_as (l_as: CLASS_LIST_AS) is
			-- Process `l_as'.
			-- If a class name (other than ANY or NONE) appears in the list, add its separate proxy as well.
		local
			l_class_name_visitor: SCOOP_CLASS_NAME_VISITOR
		do
			safe_process (l_as.lcurly_symbol (match_list))

			-- add class names with prefix
			if l_as /= Void then
				create l_class_name_visitor.make_with_context (context, scoop_classes)
				l_class_name_visitor.setup (current_class, match_list, true, true)
				l_class_name_visitor.process_class_list_with_prefix (l_as, true)
			end
			last_index := l_as.rcurly_symbol_index - 1
			safe_process (l_as.rcurly_symbol (match_list))
		end

feature -- Roundtrip: process leaf

	process_break_as (l_as: BREAK_AS) is
			-- Process `l_as'.
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_keyword_as (l_as: KEYWORD_AS) is
			-- Process `l_as'.
		do
			if l_as.is_separate_keyword then
				-- skip	
				last_index := l_as.index
			elseif l_as.is_frozen_keyword then
				Precursor (l_as)
				put_string (l_as)
				-- add a space
				context.add_string (" ")
			elseif l_as.is_prefix_keyword or l_as.is_infix_keyword then
				-- skip	
				Precursor (l_as)
				put_string (l_as)
				context.add_string ("_")
			else
				Precursor (l_as)
				put_string (l_as)
			end
		end

	process_symbol_as (l_as: SYMBOL_AS) is
			-- Process `l_as'.
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_symbol_stub_as (l_as: SYMBOL_STUB_AS) is
			-- Process `l_as'.
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_bool_as (l_as: BOOL_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_char_as (l_as: CHAR_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_typed_char_as (l_as: TYPED_CHAR_AS) is
			-- Process `l_as'.
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_result_as (l_as: RESULT_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_retry_as (l_as: RETRY_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_unique_as (l_as: UNIQUE_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_deferred_as (l_as: DEFERRED_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_void_as (l_as: VOID_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_string_as (l_as: STRING_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_verbatim_string_as (l_as: VERBATIM_STRING_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_current_as (l_as: CURRENT_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

	process_integer_as (l_as: INTEGER_AS) is
		do
			Precursor (l_as)
			context.add_string (l_as.number_text (match_list))
		end

	process_real_as (l_as: REAL_AS) is
		do
			Precursor (l_as)
			context.add_string (l_as.number_text (match_list))
		end

	process_id_as (l_as: ID_AS) is
		do
			Precursor (l_as)
			put_string (l_as)
		end

feature -- Roundtrip: implementation

	process_class_name is
			-- Process class name.
		do
			process_leading_leaves (current_class.class_name.index)
			context.add_string ("SCOOP_SEPARATE__")
			context.add_string (current_class.class_name.name.as_upper)
		end

	process_internal_conforming_parents (l_as: PARENT_LIST_AS) is
			-- Process `l_as'.
		do
			safe_process (l_as)

			-- add ...?
		end

	process_creators_and_conversions is
			-- Process creators and convertors
		do
			-- creator & convertor
			if not current_class.is_deferred then
					-- creator
				context.add_string ("%N%Ncreate%N%Tmake_from_local, set_processor_")

					-- convertor
				context.add_string ("%N%Nconvert%N%Tmake_from_local ({" + current_class.class_name.name.as_upper)

					-- formal paramters
				safe_process (current_class.internal_generics)

					-- convertor end
				context.add_string ("})")
			end

				-- skip original creators and convertors
			if current_class.creators /= Void or current_class.convertors /= Void then
				if current_class.features /= Void then
					last_index := current_class.features.index - 1
				elseif current_class.internal_invariant /= Void then
					last_index := current_class.internal_invariant.start_position - 1
				elseif current_class.internal_bottom_indexes /= Void then
					last_index := current_class.internal_bottom_indexes.index -1
				else
					last_index := current_class.end_keyword.index - 1
				end
			end

			-- wrapping creation instruciton
			if not current_class.is_deferred and then current_class.is_expanded then
				if current_class.creators /= Void then
					safe_process (current_class.creators)
				else
					process_default_create_wrappers
				end
			end
		end

	process_default_create_wrappers is
			-- Generate two additional procedures
			-- 'default_create_scoop_separate_class_name' and 'effective_default_create_scoop_separate_class_name'
			-- for wrapping creation instructions.
		do
			-- 'default_create_scoop_separate_class_name'
			context.add_string ("%N%Nfeature -- default creation instruction wrapper")
			context.add_string ("%N%N%Tdefault_create_scoop_separate_")
			context.add_string (current_class.class_name.name.as_lower)
			context.add_string (" (a_caller_: SCOOP_SEPARATE_CLIENT)")
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for creation procedure `default_create'.%N%T%T")
			context.add_string ("%N%T%Tdo")

			context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_default_create_scoop_separate_" + current_class.class_name.name.as_lower)
			context.add_string (")%N%T%Tend")

			-- 'effective_default_create_scoop_separate_class_name'
			context.add_string ("%N%N%Teffective_default_create_scoop_separate_" + current_class.class_name.name.as_lower + " is")
			context.add_string ("%N%T%T%T-- Wrapper for creation procedure `default_create'.")
			context.add_string ("%N%T%Tdo")
			if not current_class.class_name.name.as_upper.is_equal ("METHOD_BAS") or else
				current_class.class_name.name.as_upper.is_equal ("SYSTEM_STRING") or else
				current_class.class_name.name.as_upper.is_equal ("STRING_BUILDER") or else
				current_class.class_name.name.as_upper.is_equal ("SYSTEM_ARRAY") or else
				current_class.class_name.name.as_upper.is_equal ("SYSTEM_OBJECT")
			then
				context.add_string ("%N%T%T%Tcreate implementation_")
			end
			context.add_string ("%N%T%Tend%N")
		end

	process_creation_procedure_wrappers (a_feature_name: STRING) is
			-- Generate two additional procedures
			-- 'feature_name_scoop_separate_class_name' and 'effective_feature_name_scoop_separate_class_name'
			-- for wrapping creation instructions.
		local
			l_feature_i: FEATURE_I
			l_feature_as: FEATURE_AS
			lock_passing_possible: BOOLEAN
		do
				-- get feature
			if current_class.feature_table.has (a_feature_name) then
				l_feature_i := current_class.feature_table.item (a_feature_name)
			end

				-- only handle if not inherited.
			if l_feature_i.written_class.name_in_upper.is_equal (current_class.class_name.name.as_upper) then

				context.add_string ("%N%Nfeature -- creation instruction wrapper")

				l_feature_as := l_feature_i.body

				if l_feature_as /= Void and l_feature_as.body /= Void then

					context.add_string ("%N%N%T" + a_feature_name + "_scoop_separate_" + current_class.class_name.name.as_lower + " ")
					if l_feature_as.body.internal_arguments /= Void then
						is_set_prefix := true
						safe_process (l_feature_as.body.internal_arguments)
						is_set_prefix := false
					else
						context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE) ") --CLIENT) ")
					end

					context.add_string (" is%N%T%T%T")
					context.add_string ("-- Wrapper for creation procedure `" + a_feature_name + "'.%N%T%T")

					if l_feature_as.body.internal_arguments /= Void then
						lock_passing_possible := process_auxiliary_local_variables (l_feature_as, a_feature_name)
					else
						context.add_string ("%N%T%Tdo")
					end

					if lock_passing_possible then
						process_lock_passing_before
						context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false)
						end
						context.add_string (")")
						process_lock_passing_after
						context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false)
						end
						context.add_string (")")
						context.add_string ("%N%T%T%Tend")
					else
						context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent effective_" + a_feature_name)
						context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
						if l_feature_as.body.internal_arguments /= Void then
							context.add_string (" ")
							process_formal_argument_list_with_auxiliary_variables (l_feature_as.body.internal_arguments, false)
						end
						context.add_string (")")
					end
					context.add_string ("%N%T%Tend")
				end

					-- 'effective_feature_name_scoop_separate_class_name'
				context.add_string ("%N%N%Teffective_" + a_feature_name + "_scoop_separate_" + current_class.class_name.name.as_lower + " ")
				if l_feature_as.body.internal_arguments /= Void then
					process_flattened_formal_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string (" is")
				context.add_string ("%N%T%T%T-- Wrapper for creation procedure `" + a_feature_name + "'.")
				context.add_string ("%N%T%Tdo%N%T%T%Tcreate implementation_." + a_feature_name)
				if l_feature_as.body.internal_arguments /= Void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (l_feature_as.body.internal_arguments, false)
				end
				context.add_string ("%N%T%Tend")
			end
		end

	process_auxiliary_local_variables (a_feature: FEATURE_AS; a_feature_name: STRING): BOOLEAN is
		-- Generate auxiliary local variables for formal arguments.
		-- Generate conversion code for auxiliary variables.
		-- Return `true' if lock passing might occur (original feature takes separate formal arguments).
		local
			l_arguments: FORMAL_ARGU_DEC_LIST_AS
			l_argument_name: STRING
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			i, j, nb: INTEGER
		do
			l_arguments := a_feature.body.internal_arguments
			create l_scoop_type_visitor

			-- Does original feature take any separate arguments?
			if l_arguments /= Void then
				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, current_class_c, system)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						if l_scoop_type_visitor.is_separate then
							Result := True
						end
					end

					i := i + 1
				end
			end

			context.add_string ("%N%T%Tlocal")
			if a_feature.is_function then
				context.add_string ("%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
				is_processing_locals := true
				process_result_type (a_feature.body.type, false)
				is_processing_locals := false
				context.add_string ("]")
			end

			if l_arguments /= Void then
				is_processing_locals := true
				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, current_class_c, system)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						context.add_string ("%N%T%T%Taux_scoop_" + a_feature_name + ": ")
						safe_process (l_arguments.arguments.i_th (i).type)
					end

					i := i + 1
				end
				is_processing_locals := false

				if Result then
					context.add_string ("%N%T%T%Tscoop_passing_locks: BOOLEAN%N%T%T%Tscoop_locked_processors_stack_size, scoop_synchronous_processors_stack_size: INTEGER_32")
				end

					-- Conversion code.
				context.add_string ("%N%T%Tdo")

				from
					nb := l_arguments.arguments.count
					i := 1
				until
					i > nb
				loop
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_arguments.arguments.i_th (i).type, current_class_c, system)

					if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
						and then not l_scoop_type_visitor.is_tuple_type then

						if l_scoop_type_visitor.is_class_type then
							if l_scoop_type_visitor.is_separate then

								from
									j := 1
								until
									j > l_arguments.arguments.i_th (i).id_list.count
								loop
									l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name)
									context.add_string (" /= void and then (" + l_argument_name)
									context.add_string (".processor_ /= void) then%N%T%T%T%T")
									context.add_string ("aux_scoop_" + l_argument_name + " := " + l_argument_name)
									context.add_string ("%N%T%T%T%Tif aux_scoop_" + l_argument_name + ".processor_ = void then ")
									context.add_string ("aux_scoop_" + l_argument_name + ".set_processor_ (a_caller_.processor_) end")
									context.add_string ("%N%T%T%T%Tif a_caller_.processor_.locked_processors_has (aux_scoop_" + l_argument_name + ".processor_) then ")
									context.add_string ("scoop_passing_locks := true end%N%T%T%Tend")
									j := j + 1
								end
							else
									-- Non-separate type in the original feature.
								from
									j := 1
								until
									j > l_arguments.arguments.i_th (i).id_list.count
								loop
									l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

									context.add_string ("%N%T%T%Tif " + l_argument_name + " /= void then ")
									context.add_string ("%N%T%T%T%Taux_scoop_" + l_argument_name + " := ")
									context.add_string (l_argument_name + ".implementation_%N%T%T%Tend")
									j := j + 1
								end
							end
						elseif l_scoop_type_visitor.is_a_like_type or l_scoop_type_visitor.is_tuple_type then
								-- Tuple type or a like type.
							from
								j := 1
							until
								j > l_arguments.arguments.i_th (i).id_list.count
							loop
								l_argument_name := l_arguments.arguments.i_th (i).item_name (j)

								context.add_string ("%N%T%T%Taux_scoop_" + l_argument_name + " := ")
								context.add_string (l_argument_name + ".implementation_")
								j := j + 1
							end
						end
					end

					i := i + 1
				end
			else
				context.add_string ("%N%T%Tdo")
			end

			Result := Result -- and not is_lock_passing_ignored
		end

	process_formal_argument_list_with_auxiliary_variables (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments. Substitute original arguments with auxiliary variables where necessary.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, j, nb: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
			a_prefix: STRING
		do
			context.add_string ("(")
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, current_class_c, system)

				if not l_scoop_type_visitor.is_formal and then not a_class_c.is_expanded
					and then not l_scoop_type_visitor.is_tuple_type then

					create a_prefix.make_from_string ("aux_scoop_")
				else
					create a_prefix.make_empty
				end

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_prefix + a_list.arguments.i_th (i).item_name (j))
					j := j + 1
				end

				if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
					context.add_string (", ")
				end

				i := i + 1
			end
			context.add_string (")")
		end

	process_flattened_formal_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list'. Substitute anchored types with flattened types.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
		do
			context.add_string ("(")
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			if with_a_caller then
				context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")
			end

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, current_class_c, system)

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j) + ": ")
					is_processing_signature := true
					safe_process (a_list.arguments.i_th (i).type)
					is_processing_signature := false

					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_as_actual_argument_list (a_list: FORMAL_ARGU_DEC_LIST_AS; with_a_caller: BOOLEAN) is
			-- Process `a_list' as if it is list of actual arguments.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument if `with_a_caller' is true.
		local
			i, nb, j: INTEGER
		do
			context.add_string ("(")
			nb := a_list.arguments.count

			if with_a_caller then
				context.add_string ("a_caller_, ")
			end

			from
				i := 1
			until
				i > nb
			loop
				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j))
					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string (", ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
		end

	process_formal_argument_list_with_a_caller  (a_list: FORMAL_ARGU_DEC_LIST_AS) is
			-- Process `a_list'.
			-- Insert `a_caller_: SCOOP_SEPARATE_TYPE' as first argument.
		local
			i, j, nb: INTEGER
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_class_c: CLASS_C
		do
			context.add_string ("(")
			nb := a_list.arguments.count
			create l_scoop_type_visitor

			context.add_string ("a_caller_: SCOOP_SEPARATE_TYPE; ")

			from
				i := 1
			until
				i > nb
			loop
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_list.arguments.i_th (i).type, current_class_c, system)

				from
					j := 1
				until
					j > a_list.arguments.i_th (i).id_list.count
				loop
					context.add_string (a_list.arguments.i_th (i).item_name (j) + ": ")
					is_processing_signature := true
					safe_process (a_list.arguments.i_th (i).type)
					is_processing_signature := false

					if i < nb or (i = nb and j < a_list.arguments.i_th (i).id_list.count) then
						context.add_string ("; ")
					end
					j := j + 1
				end
				i := i + 1
			end
			context.add_string (")")
			last_index := a_list.end_position
		end

	process_body (l_as: BODY_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			r_as: ROUTINE_AS
			ex_as: EXTERNAL_AS
			once_as: ONCE_AS
		do
			last_index := l_as.start_position - 1

			is_processing_signature := true
			if l_as.internal_arguments /= Void then
				process_formal_argument_list_with_a_caller (l_as.internal_arguments)
			else
				context.add_string ("(a_caller_: SCOOP_SEPARATE_TYPE)")
			end
			safe_process (l_as.colon_symbol (match_list))
			safe_process (l_as.type)
			is_processing_signature := false

			safe_process (l_as.assign_keyword (match_list))
			safe_process (l_as.assigner)

			safe_process (l_as.is_keyword (match_list))
			safe_process (l_as.indexing_clause)

			r_as ?= l_as.content
			if r_as /= Void then
				-- process function and procedure
				if l_as.type /= Void then
					if a_feature.is_deferred then
						context.add_string ("%N%T%Tdeferred%N%T%Tend")
					else
						process_function_content(r_as, a_feature, a_feature_name)
					end
				else
					if a_feature.is_deferred then
						context.add_string ("%N%T%Tdeferred%N%T%Tend")
					else
						process_procedure_content(r_as, a_feature, a_feature_name)
					end
				end
			end
			ex_as ?= l_as.content
			if ex_as /= Void then
				-- external_as or built_in_as
				if l_as.type /= Void then
					process_external_function_content(ex_as, a_feature, a_feature_name)
				else
					process_external_procedure_content(ex_as, a_feature, a_feature_name)
				end
			end
			once_as ?= l_as.content
			if once_as /= Void then
				if l_as.type /= Void then
					process_once_function_content(once_as, a_feature, a_feature_name)
				else
					process_once_procedure_content(once_as, a_feature, a_feature_name)
				end
			end
		end

	process_function_content (l_as: ROUTINE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent implementation_.")

			-- infix name?
--			if a_feature.featu then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end

			if a_feature.body.internal_arguments /= Void then
				process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false)
			end
			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, current_class_c, system)

			if l_class_c.name_in_upper.is_equal ("LINKABLE")
				or else (l_class_c.is_deferred and then not l_scoop_type_visitor.is_formal) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")
		end

	process_procedure_content (l_as: ROUTINE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent implementation_.")
				context.add_string (a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent implementation_." + a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent implementation_." + a_feature_name)
				if a_feature.body.internal_arguments /= void then
					process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend")
		end

	process_external_function_content (l_as: EXTERNAL_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent ")

			-- infix name?
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)

			if a_feature.body.internal_arguments /= Void then
				context.add_string (" ")
				process_formal_argument_list_with_auxiliary_variables (a_feature.body.internal_arguments, false)
			end
			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, current_class_c, system)

			if l_class_c.name_in_upper.is_equal ("LINKABLE")
				or else (l_class_c.is_deferred and then not l_scoop_type_visitor.is_formal) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")

				-- Create wrapper for external feature. Necessary for agent creation.
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			is_processing_signature := true
			process_result_type (a_feature.body.type, true)
			is_processing_signature := false
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%TResult := implementation_.")
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_external_procedure_content (l_as: EXTERNAL_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend%N")

			context.add_string ("%N%T%Tend")

				-- Create wrapper for external feature. Necessary for agent creation.
			context.add_string (a_feature_name + "_scoop_separate_" + current_class.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%Timplementation_." + a_feature_name)
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_once_function_content (l_as: ONCE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			l_class_c: CLASS_C
		do
			create l_scoop_type_visitor

			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			context.add_string ("%N%T%T%Ta_function_to_evaluate := agent ")
			-- infix name?
--			if a_feature.featu then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)

			if a_feature.body.internal_arguments /= Void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
				context.add_string ("%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")
			end

			context.add_string ("%N%T%T%TResult ")

			l_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_feature.body.type, current_class_c, system)

			if (l_class_c.is_deferred and then not l_scoop_type_visitor.is_formal) then

				context.add_string ("?= ")
			else
				context.add_string (":= ")
			end
			context.add_string ("a_function_to_evaluate.last_result")

			process_result_conversion_code (a_feature.body.type)
			context.add_string ("%N%T%Tend%N")

			-- Create wrapper for once feature. Necessary for agent creation.
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			is_processing_signature := true
			process_result_type (a_feature.body.type, true)
			is_processing_signature := false
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for once feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%TResult := implementation_.")
--			if an_infix_name = void then
				context.add_string (a_feature_name)
--			else
--				context.add_string (an_infix_name.non_infix_name)
--			end
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_once_procedure_content (l_as: ONCE_AS; a_feature: FEATURE_AS; a_feature_name: STRING) is
		local
			lock_passing_possible: BOOLEAN
		do
			lock_passing_possible := process_auxiliary_local_variables (a_feature, a_feature_name)

			if lock_passing_possible then
				process_lock_passing_before
				context.add_string ("%N%T%T%T%Tscoop_synchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
				process_lock_passing_after
				context.add_string ("%N%T%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")%N%T%T%Tend")
			else
				context.add_string ("%N%T%T%Tscoop_asynchronous_execute (a_caller_, agent " + a_feature_name)
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)
				if a_feature.body.internal_arguments /= void then
					context.add_string (" ")
					process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
				end
				context.add_string (")")
			end
			context.add_string ("%N%T%Tend%N")

			-- Create wrapper for external feature. Necessary for agent creation.
			context.add_string (a_feature_name + "_scoop_separate_" + current_class.class_name.name.as_lower + " ")
			if a_feature.body.internal_arguments /= void then
				process_flattened_formal_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string (" is%N%T%T%T")
			context.add_string ("-- Wrapper for external feature `" + a_feature_name + "'.")
			context.add_string ("%N%T%Tdo%N%T%T%Timplementation_." + a_feature_name)
			if a_feature.body.internal_arguments /= void then
				context.add_string (" ")
				process_formal_argument_list_as_actual_argument_list (a_feature.body.internal_arguments, false)
			end
			context.add_string ("%N%T%Tend")
		end

	process_attribute (l_as: FEATURE_AS) is
			-- Process `l_as'.
		local
			i: INTEGER
			a_class_type: CLASS_TYPE_AS
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			a_class_type ?= l_as.body.type
			if not (a_class_type /= Void and then a_class_type.class_name.name.as_upper.is_equal ("PROCESSOR")) then

				--context.add_string ("%N%Nfeature -- non-constant attribute wrapper")

					-- add feature wrapper for every feature_name
				from
					i := 1
				until
					i > l_as.feature_names.count
				loop
					last_index := l_as.feature_names.i_th (i).start_position - 1
					context.add_string ("%N%N%T")

						-- set frozen keyword
					if l_as.feature_names.i_th (i).is_frozen then
						context.add_string ("frozen ")
					end

						-- set feature name
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))

						-- set formal argument
					context.add_string (" (a_caller_: SCOOP_SEPARATE_TYPE): ")

						-- set type
					is_attribute_wrapper := true
					last_index := l_as.body.type.start_position
					safe_process (l_as.body.type)
					is_attribute_wrapper := false

						-- keyword is and local declaration
					context.add_string (" is%N%T%Tlocal%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
					is_processing_locals := true
					safe_process (l_as.body.type)
					is_processing_locals := false
					context.add_string ("]")

						-- body and agent declarateion
					context.add_string ("%N%T%Tdo%N%T%T%Ta_function_to_evaluate := agent ")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)

						-- execution
					context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")

						-- feature result
					context.add_string ("%N%T%T%TResult ")
					create l_scoop_type_visitor
					a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as.body.type, current_class_c, system)
					if l_scoop_type_visitor.is_generic_parameter then
						context.add_string (":= ")
					elseif a_class_c /= Void then
						if a_class_c.is_deferred and then not l_scoop_type_visitor.is_formal  then
							context.add_string ("?= ")
						else
							context.add_string (":= ")
						end
					else
						context.add_string ("?= ")
					end
					context.add_string ("a_function_to_evaluate.last_result")

						-- create result conversion code
					process_result_conversion_code (l_as.body.type)

						-- end keyword
					context.add_string ("%N%T%Tend%N%N%T")

					-- Create wrapper for attribute. Necessary for agent creation.
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string  ("_scoop_separate_" + current_class.class_name.name.as_lower)

						-- result type
					last_index := l_as.body.type.start_position - 1
					is_processing_signature := true
					process_result_type (l_as.body.type, true)
					is_processing_signature := false

						-- body
					context.add_string ("%N%T%T%T-- Wrapper for attribute `")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ( "'.")
					context.add_string ("%N%T%Tis do%N%T%T%TResult := implementation_.")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("%N%T%Tend")

						-- Assignments?
--					safe_process (l_as.assign_keyword (match_list))
--					safe_process (l_as.assigner)

						-- no is_keyword, no body, skip indexing clause
					i := i + 1
				end
			end
		end

	process_constant (l_as: FEATURE_AS) is
		local
			i: INTEGER
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			--context.add_string ("%N%Nfeature -- constant attribute wrapper")

				-- add feature wrapper for every feature_name
			from
				i := 1
			until
				i > l_as.feature_names.count
			loop
				last_index := l_as.feature_names.i_th (i).start_position - 1
				context.add_string ("%N%N%T")

					-- set frozen keyword
				if l_as.feature_names.i_th (i).is_frozen then
					context.add_string ("frozen ")
				end

					-- set feature name
				last_index := l_as.feature_names.i_th (i).start_position - 1
				safe_process (l_as.feature_names.i_th (i))

					-- set formal argument
				context.add_string (" (a_caller_: SCOOP_SEPARATE_TYPE): ")

					-- set type
				is_attribute_wrapper := true
				last_index := l_as.body.type.start_position
				safe_process (l_as.body.type)
				is_attribute_wrapper := false

					-- keyword is and local declaration
				context.add_string (" is%N%T%Tlocal%N%T%T%Ta_function_to_evaluate: FUNCTION [ANY, TUPLE, ")
				is_processing_locals := true
				safe_process (l_as.body.type)
				is_processing_locals := false
				context.add_string ("]")

					-- body and agent declarateion
				context.add_string ("%N%T%Tdo%N%T%T%Ta_function_to_evaluate := agent ")
				last_index := l_as.feature_names.i_th (i).start_position - 1
				safe_process (l_as.feature_names.i_th (i))
				context.add_string ("_scoop_separate_" + current_class.class_name.name.as_lower)

					-- execution
				context.add_string ("%N%T%T%Tscoop_synchronous_execute (a_caller_, a_function_to_evaluate)")

					-- feature result
				context.add_string ("%N%T%T%TResult ")
				create l_scoop_type_visitor
				a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as.body.type, current_class_c, system)
				if l_scoop_type_visitor.is_generic_parameter then
					context.add_string (":= ")
				elseif a_class_c /= Void then
					context.add_string ("&&& Linkable: &&&" + a_class_c.name_in_upper)
					if a_class_c.name_in_upper.is_equal ("LINKABLE")
						or a_class_c.is_deferred and then not l_scoop_type_visitor.is_formal  then
						context.add_string ("?= ")
					else
						context.add_string (":= ")
					end
				else
					context.add_string ("?= ")
				end

					context.add_string ("a_function_to_evaluate.last_result")

						-- create result conversion code
					process_result_conversion_code (l_as.body.type)

						-- end keyword
					context.add_string ("%N%T%Tend%N%N%T")

					-- Create wrapper for attribute. Necessary for agent creation.
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string  ("_scoop_separate_" + current_class.class_name.name.as_lower)

						-- result type
					last_index := l_as.body.type.start_position - 1
					is_processing_signature := true
					process_result_type (l_as.body.type, true)
					is_processing_signature := false

						-- body
					context.add_string ("%N%T%T%T-- Wrapper for attribute `")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ( "'.")
					context.add_string ("%N%T%Tis do%N%T%T%TResult := implementation_.")
					last_index := l_as.feature_names.i_th (i).start_position - 1
					safe_process (l_as.feature_names.i_th (i))
					context.add_string ("%N%T%Tend")

						-- Assignments?
--					safe_process (l_as.assign_keyword (match_list))
--					safe_process (l_as.assigner)

						-- no is_keyword, no body, skip indexing clause
					i := i + 1
			end
		end

	process_result_conversion_code (l_as: TYPE_AS) is
		-- Generate code that sets Result's processor_ to supplier's processor if necessary.
		local
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
		do
			create l_scoop_type_visitor
			a_class_c := l_scoop_type_visitor.evaluate_class_from_type (l_as, current_class_c, system)
			if a_class_c /= Void then
				if not a_class_c.is_expanded
					and not l_scoop_type_visitor.is_formal
					and not l_scoop_type_visitor.is_tuple_type
				then
					context.add_string ("%N%T%T%Tif Result /= void and then (Result.implementation_ /= void or else Result.processor_ /= void) then")
					context.add_string ("%N%T%T%T%Tif Result.processor_ = void then Result.set_processor_ (processor_) end")
					context.add_string ("%N%T%T%Telse%N%T%T%T%TResult := void%N%T%T%Tend%N%T%T")
				end
			end
		end

	process_result_type (a_type: TYPE_AS; is_declared_type: BOOLEAN) is
			-- Process `a_type'. Precede with `:' if `is_declared_type' is true.
		local
			a_class_c: CLASS_C
			l_scoop_type_visitor: SCOOP_TYPE_VISITOR
			a_like_type: LIKE_ID_AS
		do
			if is_declared_type then
				context.add_string (": ")
			end

			create l_scoop_type_visitor
			a_class_c := l_scoop_type_visitor.evaluate_class_from_type (a_type, current_class_c, system)

			a_like_type ?= a_type
			if a_like_type /= Void and then a_like_type.anchor /= Void then
				if current_class.feature_table.has (a_like_type.anchor.name) then
					if current_class.feature_table.item (a_like_type.anchor.name).type.is_attached then
						context.add_string (" !")
					else
						context.add_string (" ")
					end
					if current_class.feature_table.item (a_like_type.anchor.name).type.is_separate then
						context.add_string ("SCOOP_SEPARATE__")
					end
					context.add_string (current_class.feature_table.item (a_like_type.anchor.name).type.associated_class.ast.class_name.name)
					safe_process (current_class.feature_table.item (a_like_type.anchor.name).access_class.ast.internal_generics)
				end
			else
				safe_process (a_type)
			end
		end


feature

	text: STRING is
			-- Generated Eiffel code
		do
			Result := context.string_representation
		end

feature {NONE} -- SCOOP Implementation

	process_lock_passing_before is
			-- Generate code for lock passing.
		do
			context.add_string ("%N%T%T%Tif scoop_passing_locks then")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.increment_lock_passing_counter")
			context.add_string ("%N%T%T%T%Tscoop_locked_processors_stack_size := processor_.locked_processors_count")
			context.add_string ("%N%T%T%T%Tscoop_synchronous_processors_stack_size := processor_.synchronous_processors_count")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_push_whole_stack (a_caller_.processor_.locked_processors)")
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_push_whole_stack (a_caller_.processor_.synchronous_processors)")
		end

	process_lock_passing_after is
			-- Generate code for cleanup after lock passing.
		do
			context.add_string ("%N%T%T%T%Tprocessor_.synchronous_processors_trim (scoop_synchronous_processors_stack_size)")
			context.add_string ("%N%T%T%T%Tprocessor_.locked_processors_trim (scoop_locked_processors_stack_size)")
--			context.add_string ("%N%T%T%T%Ta_caller_.processor_.decrement_lock_passing_counter")			
			context.add_string ("%N%T%T%Telse")
		end


feature{NONE} -- Implementation

	context: ROUNDTRIP_CONTEXT
			-- Context used to store generated code

	scoop_classes: SCOOP_SEPARATE_CLASS_LIST
			-- contains all classes which have to be processed.

	put_string (l_as: LEAF_AS) is
			-- Print text contained in `l_as' into `context'.
		require
			l_as_in_list: l_as.index >= start_index and then l_as.index <= end_index
		do
			context.add_string (l_as.text (match_list))
		end

	current_class: CLASS_AS
			-- Class currently processed.

	current_class_c: CLASS_C
			-- Class currently processed.		

	system: SYSTEM_I
			-- Shared access to the current system

	is_filter_detachable: BOOLEAN
			-- Flag for filter the detachable flag

	is_set_prefix: BOOLEAN
			-- Flag for setting 'SCOOP_SEPARATE__'

	is_attribute_wrapper: BOOLEAN
			-- Flag to indicate a attribute wrapping handling

	is_processing_locals: BOOLEAN
			-- Flag to indicate local processing

	is_processing_signature: BOOLEAN
			-- Flag to indicate signature processing

invariant
	context_not_void: context /= Void

end
